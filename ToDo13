# file: todo_pythonista.py
# version: 3.5
# - Safer navigation pushes: global 0.3s guard to prevent double-present / "animation in progress" errors
# - DateTimePicker title shown above header; month/year stays in header
# - Bigger/easier Back button on New Entry
# - Categories actions (Rename / Clear / Cancel) fully wired
# - Colour picker remains fixed-palette (no custom hex entry)
# - New FilterView for advanced filtering (name, dates, colour, completed)h
#Current theme colour: #D4AF37

import ui
import dialogs
import json
import os
import re
import time
from datetime import datetime, date, timedelta
from calendar import monthrange
from pathlib import Path
import calendar

# Knowledge centre storage
KNOWLEDGE_DATA_FILE = Path(__file__).with_name('knowledge_store.json')

# ==== 1) DROP-IN: Haptics helper ====
try:
    from objc_util import ObjCClass
    _UINotif  = ObjCClass('UINotificationFeedbackGenerator')
    _UIImpact = ObjCClass('UIImpactFeedbackGenerator')
    _UISelect = ObjCClass('UISelectionFeedbackGenerator')
except Exception:
    _UINotif = _UIImpact = _UISelect = None

def _make_safe_summary(content, max_len=80):
    """
    Turn arbitrary content into a safe, single line summary.

    - Handles None, empty strings, and whitespace
    - Never raises IndexError
    """
    if content is None:
        return ''
    text = str(content).strip()
    if not text:
        return ''
    lines = text.splitlines()
    if not lines:
        return ''
    return lines[0][:max_len]

def haptic_success():
    try:
        if not _UINotif: return
        _UINotif.new().notificationOccurred_(0)
    except Exception:
        pass

def haptic_selection():
    try:
        if not _UISelect: return
        _UISelect.new().selectionChanged()
    except Exception:
        pass

def haptic_impact_light():
    try:
        if not _UIImpact: return
        _UIImpact.alloc().initWithStyle_(0).impactOccurred()
    except Exception:
        pass

# -------------------------
# Paths
# -------------------------
DATA_PATH = Path(os.path.expanduser('~/Documents')) / 'todo_data.json'
CATS_PATH = Path(os.path.expanduser('~/Documents')) / 'todo_categories.json'

# -------------------------
# Palette + helpers  (White REMOVED)
# -------------------------
_PALETTE = [
    ('Red',    '#FF3B30'),
    ('Orange', '#FF9500'),
    ('Yellow', '#FFCC00'),
    ('Green',  '#34C759'),
    ('Teal',   '#30B0C7'),
    ('Blue',   '#007AFF'),
    ('Purple', '#AF52DE'),
    ('Pink',   '#FF2D55'),
    ('Gray',   '#8E8E93'),
]

HEX_RE = re.compile(r'^\s*#?([0-9a-fA-F]{6})\s*$')

def hex_to_rgb(hex_str):
    m = HEX_RE.match(str(hex_str or ''))
    if not m:
        raise ValueError('Invalid hex')
    h = m.group(1)
    return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

def hex_to_ui_color(hex_str):
    r, g, b = hex_to_rgb(hex_str)
    return (r/255.0, g/255.0, b/255.0)
    
def style_colour_label(label, hx):
    """
    Apply text styling for a category/colour label.

    - Normal colours use the hex colour for the text.
    - Pure black uses black text with a thin white border so it is visible.
    """
    try:
        hx_norm = (hx or '').strip().lower()
        if hx_norm == '#000000':
            # Black text on black background needs help
            label.text_color = 'black'
            label.background_color = 'black'
            label.border_width = 1
            label.border_color = (1.0, 1.0, 1.0, 0.8)
            try:
                label.corner_radius = 4
            except Exception:
                pass
        else:
            label.text_color = hex_to_ui_color(hx)
            label.border_width = 0
            # Keep background transparent for non black
            # so it blends with the existing theme
    except Exception:
        label.text_color = (0.85, 0.85, 0.9)

def best_text_color_for_bg(hex_str):
    r, g, b = hex_to_rgb(hex_str)
    luminance = 0.2126*r + 0.7152*g + 0.0722*b
    return 'black' if luminance > 140 else 'white'

def set_textfield_rounded(tf):
    try:
        bs = getattr(ui, 'TEXT_FIELD_ROUNDED', None)
        tf.border_style = bs if isinstance(bs, int) else 3
    except Exception:
        pass

# -------------------------
# ISO timestamp helpers + pretty labels
# -------------------------
ISO_RE = re.compile(r'^\s*(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2})(?::(\d{2}))?\s*$')

def parse_iso_or_now(s):
    if not s:
        return datetime.now()
    m = ISO_RE.match(s)
    if not m:
        return datetime.now()
    y, mo, d, h, mi, ss = m.groups()
    return datetime(int(y), int(mo), int(d), int(h), int(mi), int(ss or 0))

def to_iso_seconds(dt):
    return dt.strftime('%Y-%m-%dT%H:%M:%S')

def _fmt_dt_for_label(iso_str):
    if not (iso_str or '').strip():
        return 'Not set'
    dt = parse_iso_or_now(iso_str)

    time_part = dt.strftime('%I:%M %p').lstrip('0')   # 9:05 PM
    date_part = dt.strftime('%d/%m/%Y')               # 07/12/2025

    return f'{time_part} - {date_part}'


# -------------------------
# Persistence
# -------------------------
def load_items():
    if DATA_PATH.exists():
        try:
            with open(DATA_PATH, 'r', encoding='utf-8') as f:
                data = json.load(f)
            items = []
            for it in data if isinstance(data, list) else []:
                if isinstance(it, dict):
                    title = str(it.get('title', 'Untitled'))
                    done = bool(it.get('done', False))
                    color = (it.get('color') or '#8E8E93')
                    try:
                        hex_to_rgb(color)
                    except Exception:
                        color = '#8E8E93'
                    created_at = it.get('created_at') or datetime.now().isoformat()
                    due_at = it.get('due_at', '')
                    items.append({'title': title, 'done': done, 'color': color,
                                  'created_at': created_at, 'due_at': due_at})
            if items:
                return items
        except Exception:
            pass
    now = datetime.now().isoformat()
    return [
        {'title': 'Swipe left to delete', 'done': False, 'color': '#FFCC00', 'created_at': now, 'due_at': ''},
        {'title': 'Example (gray)',       'done': True,  'color': '#8E8E93', 'created_at': now, 'due_at': ''},
        {'title': 'Orange sample',        'done': False, 'color': '#FF9500', 'created_at': now, 'due_at': ''},
        {'title': 'Blue sample',          'done': False, 'color': '#007AFF', 'created_at': now, 'due_at': ''},
    ]

def save_items(items):
    try:
        with open(DATA_PATH, 'w', encoding='utf-8') as f:
            json.dump(items, f, indent=2, ensure_ascii=False)
    except Exception as e:
        dialogs.hud_alert(f'Could not save items: {e}', 'error', 1.2)

def load_categories():
    if CATS_PATH.exists():
        try:
            with open(CATS_PATH, 'r', encoding='utf-8') as f:
                data = json.load(f)
            cats = {}
            for k, v in (data.items() if isinstance(data, dict) else []):
                try:
                    hex_to_rgb(k)
                    cats[k] = str(v or '').strip()
                except Exception:
                    pass
            return cats
        except Exception:
            pass
    return {}

def save_categories(cats):
    try:
        with open(CATS_PATH, 'w', encoding='utf-8') as f:
            json.dump(cats, f, indent=2, ensure_ascii=False)
    except Exception as e:
        dialogs.hud_alert(f'Could not save categories: {e}', 'error', 1.2)

# -------------------------
# CATEGORY RENAME HELPER
# -------------------------
def reuse_rename_category(hex_color, categories, palette, title_prefix='Rename'):
    try:
        _ = hex_to_rgb(hex_color)
    except Exception:
        dialogs.hud_alert('Invalid colour selected.', 'error', 1.0)
        return False
    base_name = next((n for n, h in palette if h == hex_color), 'Colour')
    current_custom = (categories.get(hex_color, '') or '').strip()
    prefill = current_custom or base_name
    try:
        new_name = dialogs.input_alert(f'{title_prefix} {base_name}',
                                       'Enter category name:', prefill)
    except Exception:
        return False
    new_name = (new_name or '').strip()
    if new_name == current_custom:
        return False
    categories[hex_color] = new_name
    try:
        save_categories(categories)
    except Exception:
        dialogs.hud_alert('Could not save category.', 'error', 1.2)
        return False
    return True
    

def _open_category_rename(self, sender):
    view = CategoryRenameView(self, _PALETTE, title='Edit Categories')
    _safe_push(self.navigation_view, view)
    

# -------------------------
# Shared palette renderer (multi-select)
# -------------------------
class _PaletteDataSource(object):
    """
    Data source + delegate for the colour palette table (used by MultiColorPicker).

    palette        : list of (base_name, hex)
    categories     : dict hex -> custom name (optional)
    selected_hexes : set of hex strings currently selected
    on_toggle      : callback(new_selected_set) when a colour is toggled
    """

    def __init__(self, palette, categories, selected_hexes=None, on_toggle=None):
        # Build a stable list of (display_name, hex) for rows
        self._items = []
        categories = categories or {}
        for base_name, hx in (palette or []):
            display_name = categories.get(hx, '') or base_name
            self._items.append((display_name, hx))

        self._selected = set(selected_hexes or [])
        self._on_toggle = on_toggle

    # --- table basics ---
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._items)

    def tableview_cell_for_row(self, tv, section, row):
        name, hx = self._items[row]
        cell = ui.TableViewCell()
        cell.background_color = 'black'

        # Name label in its own colour
        cell.text_label.text = name
        cell.text_label.font = ('<System>', 15)
        try:
            cell.text_label.text_color = hex_to_ui_color(hx)
        except Exception:
            cell.text_label.text_color = (0.85, 0.85, 0.9)

        # Square colour chip on the right
        chip = ui.View()
        chip_size = 18
        chip.frame = (
            cell.content_view.width - chip_size - 16,
            (tv.row_height - chip_size) / 2.0,
            chip_size,
            chip_size,
        )
        chip.flex = 'L'
        chip.corner_radius = 4
        chip.border_width = 1
        chip.border_color = (0.8, 0.8, 0.85)
        try:
            chip.background_color = hex_to_ui_color(hx)
        except Exception:
            chip.background_color = 'white'
        cell.content_view.add_subview(chip)

        # Checkmark if selected
        cell.accessory_type = 'checkmark' if hx in self._selected else 'none'
        return cell

    def tableview_did_select(self, tv, section, row):
        name, hx = self._items[row]

        # Toggle selection
        if hx in self._selected:
            self._selected.remove(hx)
        else:
            self._selected.add(hx)

        # Notify parent picker
        if callable(self._on_toggle):
            try:
                self._on_toggle(set(self._selected))
            except Exception:
                pass

        tv.reload_data()
        try:
            haptic_selection()
        except Exception:
            pass

    # Helper for parent to reset selected set after Clear
    def set_selected(self, selected_hexes):
        self._selected = set(selected_hexes or [])


# -------------------------
# Color picker (single pick)
# -------------------------
class ColorPicker(ui.View):
    """
    Simple single-colour picker.

    - One row per palette entry
    - Text is in the category colour
    - Colour chip on the right
    - Tap row to return (hex, label) and pop
    """

    def __init__(self, palette, cats, on_pick=None, title='Pick a Colour'):
        super().__init__(frame=(0, 0, 420, 520))
        self.name = title
        self.background_color = 'black'
        self.on_pick = on_pick
        self.cats = cats or {}
        self.palette = list(palette or [])

        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 48
        self.table.data_source = self
        self.table.delegate = self
        self.add_subview(self.table)

        self.left_button_items = [ui.ButtonItem(title='Cancel', action=self._cancel)]

    def layout(self):
        self.table.frame = self.bounds

    def _cancel(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _choose_and_pop(self, hexc, label):
        if callable(self.on_pick):
            try:
                self.on_pick(hexc, label)
            except Exception:
                pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    # table data source / delegate
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self.palette)

    def tableview_cell_for_row(self, tv, section, row):
        base_name, hexc = self.palette[row]
        display = self.cats.get(hexc, '') or base_name

        cell = ui.TableViewCell()
        cell.background_color = 'black'
        cell.text_label.text = display
        cell.text_label.font = ('<System>', 15)
        try:
            cell.text_label.text_color = hex_to_ui_color(hexc)
        except Exception:
            cell.text_label.text_color = (0.85, 0.85, 0.9)

        chip = ui.View()
        chip_size = 18
        chip.frame = (
            cell.content_view.width - chip_size - 16,
            (tv.row_height - chip_size) / 2.0,
            chip_size,
            chip_size,
        )
        chip.flex = 'L'
        chip.corner_radius = 4
        chip.border_width = 1
        chip.border_color = (0.8, 0.8, 0.85)
        try:
            chip.background_color = hex_to_ui_color(hexc)
        except Exception:
            chip.background_color = 'white'
        cell.content_view.add_subview(chip)

        return cell

    def tableview_did_select(self, tv, section, row):
        base_name, hexc = self.palette[row]
        label = self.cats.get(hexc, '') or base_name
        self._choose_and_pop(hexc, label)


# -------------------------
# Multi Color picker (uses _PaletteDataSource)
# -------------------------
class MultiColorPicker(ui.View):
    """
    Simple colour / category picker screen.

    palette        : list of (base_name, hex)
    categories     : dict hex -> custom name (optional)
    selected_hexes : set of selected hex strings
    on_apply       : callback(selected_hexes_set)
    title          : nav title
    """

    def __init__(self, palette, categories, selected_hexes=None, on_apply=None, title='Pick Colours'):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = title
        self.background_color = 'black'

        self.palette = list(palette or [])
        self.categories = categories or {}
        self.selected_hexes = set(selected_hexes or [])
        self.on_apply = on_apply

        # Nav buttons
        self.left_button_items = [
            ui.ButtonItem(title='Back', action=self._back)
        ]
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        # Table
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 48
        self.add_subview(self.table)

        # Data source that will keep self.selected_hexes in sync
        def _on_toggle(new_selected):
            self.selected_hexes = set(new_selected)

        self.ds = _PaletteDataSource(
            self.palette,
            self.categories,
            self.selected_hexes,
            on_toggle=_on_toggle
        )
        self.table.data_source = self.ds
        self.table.delegate = self.ds

    def layout(self):
        self.table.frame = self.bounds

    # --- actions ---
    def _clear(self, sender):
        self.selected_hexes.clear()
        self.ds.set_selected(self.selected_hexes)
        self.table.reload_data()
        try:
            haptic_selection()
        except Exception:
            pass

    def _save(self, sender):
        if callable(self.on_apply):
            try:
                self.on_apply(set(self.selected_hexes))
            except Exception:
                pass
        try:
            haptic_success()
        except Exception:
            pass

        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()


# -------------------------
# Category rename data source + view
# -------------------------
class _CategoryRenameDataSource(object):
    """
    Data source + delegate for the CategoryRenameView.

    palette    : list of (base_name, hex)
    categories : dict hex -> custom name (optional)
    on_tap     : callback(row_index) when a row is tapped
    """

    def __init__(self, palette, categories, on_tap):
        self._items = []
        categories = categories or {}
        for base_name, hx in (palette or []):
            display_name = categories.get(hx, '') or base_name
            self._items.append((display_name, base_name, hx))

        self.on_tap = on_tap
        self.selected_index = None

    # --- table basics ---
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._items)

    def tableview_cell_for_row(self, tv, section, row):
        display_name, base_name, hx = self._items[row]

        cell = ui.TableViewCell()
        cell.background_color = 'black'

        # Full row is the hit box, no accessory / checkmark
        cell.text_label.text = display_name
        cell.text_label.font = ('<System>', 16)
        try:
            cell.text_label.text_color = hex_to_ui_color(hx)
        except Exception:
            cell.text_label.text_color = (0.85, 0.85, 0.9)

        # Subtle selected highlight
        if row == self.selected_index:
            cell.background_color = (0.20, 0.20, 0.24)
        else:
            cell.background_color = 'black'

        # Remove any reuse artefacts
        cell.accessory_type = 'none'
        return cell

    def tableview_did_select(self, tv, section, row):
        self.selected_index = row
        tv.reload_data()

        if callable(self.on_tap):
            try:
                self.on_tap(row)
            except Exception:
                pass

        try:
            haptic_selection()
        except Exception:
            pass


class CategoryRenameView(ui.View):
    """
    Category management screen for RENAMING categories.

    - Shows one row per colour / category (like MultiColorPicker)
    - Text is in the category colour
    - No checkmarks and no colour chip
    - Tap anywhere on a row to select it
    - Bottom button opens Rename / Clear / Cancel actions

    Usage example from your main view:
        view = CategoryRenameView(self, _PALETTE, title='Edit Categories')
        _safe_push(self.navigation_view, view)
    """

    def __init__(self, owner, palette, title='Edit Categories'):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = title
        self.background_color = 'black'

        self.owner = owner
        self.palette = list(palette or [])
        # This is your shared mapping hex -> custom name
        self.categories = getattr(owner, 'categories', {}) or {}
        self.selected_index = None  # which row is "active" for rename

        # Nav bar: simple Back only (no Save/Cancel here; edits apply instantly)
        self.left_button_items = [
            ui.ButtonItem(title='Back', action=self._back)
        ]

        # Table of categories
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 48
        self.add_subview(self.table)

        # Data source / delegate to draw rows and handle taps
        def _row_tapped(row_index):
            self._on_row_selected(row_index)

        self.ds = _CategoryRenameDataSource(
            self.palette,
            self.categories,
            on_tap=_row_tapped
        )
        self.table.data_source = self.ds
        self.table.delegate = self.ds

        # Bottom action button: Rename / Clear / Cancel
        self.action_btn = ui.Button(title='Rename / Clear / Cancel')
        self.action_btn.corner_radius = 10
        self.action_btn.border_width = 1
        try:
            self.action_btn.border_color = hex_to_ui_color('#D4AF37')
            self.action_btn.background_color = hex_to_ui_color('#D4AF37')
        except Exception:
            self.action_btn.border_color = (0.90, 0.80, 0.45)
            self.action_btn.background_color = (0.90, 0.80, 0.45)
        self.action_btn.tint_color = 'black'
        self.action_btn.font = ('<System-Bold>', 16)
        self.action_btn.enabled = False  # enabled once a row is tapped
        self.action_btn.action = self._action_pressed
        self.add_subview(self.action_btn)

    def layout(self):
        # Layout table + bottom button
        margin = 16
        btn_h = 48

        self.action_btn.width = self.width - 2 * margin
        self.action_btn.x = margin
        self.action_btn.y = self.height - btn_h - margin

        self.table.frame = (0, 0, self.width, self.action_btn.y - margin)

    # --- selection handling ---
    def _on_row_selected(self, row_index):
        self.selected_index = row_index
        self.ds.selected_index = row_index
        self.table.reload_data()
        self.action_btn.enabled = True

    # --- button: Rename / Clear / Cancel ---
    def _action_pressed(self, sender):
        if self.selected_index is None:
            dialogs.hud_alert('Select a category first.', 'warning', 0.7)
            return

        display_name, base_name, hx = self.ds._items[self.selected_index]

        # Primary action sheet: Rename / Clear / Cancel
        choice = dialogs.alert(
            'Edit category',
            f'Category: {display_name}',
            'Rename',
            'Clear name',
            'Cancel',
            hide_cancel_button=True
        )

        # choice: 1=Rename, 2=Clear name, 3=Cancel
        if choice == 1:
            self._rename_category(base_name, hx, display_name)
        elif choice == 2:
            self._clear_category_name(base_name, hx, display_name)
        else:
            # Cancel, do nothing
            try:
                haptic_selection()
            except Exception:
                pass

    def _rename_category(self, base_name, hx, current_display):
        # Prompt for new name; use current display as default text
        try:
            new_name = dialogs.input_alert(
                'Rename category',
                'Enter a new category name:',
                current_display
            )
        except KeyboardInterrupt:
            # User cancelled out of dialog
            return
        except Exception:
            new_name = None

        if not new_name:
            return

        new_name = new_name.strip()
        if not new_name:
            return

        # Save into categories dict
        self.categories[hx] = new_name
        self._after_edit()

    def _clear_category_name(self, base_name, hx, current_display):
        # Remove custom label, back to base name
        if hx in self.categories:
            del self.categories[hx]
        self._after_edit()

    def _after_edit(self):
        # Rebuild items for table
        self.ds = _CategoryRenameDataSource(
            self.palette,
            self.categories,
            on_tap=self._on_row_selected
        )
        self.table.data_source = self.ds
        self.table.delegate = self.ds
        self.table.reload_data()

        # Keep same index highlighted if still valid
        if self.selected_index is not None and self.selected_index < len(self.ds._items):
            self.ds.selected_index = self.selected_index
        else:
            self.selected_index = None
            self.action_btn.enabled = False

        # Try to persist + refresh owner views
        try:
            # If you have a dedicated categories-save method, it will be called here.
            if hasattr(self.owner, '_save_categories'):
                self.owner._save_categories()
        except Exception:
            pass

        try:
            if hasattr(self.owner, 'ds') and hasattr(self.owner.ds, 'refresh'):
                self.owner.ds.refresh()
            if hasattr(self.owner, 'table') and self.owner.table:
                self.owner.table.reload_data()
            if hasattr(self.owner, '_rebuild_filter_summary'):
                self.owner._rebuild_filter_summary()
        except Exception:
            pass

        try:
            haptic_success()
        except Exception:
            pass

    # --- nav back ---
    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()


# =========================================================
# NEW: Date/Time Picker (dark, with month/year popup)
# =========================================================
def _round_minutes(minute, step):
    return int(round(minute / float(step)) * step) % 60

def _start_of_week(d):  # Monday as start
    return d - timedelta(days=d.weekday())

def _days_for_month_grid(year, month):
    first = date(year, month, 1)
    start = _start_of_week(first)  # Monday
    grid = [start + timedelta(days=i) for i in range(42)]
    return grid


class DateTimePicker(ui.View):
    """
    Theme matched picker that returns:
      - ISO string (e.g. '2025-02-19T17:00:00') on Save
      - '' on Clear (if allow_clear)
      - None on Cancel

    Args:
      title        : Nav title
      initial_iso  : Initial ISO datetime string or ''
      allow_clear  : Show Clear button that returns ''
      min_iso      : Optional minimum ISO (dates before disabled)
      mode         : 'datetime' or 'date'
                     - 'datetime'  -> calendar + time selector
                     - 'date'      -> calendar only, no time UI
      minute_step  : Time selection step size (for datetime mode)
      on_result    : Callback(result)

    Use by pushing into a NavigationView, or present() directly.

    NOTE: When "All day" is turned on, the selected time is normalised
    to 00:00. You can treat hour == 0 and minute == 0 as an "all-day"
    item elsewhere in your code (filters, etc.).
    """

    class _ListDataSource(object):
        """
        Simple list data source for the month/year/time popups.

        values      : list of items
        on_select   : callback(value)
        format_func : optional function(value) -> string
        """
        def __init__(self, values, on_select, format_func=None):
            self.values = list(values or [])
            self.on_select = on_select
            self.format_func = format_func
            self.selected_value = None

        def tableview_number_of_sections(self, tv):
            return 1

        def tableview_number_of_rows(self, tv, section):
            return len(self.values)

        def tableview_cell_for_row(self, tv, section, row):
            v = self.values[row]
            text = self.format_func(v) if self.format_func else str(v)
            cell = ui.TableViewCell()
            cell.background_color = (0.10, 0.10, 0.12)
            cell.text_label.text = text
            cell.text_label.alignment = ui.ALIGN_CENTER
            cell.text_label.font = ('<System>', 16)
            cell.text_label.text_color = 'white'
            if self.selected_value is not None and v == self.selected_value:
                cell.background_color = (0.24, 0.20, 0.10)
            return cell

        def tableview_did_select(self, tv, section, row):
            value = self.values[row]
            self.selected_value = value
            if callable(self.on_select):
                self.on_select(value)
            tv.reload_data()

    def __init__(self,
                 title='Select date/time',
                 initial_iso='',
                 allow_clear=True,
                 min_iso=None,
                 mode='datetime',
                 minute_step=5,
                 on_result=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.background_color = 'black'
        self.name = title

        self.allow_clear = allow_clear
        self.on_result = on_result
        self.mode = mode if mode in ('date', 'datetime') else 'datetime'
        self.minute_step = max(1, int(minute_step or 1))

        # Parse base dt
        base_dt = parse_iso_or_now(initial_iso)
        base_dt = base_dt.replace(second=0, microsecond=0)
        base_dt = base_dt.replace(minute=_round_minutes(base_dt.minute, self.minute_step))
        self.selected_dt = base_dt
        self.view_year = base_dt.year
        self.view_month = base_dt.month

        # All day state
        self.all_day = False
        self._saved_time = None  # (hour, minute) when exiting all-day

        # Optional minimum date/time
        self.min_dt = None
        if min_iso:
            try:
                self.min_dt = parse_iso_or_now(min_iso)
            except Exception:
                self.min_dt = None

        # Month/year popup state
        self.monthyear_popup = None
        self.month_table = None
        self.year_table = None
        self.month_ds = None
        self.year_ds = None

        # Time popup state
        self.time_popup = None
        self.hour_table = None
        self.minute_table = None
        self.period_table = None
        self.hour_ds = None
        self.minute_ds = None
        self.period_ds = None
        self._time_period = 'AM'

        # Navigation bar buttons
        self.left_button_items = [ui.ButtonItem(title='Cancel', action=self._cancel)]
        self.right_button_items = []

        # Header: month + year navigation
        y = 0
        self.header = ui.View(frame=(0, y, self.width, 56), flex='W')
        self.header.background_color = (0.12, 0.12, 0.14)
        self.add_subview(self.header)

        # Year step buttons (double arrows)
        self.prev_year_btn = ui.Button(frame=(8, 10, 32, 36))
        self.prev_year_btn.title = '≪'
        self.prev_year_btn.tint_color = 'white'
        self.prev_year_btn.background_color = (0.18, 0.18, 0.2)
        self.prev_year_btn.corner_radius = 9
        self.prev_year_btn.font = ('<System-Bold>', 18)
        self.prev_year_btn.action = self._prev_year
        self.header.add_subview(self.prev_year_btn)

        self.next_year_btn = ui.Button(frame=(self.width - 40, 10, 32, 36), flex='L')
        self.next_year_btn.title = '≫'
        self.next_year_btn.tint_color = 'white'
        self.next_year_btn.background_color = (0.18, 0.18, 0.2)
        self.next_year_btn.corner_radius = 9
        self.next_year_btn.font = ('<System-Bold>', 18)
        self.next_year_btn.action = self._next_year
        self.header.add_subview(self.next_year_btn)

        # Month step buttons (single arrows)
        self.prev_btn = ui.Button(frame=(0, 10, 32, 36))
        self.prev_btn.title = '<'
        self.prev_btn.tint_color = 'white'
        self.prev_btn.background_color = (0.18, 0.18, 0.2)
        self.prev_btn.corner_radius = 9
        self.prev_btn.font = ('<System-Bold>', 18)
        self.prev_btn.action = self._prev_month
        self.header.add_subview(self.prev_btn)

        self.next_btn = ui.Button(frame=(0, 10, 32, 36))
        self.next_btn.title = '>'
        self.next_btn.tint_color = 'white'
        self.next_btn.background_color = (0.18, 0.18, 0.2)
        self.next_btn.corner_radius = 9
        self.next_btn.font = ('<System-Bold>', 18)
        self.next_btn.action = self._next_month
        self.header.add_subview(self.next_btn)

        # Month-year label as a button (clickable)
        self.month_lbl = ui.Button(frame=(0, 10, self.width, 36), flex='W')
        self.month_lbl.alignment = ui.ALIGN_CENTER
        self.month_lbl.tint_color = 'white'
        self.month_lbl.background_color = (0, 0, 0, 0)
        self.month_lbl.font = ('<System-Bold>', 18)
        self.month_lbl.action = self._month_label_tapped
        self.header.add_subview(self.month_lbl)

        self._layout_header_buttons()
        y += self.header.height

        # Weekday row
        self.weekdays_view = ui.View(frame=(0, y, self.width, 24), flex='W')
        self.add_subview(self.weekdays_view)
        y += self.weekdays_view.height

        # Calendar grid
        self.calendar_view = ui.View(frame=(0, y, self.width, 6 * 44), flex='W')
        self.add_subview(self.calendar_view)
        y += self.calendar_view.height + 10

        # Selected summary label
        self.summary_lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        self.summary_lbl.text_color = (0.82, 0.82, 0.88)
        self.summary_lbl.font = ('<System>', 14)
        self.summary_lbl.alignment = ui.ALIGN_CENTER
        self.add_subview(self.summary_lbl)
        y += 28

        # All-day row (label + switch)
        self.all_day_label = ui.Label(frame=(16, y, self.width - 90, 26), flex='W')
        self.all_day_label.text = 'All day'
        self.all_day_label.text_color = (0.9, 0.9, 0.95)
        self.all_day_label.font = ('<System>', 14)
        self.add_subview(self.all_day_label)

        self.all_day_switch = ui.Switch()
        self.all_day_switch.frame = (self.width - 16 - self.all_day_switch.width,
                                     y - 2,
                                     self.all_day_switch.width,
                                     self.all_day_switch.height)
        self.all_day_switch.flex = 'L'
        self.all_day_switch.value = False
        self.all_day_switch.action = self._toggle_all_day
        self.add_subview(self.all_day_switch)
        y += 32

        # Time button (only for datetime mode)
        self.time_btn = ui.Button(frame=(16, y, self.width - 32, 42), flex='W')
        self.time_btn.corner_radius = 9
        self.time_btn.border_width = 1
        self.time_btn.border_color = (0.55, 0.55, 0.65)
        self.time_btn.background_color = (0.17, 0.17, 0.19)
        self.time_btn.tint_color = 'white'
        self.time_btn.font = ('<System>', 15)
        self.time_btn.action = self._pick_time
        self.add_subview(self.time_btn)

        if self.mode == 'date':
            self.time_btn.hidden = True
            self.all_day_label.hidden = True
            self.all_day_switch.hidden = True

        # Footer: bottom Save / Clear buttons
        y_footer = y + (0 if self.mode == 'date' else 52)
        self.footer = ui.View(frame=(0, y_footer, self.width, 60), flex='W')
        self.add_subview(self.footer)

        btn_w = (self.width - 16 * 3) / 2.0
        btn_y = 10

        self.footer_clear = ui.Button(frame=(16, btn_y, btn_w, 40))
        self.footer_clear.corner_radius = 9
        self.footer_clear.border_width = 1
        self.footer_clear.border_color = (0.55, 0.55, 0.65)
        self.footer_clear.background_color = (0.17, 0.17, 0.19)
        self.footer_clear.tint_color = 'white'
        self.footer_clear.font = ('<System-Bold>', 16)
        self.footer_clear.title = 'Clear'
        self.footer_clear.action = self._clear
        self.footer.add_subview(self.footer_clear)
        if not self.allow_clear:
            self.footer_clear.hidden = True

        self.footer_save = ui.Button(frame=(16 + btn_w + 16, btn_y, btn_w, 40))
        self.footer_save.corner_radius = 9
        self.footer_save.border_width = 1
        try:
            gold = hex_to_ui_color('#D4AF37')
        except Exception:
            gold = (0.9, 0.8, 0.4)
        self.footer_save.border_color = gold
        self.footer_save.background_color = gold
        self.footer_save.tint_color = 'black'
        self.footer_save.font = ('<System-Bold>', 16)
        self.footer_save.title = 'Save'
        self.footer_save.action = self._save
        self.footer.add_subview(self.footer_save)

        # Build weekdays and day buttons
        self._build_weekdays()
        self._build_day_buttons()
        self._refresh_month()
        self._refresh_selected_label()
        self._refresh_time_label()

    # ---------- layout ----------
    def _layout_header_buttons(self):
        # Left cluster: year back then month back
        self.prev_year_btn.x = 8
        self.prev_btn.x = self.prev_year_btn.x + self.prev_year_btn.width + 4

        # Right cluster: month forward then year forward
        self.next_year_btn.x = self.header.width - 8 - self.next_year_btn.width
        self.next_btn.x = self.next_year_btn.x - 4 - self.next_btn.width

        # Month label between left and right arrow clusters
        left_edge = self.prev_btn.x + self.prev_btn.width + 8
        right_edge = self.next_btn.x - 8
        self.month_lbl.frame = (left_edge,
                                self.month_lbl.y,
                                max(60, right_edge - left_edge),
                                self.month_lbl.height)

    def layout(self):
        self.header.width = self.width
        self._layout_header_buttons()

        self.weekdays_view.width = self.width
        self.calendar_view.width = self.width

        self.summary_lbl.width = self.width - 32

        # All day row
        self.all_day_label.width = self.width - 90
        self.all_day_switch.x = self.width - 16 - self.all_day_switch.width

        self.time_btn.width = self.width - 32

        self.footer.width = self.width
        btn_w = (self.width - 16 * 3) / 2.0
        self.footer_clear.width = btn_w
        self.footer_save.width = btn_w
        self.footer_save.x = 16 + btn_w + 16

        # Keep time popup full width if visible
        if self.time_popup is not None:
            self.time_popup.width = self.width
        if self.monthyear_popup is not None:
            self.monthyear_popup.width = self.width
            if self.monthyear_popup.subviews:
                inner = self.monthyear_popup.subviews[0]
                inner.width = self.width - 16

    # ---------- calendar helpers ----------
    def _build_weekdays(self):
        for sv in list(self.weekdays_view.subviews):
            self.weekdays_view.remove_subview(sv)

        labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
        w = self.width / 7.0
        for i, text in enumerate(labels):
            lbl = ui.Label(frame=(i * w, 0, w, self.weekdays_view.height), flex='W')
            lbl.text = text
            lbl.font = ('<System>', 13)
            lbl.alignment = ui.ALIGN_CENTER
            lbl.text_color = (0.7, 0.7, 0.75)
            self.weekdays_view.add_subview(lbl)

    def _build_day_buttons(self):
        self.day_buttons = []
        for sv in list(self.calendar_view.subviews):
            self.calendar_view.remove_subview(sv)

        rows = 6
        cols = 7
        cell_w = self.width / cols
        cell_h = 44

        for r in range(rows):
            for c in range(cols):
                idx = r * cols + c
                b = ui.Button()
                b.frame = (c * cell_w, r * cell_h, cell_w, cell_h)
                b.font = ('<System>', 16)
                b.background_color = 'black'
                b.tint_color = 'white'
                b.border_width = 0
                b.action = self._day_tapped
                b.tag = idx
                self.calendar_view.add_subview(b)
                self.day_buttons.append(b)

    def _refresh_month(self):
        dt = datetime(self.view_year, self.view_month, 1)
        center_text = dt.strftime('%B %Y')
        self.month_lbl.title = f'▾ {center_text} ▾'

        first_weekday, num_days = monthrange(self.view_year, self.view_month)
        start_col = first_weekday

        for b in self.day_buttons:
            b.enabled = False
            b.title = ''
            b.background_color = 'black'
            b.border_width = 0
            b.border_color = 'clear'

        day = 1
        for d in range(num_days):
            idx = start_col + d
            if idx >= len(self.day_buttons):
                break
            b = self.day_buttons[idx]
            b.title = str(day)
            b.enabled = True
            b.date_value = datetime(self.view_year, self.view_month, day,
                                    self.selected_dt.hour,
                                    self.selected_dt.minute)

            if self.min_dt and b.date_value.date() < self.min_dt.date():
                b.enabled = False
                b.tint_color = (0.4, 0.4, 0.45)
            else:
                b.tint_color = 'white'
            day += 1

        self._highlight_selected_day()

    def _highlight_selected_day(self):
        for b in self.day_buttons:
            if not getattr(b, 'enabled', False) or not b.title:
                b.border_width = 0
                b.background_color = 'black'
                continue

            d = getattr(b, 'date_value', None)
            if d and d.date() == self.selected_dt.date():
                b.background_color = (0.26, 0.26, 0.30)
                try:
                    b.border_color = hex_to_ui_color('#D4AF37')
                except Exception:
                    b.border_color = (0.9, 0.8, 0.4)
                b.border_width = 1
            else:
                b.background_color = 'black'
                b.border_width = 0

    def _day_tapped(self, sender):
        if not getattr(sender, 'enabled', False):
            return
        d = getattr(sender, 'date_value', None)
        if not d:
            return
        self.selected_dt = self.selected_dt.replace(
            year=d.year, month=d.month, day=d.day
        )
        self.view_year = d.year
        self.view_month = d.month
        self._highlight_selected_day()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------- year & month buttons ----------
    def _prev_year(self, sender):
        y = self.view_year - 1
        m = self.view_month
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.view_year = y
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    def _next_year(self, sender):
        y = self.view_year + 1
        m = self.view_month
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.view_year = y
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    def _prev_month(self, sender):
        y, m = self.view_year, self.view_month
        m -= 1
        if m < 1:
            m = 12
            y -= 1
        self.view_year, self.view_month = y, m
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    def _next_month(self, sender):
        y, m = self.view_year, self.view_month
        m += 1
        if m > 12:
            m = 1
            y += 1
        self.view_year, self.view_month = y, m
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------- month/year popup ----------
    def _month_label_tapped(self, sender):
        if self.monthyear_popup is not None:
            self._hide_monthyear_popup()
        else:
            self._show_monthyear_popup()

    def _show_monthyear_popup(self):
        if self.monthyear_popup is not None:
            return

        popup_h = 220
        header_bottom = self.header.y + self.header.height

        popup = ui.View(frame=(0, header_bottom, self.width, popup_h))
        popup.background_color = (0, 0, 0, 0.7)
        popup.alpha = 0.0
        self.add_subview(popup)

        inner = ui.View(frame=(8, 8, self.width - 16, popup_h - 16))
        inner.background_color = (0.10, 0.10, 0.12)
        inner.corner_radius = 10
        popup.add_subview(inner)

        col_pad = 8
        col_w = (inner.width - col_pad * 3) / 2.0
        top_pad = 8
        label_h = 18
        list_top = top_pad + label_h + 4
        list_h = inner.height - list_top - 40

        month_label = ui.Label(frame=(col_pad, top_pad, col_w, label_h))
        month_label.text = 'Month'
        month_label.font = ('<System>', 12)
        month_label.text_color = 'white'
        month_label.alignment = ui.ALIGN_CENTER
        inner.add_subview(month_label)

        year_label = ui.Label(frame=(col_pad * 2 + col_w, top_pad, col_w, label_h))
        year_label.text = 'Year'
        year_label.font = ('<System>', 12)
        year_label.text_color = 'white'
        year_label.alignment = ui.ALIGN_CENTER
        inner.add_subview(year_label)

        months = list(range(1, 13))
        current_year = self.view_year
        years = list(range(current_year - 10, current_year + 11))

        def on_month_sel(val):
            day = min(self.selected_dt.day, monthrange(self.view_year, val)[1])
            self.view_month = val
            self.selected_dt = self.selected_dt.replace(year=self.view_year, month=val, day=day)
            self._refresh_month()
            self._refresh_selected_label()

        def on_year_sel(val):
            day = min(self.selected_dt.day, monthrange(val, self.view_month)[1])
            self.view_year = val
            self.selected_dt = self.selected_dt.replace(year=val, month=self.view_month, day=day)
            self._refresh_month()
            self._refresh_selected_label()

        MONTH_NAMES = (
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        )

        self.month_ds = DateTimePicker._ListDataSource(
            months,
            on_month_sel,
            format_func=lambda m, names=MONTH_NAMES: names[m - 1]
        )
        self.year_ds = DateTimePicker._ListDataSource(
            years,
            on_year_sel,
            format_func=None
        )

        self.month_ds.selected_value = self.view_month
        self.year_ds.selected_value = self.view_year

        self.month_table = ui.TableView(frame=(col_pad, list_top, col_w, list_h))
        self.month_table.row_height = 30
        self.month_table.data_source = self.month_ds
        self.month_table.delegate = self.month_ds
        self.month_table.background_color = (0.10, 0.10, 0.12)
        self.month_table.separator_color = (0.20, 0.20, 0.22)
        inner.add_subview(self.month_table)

        self.year_table = ui.TableView(frame=(col_pad * 2 + col_w, list_top, col_w, list_h))
        self.year_table.row_height = 30
        self.year_table.data_source = self.year_ds
        self.year_table.delegate = self.year_ds
        self.year_table.background_color = (0.10, 0.10, 0.12)
        self.year_table.separator_color = (0.20, 0.20, 0.22)
        inner.add_subview(self.year_table)

        def _scroll_to_current():
            try:
                mi = months.index(self.view_month)
            except ValueError:
                mi = 0
            try:
                yi = years.index(self.view_year)
            except ValueError:
                yi = 0
            self.month_table.content_offset = (
                0,
                max(0, mi * self.month_table.row_height - self.month_table.height / 2),
            )
            self.year_table.content_offset = (
                0,
                max(0, yi * self.year_table.row_height - self.year_table.height / 2),
            )
        ui.delay(_scroll_to_current, 0.02)

        confirm_btn = ui.Button()
        confirm_btn.title = 'Done'
        confirm_btn.font = ('<System-Bold>', 14)
        confirm_btn.tint_color = 'black'
        try:
            confirm_btn.background_color = hex_to_ui_color('#D4AF37')
        except Exception:
            confirm_btn.background_color = (0.9, 0.8, 0.4)
        confirm_btn.corner_radius = 8
        confirm_btn.frame = (col_pad,
                             inner.height - 32,
                             inner.width - col_pad * 2,
                             26)

        def _confirm(sender):
            self._hide_monthyear_popup()

        confirm_btn.action = _confirm
        inner.add_subview(confirm_btn)

        self.monthyear_popup = popup

        def anim():
            popup.alpha = 1.0
        ui.animate(anim, duration=0.22)
        try:
            haptic_selection()
        except Exception:
            pass

    def _hide_monthyear_popup(self):
        if self.monthyear_popup is None:
            return
        popup = self.monthyear_popup

        def anim():
            popup.alpha = 0.0

        def cleanup():
            if popup.superview:
                popup.superview.remove_subview(popup)
            self.monthyear_popup = None
            self.month_table = None
            self.year_table = None
            self.month_ds = None
            self.year_ds = None

        ui.animate(anim, duration=0.18, completion=cleanup)
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------- all day toggle ----------
    def _toggle_all_day(self, sender):
        val = bool(sender.value)
        if val and not self.all_day:
            # Enter all-day mode: remember previous time, normalise to 00:00
            self._saved_time = (self.selected_dt.hour, self.selected_dt.minute)
            self.selected_dt = self.selected_dt.replace(hour=0, minute=0, second=0)
            self.all_day = True
            self.time_btn.enabled = False
            self.time_btn.alpha = 0.5
        elif not val and self.all_day:
            # Exit all-day mode: restore last time if available
            self.all_day = False
            if self._saved_time is not None:
                h, m = self._saved_time
                self.selected_dt = self.selected_dt.replace(hour=h, minute=m, second=0)
            self.time_btn.enabled = True
            self.time_btn.alpha = 1.0

        self._refresh_time_label()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------- time label + popup ----------
    def _refresh_time_label(self):
        if self.mode == 'date':
            self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y')
            return

        if self.all_day:
            self.time_btn.title = 'All day'
            self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y (All day)')
            return

        t_str = self.selected_dt.strftime('%I:%M %p').lstrip('0')
        self.time_btn.title = f'Time: {t_str}'
        self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y ') + t_str

    def _pick_time(self, sender):
        if self.mode == 'date' or self.all_day:
            return
        if self.time_popup is not None:
            self._hide_time_popup()
        else:
            self._show_time_popup()

    def _show_time_popup(self):
        if self.time_popup is not None:
            return

        popup_h = 220
        btn_frame = self.time_btn.frame
        popup = ui.View(frame=(0,
                               btn_frame.y + btn_frame.height + 4,
                               self.width,
                               popup_h))
        popup.background_color = (0, 0, 0, 0.7)
        popup.alpha = 0.0
        self.add_subview(popup)

        inner = ui.View(frame=(8, 8, self.width - 16, popup_h - 16))
        inner.background_color = (0.10, 0.10, 0.12)
        inner.corner_radius = 10
        popup.add_subview(inner)

        col_pad = 8
        col_w = (inner.width - col_pad * 4) / 3.0
        top_pad = 8
        label_h = 18
        list_top = top_pad + label_h + 4
        list_h = inner.height - list_top - 40

        hour_label = ui.Label(frame=(col_pad, top_pad, col_w, label_h))
        hour_label.text = 'Hour'
        hour_label.font = ('<System>', 12)
        hour_label.text_color = 'white'
        hour_label.alignment = ui.ALIGN_CENTER
        inner.add_subview(hour_label)

        minute_label = ui.Label(frame=(col_pad * 2 + col_w, top_pad, col_w, label_h))
        minute_label.text = 'Minute'
        minute_label.font = ('<System>', 12)
        minute_label.text_color = 'white'
        minute_label.alignment = ui.ALIGN_CENTER
        inner.add_subview(minute_label)

        period_label = ui.Label(frame=(col_pad * 3 + col_w * 2, top_pad, col_w, label_h))
        period_label.text = 'AM/PM'
        period_label.font = ('<System>', 12)
        period_label.text_color = 'white'
        period_label.alignment = ui.ALIGN_CENTER
        inner.add_subview(period_label)

        hours = list(range(1, 13))
        minutes = list(range(0, 60, self.minute_step))
        periods = ['AM', 'PM']

        h24 = self.selected_dt.hour
        if h24 == 0:
            h12 = 12
            period = 'AM'
        elif 1 <= h24 <= 11:
            h12 = h24
            period = 'AM'
        elif h24 == 12:
            h12 = 12
            period = 'PM'
        else:
            h12 = h24 - 12
            period = 'PM'
        self._time_period = period

        cur_min = self.selected_dt.minute
        step = self.minute_step
        min_rounded = (cur_min // step) * step

        def _apply_time(h12=None, minute=None, period_str=None):
            if h12 is None:
                h12 = self.hour_ds.selected_value or 12
            if minute is None:
                minute = self.minute_ds.selected_value if self.minute_ds.selected_value is not None else min_rounded
            if period_str is None:
                period_str = self._time_period

            if period_str == 'AM':
                h24_local = 0 if h12 == 12 else h12
            else:
                h24_local = 12 if h12 == 12 else h12 + 12

            self._time_period = period_str
            self.selected_dt = self.selected_dt.replace(hour=h24_local, minute=minute, second=0)
            self._refresh_time_label()
            self._refresh_selected_label()

        def on_hour_selected(val):
            _apply_time(h12=val, minute=None, period_str=None)

        def on_min_selected(val):
            _apply_time(h12=None, minute=val, period_str=None)

        def on_period_selected(val):
            _apply_time(h12=None, minute=None, period_str=val)

        self.hour_ds = DateTimePicker._ListDataSource(hours, on_hour_selected, format_func=None)
        self.minute_ds = DateTimePicker._ListDataSource(minutes, on_min_selected,
                                                        format_func=lambda m: f'{m:02d}')
        self.period_ds = DateTimePicker._ListDataSource(periods, on_period_selected, format_func=None)

        self.hour_ds.selected_value = h12
        self.minute_ds.selected_value = min_rounded
        self.period_ds.selected_value = period

        self.hour_table = ui.TableView(frame=(col_pad, list_top, col_w, list_h))
        self.hour_table.row_height = 30
        self.hour_table.data_source = self.hour_ds
        self.hour_table.delegate = self.hour_ds
        self.hour_table.background_color = (0.10, 0.10, 0.12)
        self.hour_table.separator_color = (0.20, 0.20, 0.22)
        inner.add_subview(self.hour_table)

        self.minute_table = ui.TableView(frame=(col_pad * 2 + col_w, list_top, col_w, list_h))
        self.minute_table.row_height = 30
        self.minute_table.data_source = self.minute_ds
        self.minute_table.delegate = self.minute_ds
        self.minute_table.background_color = (0.10, 0.10, 0.12)
        self.minute_table.separator_color = (0.20, 0.20, 0.22)
        inner.add_subview(self.minute_table)

        self.period_table = ui.TableView(frame=(col_pad * 3 + col_w * 2, list_top, col_w, list_h))
        self.period_table.row_height = 30
        self.period_table.data_source = self.period_ds
        self.period_table.delegate = self.period_ds
        self.period_table.background_color = (0.10, 0.10, 0.12)
        self.period_table.separator_color = (0.20, 0.20, 0.22)
        inner.add_subview(self.period_table)

        def _scroll_to_current():
            try:
                hi = hours.index(h12)
            except ValueError:
                hi = 0
            try:
                mi = minutes.index(min_rounded)
            except ValueError:
                mi = 0
            try:
                pi = periods.index(period)
            except ValueError:
                pi = 0

            self.hour_table.content_offset = (
                0,
                max(0, hi * self.hour_table.row_height - self.hour_table.height / 2),
            )
            self.minute_table.content_offset = (
                0,
                max(0, mi * self.minute_table.row_height - self.minute_table.height / 2),
            )
            self.period_table.content_offset = (
                0,
                max(0, pi * self.period_table.row_height - self.period_table.height / 2),
            )
        ui.delay(_scroll_to_current, 0.02)

        confirm_btn = ui.Button()
        confirm_btn.title = 'Done'
        confirm_btn.font = ('<System-Bold>', 14)
        confirm_btn.tint_color = 'black'
        try:
            confirm_btn.background_color = hex_to_ui_color('#D4AF37')
        except Exception:
            confirm_btn.background_color = (0.9, 0.8, 0.4)
        confirm_btn.corner_radius = 8
        confirm_btn.frame = (col_pad,
                             inner.height - 32,
                             inner.width - col_pad * 2,
                             26)

        def _confirm(sender):
            self._hide_time_popup()

        confirm_btn.action = _confirm
        inner.add_subview(confirm_btn)

        self.time_popup = popup

        def anim():
            popup.alpha = 1.0
        ui.animate(anim, duration=0.22)
        try:
            haptic_selection()
        except Exception:
            pass

    def _hide_time_popup(self):
        if self.time_popup is None:
            return
        popup = self.time_popup

        def anim():
            popup.alpha = 0.0

        def cleanup():
            if popup.superview:
                popup.superview.remove_subview(popup)
            self.time_popup = None
            self.hour_table = None
            self.minute_table = None
            self.period_table = None
            self.hour_ds = None
            self.minute_ds = None
            self.period_ds = None

        ui.animate(anim, duration=0.18, completion=cleanup)
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------- summary + save/clear/cancel ----------
    def _refresh_selected_label(self):
        if self.mode == 'date':
            self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y')
        else:
            self._refresh_time_label()

    def _final_result(self, value):
        if callable(self.on_result):
            try:
                self.on_result(value)
            except Exception:
                pass

    def _save(self, sender):
        iso_value = to_iso_seconds(self.selected_dt)
        self._final_result(iso_value)
        try:
            haptic_success()
        except Exception:
            pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _clear(self, sender):
        if not self.allow_clear:
            return
        self._final_result('')
        try:
            haptic_selection()
        except Exception:
            pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _cancel(self, sender):
        self._final_result(None)
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()
            
                                    
# ==== KNOWLEDGE CENTRE =======================================================

# =========================
# Knowledge data file
# =========================
KNOWLEDGE_DATA_FILE = Path(__file__).with_name('knowledge_store.json')


# =========================
# Knowledge List Screen
# =========================
class KnowledgeCenterView(ui.View):
    """
    Light themed Knowledge list that matches the To Do app.

    - Title at the top left
    - "Add" button at the top right
    - List of items in a card style area
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = 'Knowledge'
        self.background_color = 'white'
        self.flex = 'WH'

        self._items = []
        self._load_items()

        # Section title
        self.section_lbl = ui.Label()
        self.section_lbl.text = 'Knowledge'
        self.section_lbl.font = ('<System-Bold>', 25)
        self.section_lbl.text_color = (0.1, 0.1, 0.2)
        self.section_lbl.flex = 'W'
        self.add_subview(self.section_lbl)

        # Add button
        self.add_btn = ui.Button()
        self.add_btn.title = 'Add'
        self.add_btn.action = self._add_item_tapped
        self.add_btn.corner_radius = 8
        self.add_btn.border_width = 1
        self.add_btn.border_color = (0.8, 0.8, 0.85)
        self.add_btn.background_color = (1, 1, 1)
        self.add_btn.tint_color = (0.1, 0.1, 0.2)
        self.add_btn.flex = 'L'
        self.add_subview(self.add_btn)

        # Card style container for the list
        self.list_card = ui.View()
        self.list_card.background_color = (0.98, 0.98, 0.99)
        self.list_card.corner_radius = 12
        self.list_card.border_width = 1
        self.list_card.border_color = (0.9, 0.9, 0.93)
        self.list_card.flex = 'WH'
        self.add_subview(self.list_card)

        # Table of items
        self.table = ui.TableView()
        self.table.row_height = 56
        self.table.data_source = self
        self.table.delegate = self
        self.table.flex = 'WH'
        self.table.background_color = (0.98, 0.98, 0.99)
        self.list_card.add_subview(self.table)

    def layout(self):
        margin = 12
        btn_w, btn_h = 80, 32
        top = 8

        # Title and Add button
        self.section_lbl.frame = (margin, top, self.width - 3 * margin - btn_w, 28)
        self.add_btn.frame = (self.width - margin - btn_w, top, btn_w, btn_h)

        # Card and table fill the rest
        card_top = self.section_lbl.y + self.section_lbl.height + 8
        self.list_card.frame = (margin, card_top, self.width - 2 * margin, self.height - card_top - margin)
        self.table.frame = self.list_card.bounds

    # ----------------- Persistence -----------------
    def _load_items(self):
        try:
            if KNOWLEDGE_DATA_FILE.exists():
                with KNOWLEDGE_DATA_FILE.open('r', encoding='utf-8') as f:
                    self._items = json.load(f)
            else:
                self._items = []
        except Exception:
            # Corrupt file, start fresh
            self._items = []

    def _save_items(self):
        try:
            with KNOWLEDGE_DATA_FILE.open('w', encoding='utf-8') as f:
                json.dump(self._items, f, indent=2, ensure_ascii=False)
        except Exception:
            # Non fatal
            pass

    @property
    def items(self):
        return self._items

    def add_item(self, item):
        self._items.append(item)
        self._save_items()
        self.table.reload()

    def update_item(self, index, item):
        if 0 <= index < len(self._items):
            self._items[index] = item
            self._save_items()
            self.table.reload()

    def delete_item(self, index):
        if 0 <= index < len(self._items):
            self._items.pop(index)
            self._save_items()
            self.table.reload()

    # ----------------- Actions -----------------
    def _add_item_tapped(self, sender):
        editor = KnowledgeEditorView(parent_view=self, index=None, item=None)
        if self.navigation_view:
            _safe_push(self.navigation_view, editor)
        else:
            editor.present('sheet')

    # ----------------- TableView -----------------
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._items)

    def tableview_cell_for_row(self, tv, section, row):
        cell = ui.TableViewCell('subtitle')
        item = self._items[row]

        # Title
        cell.text_label.text = item.get('title') or 'Untitled item'
        cell.text_label.text_color = (0.1, 0.1, 0.2)

        # Type and summary
        itype = item.get('kind') or 'Text'
        summary = item.get('summary') or ''

        if not summary:
            raw = item.get('content') or ''
            raw = raw.strip()
            if raw:
                lines = raw.splitlines()
                if lines:
                    summary = lines[0][:80]
                else:
                    summary = ''
            else:
                summary = ''

        # If still no summary, just show the type
        if summary:
            cell.detail_text_label.text = f'{itype} \u2022 {summary}'
        else:
            cell.detail_text_label.text = itype

        cell.detail_text_label.text_color = (0.35, 0.35, 0.4)
        cell.background_color = (0.98, 0.98, 0.99)
        return cell

    def tableview_did_select(self, tv, section, row):
        tv.selected_row = (-1, -1)
        editor = KnowledgeEditorView(parent_view=self, index=row, item=self._items[row])
        if self.navigation_view:
            _safe_push(self.navigation_view, editor)
        else:
            editor.present('sheet')

    def tableview_can_delete(self, tv, section, row):
        return True

    def tableview_commit(self, tv, editing_style, section, row):
        if editing_style == 'delete':
            self.delete_item(row)


# =========================
# Knowledge Editor Screen
# =========================
class KnowledgeEditorView(ui.View):
    """
    Editor for a single knowledge item.

    - Title field
    - Type segmented control
    - Multiline content box
    - Save, Delete, Duplicate buttons at bottom
    """

    KIND_OPTIONS = ['Text', 'Link', 'Phone', 'Image', 'Video', 'Other']

    def __init__(self, parent_view, index=None, item=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = 'Knowledge item'
        self.background_color = 'white'
        self.flex = 'WH'

        self.parent_view = parent_view
        self.index = index

        item = item or {}
        self._item = {
            'title': item.get('title', ''),
            'kind': item.get('kind', 'Text'),
            'content': item.get('content', ''),
            'summary': item.get('summary', ''),
            'meta': item.get('meta', {}),
        }

        # Title
        self.title_lbl = ui.Label(text='Title')
        self.title_lbl.font = ('<System>', 14)
        self.title_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.title_lbl)

        self.title_tf = ui.TextField()
        self.title_tf.text = self._item['title']
        self.title_tf.clear_button_mode = 'while_editing'
        
        # Set a rounded border style if the constant exists, otherwise skip
        bs = getattr(ui, 'TEXT_FIELD_BORDER_STYLE_ROUNDED_RECT', None)
        if bs is not None:
            try:
                self.title_tf.border_style = bs
            except Exception:
                pass
        
        self.add_subview(self.title_tf)

        # Type
        self.kind_lbl = ui.Label(text='Type')
        self.kind_lbl.font = ('<System>', 14)
        self.kind_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.kind_lbl)

        self.kind_seg = ui.SegmentedControl(segments=self.KIND_OPTIONS)
        if self._item['kind'] in self.KIND_OPTIONS:
            self.kind_seg.selected_index = self.KIND_OPTIONS.index(self._item['kind'])
        else:
            self.kind_seg.selected_index = 0
        self.add_subview(self.kind_seg)

        # Content
        self.content_lbl = ui.Label(text='Content / notes')
        self.content_lbl.font = ('<System>', 14)
        self.content_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.content_lbl)

        self.content_tv = ui.TextView()
        self.content_tv.text = self._item['content']
        self.add_subview(self.content_tv)

        # Buttons
        self.save_btn = ui.Button(title='Save')
        self.save_btn.action = self._save_tapped
        self.save_btn.corner_radius = 8
        self.save_btn.border_width = 1
        self.save_btn.border_color = (0.3, 0.5, 0.3)
        self.save_btn.background_color = (0.9, 1.0, 0.9)
        self.save_btn.tint_color = (0, 0.3, 0)
        self.add_subview(self.save_btn)

        self.delete_btn = ui.Button(title='Delete')
        self.delete_btn.action = self._delete_tapped
        self.delete_btn.corner_radius = 8
        self.delete_btn.border_width = 1
        self.delete_btn.border_color = (0.7, 0.2, 0.2)
        self.delete_btn.background_color = (1.0, 0.9, 0.9)
        self.delete_btn.tint_color = (0.5, 0, 0)
        self.add_subview(self.delete_btn)

        self.dup_btn = ui.Button(title='Duplicate')
        self.dup_btn.action = self._duplicate_tapped
        self.dup_btn.corner_radius = 8
        self.dup_btn.border_width = 1
        self.dup_btn.border_color = (0.8, 0.8, 0.85)
        self.dup_btn.background_color = (1, 1, 1)
        self.dup_btn.tint_color = (0.1, 0.1, 0.2)
        self.add_subview(self.dup_btn)

    def layout(self):
        margin = 16
        width = self.width - 2 * margin
        y = 8

        # Title
        self.title_lbl.frame = (margin, y, width, 20)
        y += 22
        self.title_tf.frame = (margin, y, width, 32)
        y += 40

        # Type
        self.kind_lbl.frame = (margin, y, width, 20)
        y += 22
        self.kind_seg.frame = (margin, y, width, 32)
        y += 40

        # Content label
        self.content_lbl.frame = (margin, y, width, 20)
        y += 22

        # Content box height adapts to screen, leaving room for buttons
        bottom_buttons_height = 40
        bottom_margin = 16
        content_height = self.height - y - bottom_buttons_height - bottom_margin * 2
        if content_height < 80:
            content_height = 80
        self.content_tv.frame = (margin, y, width, content_height)

        # Bottom buttons, equal sized, no overlap
        btn_y = self.height - bottom_buttons_height - bottom_margin
        gap = 8
        btn_w = (width - 2 * gap) / 3.0
        self.save_btn.frame = (margin, btn_y, btn_w, bottom_buttons_height)
        self.delete_btn.frame = (margin + btn_w + gap, btn_y, btn_w, bottom_buttons_height)
        self.dup_btn.frame = (margin + 2 * (btn_w + gap), btn_y, btn_w, bottom_buttons_height)

    # ----------------- Button actions -----------------
    def _save_tapped(self, sender):
        title = (self.title_tf.text or '').strip()
        kind = self.KIND_OPTIONS[self.kind_seg.selected_index]
        content = self.content_tv.text or ''
        summary = _make_safe_summary(content, 120)
        item = {
            'title': title,
            'kind': kind,
            'content': content,
            'summary': summary,
            'meta': self._item.get('meta', {}),
        }

        if self.index is None:
            self.parent_view.add_item(item)
        else:
            self.parent_view.update_item(self.index, item)

        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _delete_tapped(self, sender):
        if self.index is not None:
            self.parent_view.delete_item(self.index)
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _duplicate_tapped(self, sender):
        title = (self.title_tf.text or '').strip()
        kind = self.KIND_OPTIONS[self.kind_seg.selected_index]
        content = self.content_tv.text or ''
        summary = _make_safe_summary(content, 120)
        item = {
            'title': f"{title or 'Item'} (copy)",
            'kind': kind,
            'content': content,
            'summary': summary,
            'meta': self._item.get('meta', {}),
        }

        self.parent_view.add_item(item)

        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()
                        
                              
                                          
# -------------------------
# Categories (rename/clear per color)
# -------------------------
class CategoriesView(ui.View):
    def __init__(self, palette, cats, on_change=None):
        super().__init__(frame=(0, 0, 420, 520))
        self.name = 'Categories'
        self.background_color = 'black'
        self.palette = list(palette)
        self.cats = cats
        self.on_change = on_change
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 56
        self.table.data_source = self
        self.table.delegate = self
        self.add_subview(self.table)
        self.left_button_items  = [ui.ButtonItem(title='Done', action=self._done)]
        self.right_button_items = [ui.ButtonItem(title='Reset All', action=self._reset_all)]

    def tableview_number_of_sections(self, tv): return 1
    def tableview_number_of_rows(self, tv, section): return len(self.palette)

    def tableview_cell_for_row(self, tv, section, row):
        cell = ui.TableViewCell('subtitle')
        base_name, hexc = self.palette[row]
        cell.text_label.text = base_name
        current = self.cats.get(hexc, '')
        cell.detail_text_label.text = (current if current else 'No category')
        try:
            cell.background_color = hex_to_ui_color(hexc)
            fg = best_text_color_for_bg(hexc)
            cell.text_label.text_color = fg
            cell.detail_text_label.text_color = fg
        except Exception:
            cell.background_color = 'white'
            cell.text_label.text_color = 'black'
            cell.detail_text_label.text_color = 'black'
        cell.accessory_type = 'disclosure_indicator'
        return cell

    def tableview_did_select(self, tv, section, row):
        ui.delay(lambda r=row: self._present_category_actions(r), 0.01)

    @ui.in_background
    def _present_category_actions(self, row):
        try:
            base_name, hexc = self.palette[row]
        except Exception:
            return
        choice = dialogs.list_dialog(f'{base_name} Category', ['Rename', 'Clear', 'Cancel'])
        if not choice or choice == 'Cancel':
            ui.delay(self.table.reload_data, 0.0)
            return
        if choice == 'Clear':
            self.cats[hexc] = ''
            save_categories(self.cats)
            if callable(self.on_change): self.on_change(self.cats)
            ui.delay(self.table.reload_data, 0.0)
            return
        if choice == 'Rename':
            changed = reuse_rename_category(hexc, self.cats, _PALETTE, title_prefix='Rename')
            def _after():
                if changed and callable(self.on_change):
                    self.on_change(self.cats)
                self.table.reload_data()
            ui.delay(_after, 0.0)

    def _done(self, sender):
        if self.navigation_view: self.navigation_view.pop_view()
        else: self.close()

    def _reset_all(self, sender):
        if not dialogs.yes_no_alert('Reset All', 'Clear ALL category names?', 'Reset', 'Cancel'):
            return
        for _n, hx in self.palette:
            self.cats[hx] = ''
        save_categories(self.cats)
        if callable(self.on_change): self.on_change(self.cats)
        self.table.reload_data()
        dialogs.hud_alert('All category names cleared', 'success', 0.8)

# =========================================================
# FILTER VIEW + DETAIL SCREENS (FULL UPDATED SET)
# =========================================================

class FilterView(ui.View):
    """
    Menu screen listing filter options.
    Pushes detail screens for each filter type (except colours, which go
    straight to MultiColorPicker).
    """

    def __init__(self, owner, on_apply=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Filters'
        self.background_color = 'black'
        self.owner = owner
        self.on_apply = on_apply  # optional

        # Ensure adv filter exists with new fields
        if not hasattr(owner, 'adv_filter') or not isinstance(owner.adv_filter, dict):
            owner.adv_filter = {
                'enabled': False,
                # Name filter
                'name_mode': 'contains',   # contains | equals | starts
                'name_values': [],         # list of strings
                'name_logic': 'or',        # or | and
                'name_value': '',          # legacy string (comma-joined)
                # Created date filter
                'created_mode': 'any',     # any | on | range
                'created_on': '',
                'created_from': '',
                'created_to': '',
                # Due date filter
                'due_mode': 'any',         # any | on | range
                'due_on': '',
                'due_from': '',
                'due_to': '',
                'due_include_empty': False,
            }

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [ui.ButtonItem(title='Clear All', action=self._clear_all)]

        # Table menu
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 58
        self.table.data_source = self
        self.table.delegate = self
        self.add_subview(self.table)

        # Bottom "Save filters" button (raised 20 higher)
        self.save_btn = ui.Button(title='Save filters')
        self.save_btn.corner_radius = 10
        self.save_btn.border_width = 1
        self.save_btn.border_color = hex_to_ui_color('#D4AF37')
        self.save_btn.background_color = hex_to_ui_color('#D4AF37')
        self.save_btn.tint_color = 'black'
        self.save_btn.font = ('<System-Bold>', 16)
        self.save_btn.action = self._save_filters
        self.add_subview(self.save_btn)

    def layout(self):
        margin = 16
        btn_h = 48

        # Raised 20 points from bottom
        self.save_btn.width = self.width - 2 * margin
        self.save_btn.x = margin
        self.save_btn.y = self.height - btn_h - margin - 20

        table_bottom = self.save_btn.y - margin
        self.table.frame = (0, 0, self.width, table_bottom)

    # ----- Menu rows -----
    def _rows(self):
        return [
            ('Item Name',            'name'),
            ('Item Created Date',    'created'),
            ('Item Due Date',        'due'),
            ('Colour / Category',    'colour'),
            ('Completed / Not',      'done'),
        ]

    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._rows())

    def _subtitle_for_key(self, key):
        af = self.owner.adv_filter or {}

        if key == 'name':
            vals = [v.strip() for v in (af.get('name_values') or []) if v.strip()]
            if not vals:
                return 'Any'
            mode = af.get('name_mode', 'contains')
            mode_label = {
                'contains': 'Contains',
                'equals':   'Equals',
                'starts':   'Starts with',
            }.get(mode, 'Contains')
            logic = af.get('name_logic', 'or')
            joiner = ' OR ' if logic == 'or' else ' AND '
            preview = joiner.join(vals)
            if len(preview) > 30:
                preview = preview[:27] + '...'
            return f'{mode_label}: {preview}'

        if key == 'created':
            mode = af.get('created_mode', 'any')
            if mode == 'on':
                on_iso = (af.get('created_on') or '').strip()
                return f'On {_fmt_dt_for_label(on_iso)}' if on_iso else 'On (not set)'
            if mode == 'range':
                f = (af.get('created_from') or '').strip()
                t = (af.get('created_to') or '').strip()
                if f and t:
                    return f'{_fmt_dt_for_label(f)} to {_fmt_dt_for_label(t)}'
                if f:
                    return f'From {_fmt_dt_for_label(f)}'
                if t:
                    return f'To {_fmt_dt_for_label(t)}'
            return 'Any'

        if key == 'due':
            mode = af.get('due_mode', 'any')
            inc_empty = bool(af.get('due_include_empty', False))
            extra = ' (incl empty)' if inc_empty else ''
            if mode == 'on':
                on_iso = (af.get('due_on') or '').strip()
                return f'On {_fmt_dt_for_label(on_iso)}{extra}' if on_iso else f'On (not set){extra}'
            if mode == 'range':
                f = (af.get('due_from') or '').strip()
                t = (af.get('due_to') or '').strip()
                if f and t:
                    return f'{_fmt_dt_for_label(f)} to {_fmt_dt_for_label(t)}{extra}'
                if f:
                    return f'From {_fmt_dt_for_label(f)}{extra}'
                if t:
                    return f'To {_fmt_dt_for_label(t)}{extra}'
            return 'Any' + extra if inc_empty else 'Any'

        if key == 'colour':
            sel = set(getattr(self.owner, 'filter_category_hexes', set()) or [])
            count = len(sel)
            if count == 0:
                return 'All colours'

            # Ordered pairs based on palette
            pairs = []
            for base_name, hx in _PALETTE:
                if hx in sel:
                    name = self.owner.categories.get(hx, '') or base_name
                    pairs.append((name, hx))

            if not pairs:
                return 'All colours'

            # For many colours, just give a count
            if count > 4:
                return f'{count} colours selected'

            # For 1–4 colours, list their names
            names = [p[0] for p in pairs]
            return ', '.join(names)

        if key == 'done':
            v = getattr(self.owner, 'filter_done', 'all')
            return {'all': 'All', 'active': 'Active only', 'done': 'Completed only'}.get(v, 'All')

        return ''

    def tableview_cell_for_row(self, tv, section, row):
        title, key = self._rows()[row]

        # Basic cell with subtitle style
        cell = ui.TableViewCell('subtitle')
        cell.background_color = 'black'
        cell.text_label.text = title
        cell.text_label.text_color = 'white'
        cell.text_label.font = ('<System>', 17)

        # Default subtitle text for all keys
        subtitle_text = self._subtitle_for_key(key)
        cell.detail_text_label.text = subtitle_text
        cell.detail_text_label.text_color = (0.65, 0.65, 0.7)
        cell.detail_text_label.font = ('<System>', 12)
        cell.detail_text_label.hidden = False

        # Clean up any previous custom colour row from reused cells
        for sv in list(cell.content_view.subviews):
            if getattr(sv, 'name', '') == 'colour_row':
                cell.content_view.remove_subview(sv)

        # Special rendering for the colour row
        if key == 'colour':
            sel = set(getattr(self.owner, 'filter_category_hexes', set()) or [])
            count = len(sel)

            # Only draw custom chips when 1–4 colours selected.
            # For 0 colours, "All colours" subtitle shows.
            # For 5+ colours, "N colours selected" subtitle shows.
            if 1 <= count <= 4:
                # Build ordered list of (category_name, hex) based on palette order
                pairs = []
                for base_name, hx in _PALETTE:
                    if hx in sel:
                        name = self.owner.categories.get(hx, '') or base_name
                        pairs.append((name, hx))

                if pairs:
                    # Keep subtitle "alive" so the title layout does not move
                    # We leave the label visible but with transparent text.
                    cell.detail_text_label.text = ' '      # non empty string for layout
                    cell.detail_text_label.hidden = False
                    cell.detail_text_label.text_color = (0, 0, 0, 0)

                    # Create a container view that will be aligned to the subtitle frame
                    row_view = ui.View()
                    row_view.name = 'colour_row'
                    row_view.background_color = 'clear'
                    # Initial dummy frame, will be aligned after layout
                    row_view.frame = (0, 0, 0, 0)
                    row_view.flex = 'W'

                    # Provisional width for laying out chips
                    max_w = tv.bounds.width - 32
                    if max_w <= 0:
                        max_w = 200

                    x = 0
                    chip_size = 12
                    pad = 8
                    row_h = 18

                    # Build up to 4 [Name][Square] pairs
                    for (name, hx) in pairs[:4]:
                        lbl = ui.Label()
                        lbl.text = name
                        style_colour_label(lbl, hx)
                        lbl.font = ('<System>', 11)
                        lbl.size_to_fit()
                        lw = lbl.width

                        if x + lw + chip_size + pad > max_w and x > 0:
                            break

                        lbl.frame = (x, 0, lw, row_h)
                        row_view.add_subview(lbl)
                        x += lw + 4

                        chip = ui.View()
                        chip.frame = (x, (row_h - chip_size) / 2.0, chip_size, chip_size)
                        chip.corner_radius = 3
                        chip.border_width = 1
                        chip.border_color = (0.8, 0.8, 0.85)
                        try:
                            chip.background_color = hex_to_ui_color(hx)
                        except Exception:
                            chip.background_color = 'white'
                        row_view.add_subview(chip)
                        x += chip_size + pad

                    cell.content_view.add_subview(row_view)

                    # Align the row exactly where the subtitle label is,
                    # once the cell has done its layout.
                    def _align_row():
                        if not cell.superview:
                            return

                        dx, dy, dw, dh = cell.detail_text_label.frame

                        # Minimum sensible width so content is not crushed
                        min_w = cell.content_view.width - dx - 16
                        if min_w < 40:
                            min_w = 40

                        if dw <= 0 or dw < min_w * 0.5:
                            dw = min_w

                        if dh <= 0:
                            dh = row_h

                        row_view.frame = (dx, dy, dw, dh)

                    ui.delay(_align_row, 0)

        cell.accessory_type = 'disclosure_indicator'
        return cell

    def tableview_did_select(self, tv, section, row):
        _title, key = self._rows()[row]
        tv.reload_data()
        haptic_selection()

        if key == 'name':
            view = NameFilterDetailView(self.owner, on_done=self._detail_done)
            _safe_push(self.navigation_view, view)
            return

        if key == 'created':
            view = DateFilterDetailView(
                self.owner,
                kind='created',
                title='Filter Created Date',
                on_done=self._detail_done,
                allow_include_empty=False
            )
            _safe_push(self.navigation_view, view)
            return

        if key == 'due':
            view = DateFilterDetailView(
                self.owner,
                kind='due',
                title='Filter Due Date',
                on_done=self._detail_done,
                allow_include_empty=True
            )
            _safe_push(self.navigation_view, view)
            return

        if key == 'colour':
            # Open picker immediately (no extra screen)
            def applied(selected_hexes):
                self.owner.filter_category_hexes = set(selected_hexes)
                try:
                    self.owner.ds.refresh()
                    self.owner._rebuild_filter_summary()
                    self.owner.table.reload_data()
                except Exception:
                    pass
           

                haptic_success()
                self._detail_done()  # refresh subtitles

            picker = MultiColorPicker(
                _PALETTE,
                self.owner.categories,
                selected_hexes=getattr(self.owner, 'filter_category_hexes', set()),
                on_apply=applied,
                title='Filter by Colour'
            )
            _safe_push(self.navigation_view, picker)
            return

        if key == 'done':
            view = DoneFilterDetailView(self.owner, on_done=self._detail_done)
            _safe_push(self.navigation_view, view)
            return

    # ----- Callbacks from detail screens -----
    def _detail_done(self):
        self.table.reload_data()
        if callable(self.on_apply):
            try:
                self.on_apply(
                    self.owner.adv_filter,
                    set(self.owner.filter_category_hexes),
                    self.owner.filter_done
                )
            except Exception:
                pass

    def _save_filters(self, sender):
        """
        Global apply button at the bottom of the filter menu.
        Treats the current adv_filter + category + done settings
        as the active filter and closes the filter view.
        """
        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass

        if callable(self.on_apply):
            try:
                self.on_apply(
                    self.owner.adv_filter,
                    set(self.owner.filter_category_hexes),
                    self.owner.filter_done
                )
            except Exception:
                pass

        dialogs.hud_alert('Filters applied', 'success', 0.6)
        haptic_success()

        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _clear_all(self, sender):
        self.owner.filter_category_hexes.clear()
        self.owner.filter_done = 'all'
        self.owner.adv_filter = {
            'enabled': False,
            'name_mode': 'contains',
            'name_values': [],
            'name_logic': 'or',
            'name_value': '',
            'created_mode': 'any',
            'created_on': '',
            'created_from': '',
            'created_to': '',
            'due_mode': 'any',
            'due_on': '',
            'due_from': '',
            'due_to': '',
            'due_include_empty': False,
        }
        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass
        self.table.reload_data()
        dialogs.hud_alert('All filters cleared', 'success', 0.6)
        haptic_success()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()


# =========================================================
# DETAIL: NAME FILTER (MULTIPLE TERMS + AND/OR)
# =========================================================

class NameFilterDetailView(ui.View):
    """
    Filter by item name, supports multiple terms plus AND / OR logic.
    """
    def __init__(self, owner, on_done):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Item Name'
        self.background_color = 'black'
        self.owner = owner
        self.on_done = on_done

        af = owner.adv_filter or {}

        self.mode = af.get('name_mode', 'contains')
        self.values = list(af.get('name_values') or [])
        self.logic = af.get('name_logic', 'or')  # or | and

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        y = 20

        lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        lbl.text = 'Filter by name'
        lbl.text_color = 'white'
        lbl.font = ('<System-Bold>', 18)
        self.add_subview(lbl)
        y += 34

        # Text field + "Add" button
        self.tf = ui.TextField(frame=(16, y, self.width - 32 - 84, 36), flex='W')
        self.tf.placeholder = 'Enter a word or phrase'
        self.tf.clear_button_mode = 'while_editing'
        self.tf.background_color = 'white'
        self.tf.text_color = 'black'
        self.tf.tint_color = 'black'
        self.tf.corner_radius = 8
        self.add_subview(self.tf)

        self.add_btn = ui.Button(frame=(self.tf.x + self.tf.width + 8, y, 76, 36), flex='L')
        self.add_btn.title = 'Add'
        self.add_btn.corner_radius = 8
        self.add_btn.border_width = 1
        self.add_btn.border_color = (0.6, 0.6, 0.7)
        self.add_btn.background_color = (0.18, 0.18, 0.2)
        self.add_btn.tint_color = 'white'
        self.add_btn.font = ('<System>', 14)
        self.add_btn.action = self._add_term
        self.add_subview(self.add_btn)
        y += 50

        # Mode segmented (Contains / Equals / Starts)
        self.seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.seg)

        self.seg_btns = []
        def make_action(val):
            def a(sender):
                self.mode = val
                self._refresh_seg()
                haptic_selection()
            return a

        for label, val in [('Contains', 'contains'), ('Equals', 'equals'), ('Starts', 'starts')]:
            b = ui.Button(title=label, action=make_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 12)
            self.seg.add_subview(b)
            self.seg_btns.append((b, val))

        y += 40

        # Tokens container (words added to filter)
        self.tokens_view = ui.View(frame=(16, y, self.width - 32, 80), flex='W')
        self.add_subview(self.tokens_view)
        y += 90

        # AND / OR segmented (only visible if at least one word)
        self.logic_hint = ui.Label(frame=(16, y, self.width - 32, 18), flex='W')
        self.logic_hint.text = 'Combine words with:'
        self.logic_hint.text_color = 'white'
        self.logic_hint.font = ('<System>', 12)
        self.add_subview(self.logic_hint)
        y += 22

        self.logic_seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.logic_seg)

        self.logic_btns = []
        def make_logic_action(val):
            def a(sender):
                self.logic = val
                self._refresh_logic_seg()
                haptic_selection()
            return a

        for label, val in [('OR (any match)', 'or'), ('AND (all match)', 'and')]:
            b = ui.Button(title=label, action=make_logic_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 12)
            self.logic_seg.add_subview(b)
            self.logic_btns.append((b, val))

        # Layout + initial state
        self._layout_seg()
        self._layout_logic_seg()
        self._refresh_seg()
        self._refresh_tokens()
        self._refresh_logic_seg()
        self._update_logic_visibility()

    def layout(self):
        self.tf.width = self.width - 32 - 84
        self.add_btn.x = self.tf.x + self.tf.width + 8

        self.seg.width = self.width - 32
        self._layout_seg()

        self.tokens_view.width = self.width - 32

        self.logic_hint.width = self.width - 32
        self.logic_seg.width = self.width - 32
        self._layout_logic_seg()

    # ----- segment layouts -----
    def _layout_seg(self):
        gap = 6
        n = len(self.seg_btns)
        if n <= 0:
            return
        w = (self.seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.seg_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _layout_logic_seg(self):
        gap = 6
        n = len(self.logic_btns)
        if n <= 0:
            return
        w = (self.logic_seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.logic_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _refresh_seg(self):
        for (b, v) in self.seg_btns:
            if v == self.mode:
                b.background_color = (0.28, 0.28, 0.32)
                b.border_color = hex_to_ui_color('#D4AF37')
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _refresh_logic_seg(self):
        for (b, v) in self.logic_btns:
            if v == self.logic:
                b.background_color = (0.28, 0.28, 0.32)
                b.border_color = hex_to_ui_color('#D4AF37')
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _update_logic_visibility(self):
        has_terms = len(self.values) > 0
        self.logic_hint.hidden = not has_terms
        self.logic_seg.hidden = not has_terms

    # ----- token handling -----
    def _refresh_tokens(self):
        for sv in list(self.tokens_view.subviews):
            self.tokens_view.remove_subview(sv)

        x = 0
        y = 0
        row_h = 26
        max_w = self.tokens_view.width or 300
        pad = 6

        for term in self.values:
            label = term
            if len(label) > 18:
                label = label[:15] + '...'

            b = ui.Button()
            b.title = label + '  ✕'
            b.font = ('<System>', 11)
            b.corner_radius = 12
            b.border_width = 1
            b.border_color = (0.6, 0.6, 0.7)
            b.background_color = (0.2, 0.2, 0.24)
            b.tint_color = 'white'
            b.size_to_fit()
            w = b.width + 12

            if x + w > max_w and x > 0:
                x = 0
                y += row_h + 4

            b.frame = (x, y, w, row_h)
            x += w + pad

            def make_remove(t=term):
                def _r(sender):
                    try:
                        self.values.remove(t)
                    except ValueError:
                        pass
                    self._refresh_tokens()
                    self._update_logic_visibility()
                return _r
            b.action = make_remove()
            self.tokens_view.add_subview(b)

        self._update_logic_visibility()

    def _add_term(self, sender):
        txt = (self.tf.text or '').strip()
        if not txt:
            dialogs.hud_alert('Enter a word first.', 'warning', 0.7)
            return
        self.values.append(txt)
        self.tf.text = ''
        self._refresh_tokens()
        self._update_logic_visibility()
        haptic_selection()

    # ----- clear/save -----
    def _clear(self, sender):
        self.tf.text = ''
        self.mode = 'contains'
        self.logic = 'or'
        self.values = []
        self._refresh_seg()
        self._refresh_logic_seg()
        self._refresh_tokens()
        self._update_logic_visibility()
        self._save(sender)

    def _save(self, sender):
        vals = [v.strip() for v in self.values if v.strip()]
        af = self.owner.adv_filter or {}

        af['name_mode'] = self.mode
        af['name_values'] = vals
        af['name_logic'] = self.logic if vals else 'or'
        af['name_value'] = ', '.join(vals) if vals else ''

        af['enabled'] = bool(
            vals or
            (af.get('created_on') or '').strip() or
            (af.get('created_from') or '').strip() or (af.get('created_to') or '').strip() or
            (af.get('due_on') or '').strip() or
            (af.get('due_from') or '').strip() or (af.get('due_to') or '').strip()
        )
        self.owner.adv_filter = af

        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass

        haptic_success()
        if callable(self.on_done):
            self.on_done()
        if self.navigation_view:
            self.navigation_view.pop_view()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()


# =========================================================
# DETAIL: DATE FILTER (WITH DATE-ONLY "ON DATE")
# =========================================================

class DateFilterDetailView(ui.View):
    """
    kind = 'created' or 'due'

    Modes:
      - any   (no date filter)
      - on    (single date, date-only picker)
      - range (from/to, datetime picker)

    Time defaults:
      - On / From -> 12:00 AM
      - To        -> 11:59 PM
    """
    def __init__(self, owner, kind='created', title='Filter Dates', on_done=None, allow_include_empty=False):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = title
        self.background_color = 'black'
        self.owner = owner
        self.kind = kind
        self.on_done = on_done
        self.allow_include_empty = allow_include_empty

        af = owner.adv_filter or {}

        if kind == 'created':
            self.mode = af.get('created_mode', 'any')
            self.on_iso = af.get('created_on', '')
            self.from_iso = af.get('created_from', '')
            self.to_iso   = af.get('created_to', '')
            self.include_empty = False
        else:
            self.mode = af.get('due_mode', 'any')
            self.on_iso = af.get('due_on', '')
            self.from_iso = af.get('due_from', '')
            self.to_iso   = af.get('due_to', '')
            self.include_empty = bool(af.get('due_include_empty', False))

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        y = 20

        lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        lbl.text = 'Select mode'
        lbl.text_color = 'white'
        lbl.font = ('<System-Bold>', 18)
        self.add_subview(lbl)
        y += 34

        # Mode segmented
        self.mode_seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.mode_seg)
        self.mode_btns = []

        def make_mode_action(val):
            def a(sender):
                self.mode = val
                self._refresh_mode_seg()
                self._refresh_visibility()
                try:
                    haptic_selection()
                except Exception:
                    pass
            return a

        for label, val in [('Any', 'any'), ('On Date', 'on'), ('Range', 'range')]:
            b = ui.Button(title=label, action=make_mode_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 13)
            self.mode_seg.add_subview(b)
            self.mode_btns.append((b, val))
        y += 46

        # Single date button (On)
        self.on_btn = ui.Button(frame=(16, y, self.width - 32, 38), flex='W')
        self._style_field_btn(self.on_btn)
        self.on_btn.title = self._title_for(self.on_iso, 'On')
        self.on_btn.action = self._pick_on
        self.add_subview(self.on_btn)
        y += 50

        # Range buttons (From/To)
        half_w = (self.width - 48) / 2
        self.from_btn = ui.Button(frame=(16, y, half_w, 38), flex='W')
        self.to_btn   = ui.Button(frame=(16 + half_w + 16, y, half_w, 38), flex='W')
        self._style_field_btn(self.from_btn)
        self._style_field_btn(self.to_btn)
        self.from_btn.title = self._title_for(self.from_iso, 'From')
        self.to_btn.title   = self._title_for(self.to_iso, 'To')
        self.from_btn.action = self._pick_from
        self.to_btn.action   = self._pick_to
        self.add_subview(self.from_btn)
        self.add_subview(self.to_btn)
        y += 58

        # Include-empty toggle for due
        if self.allow_include_empty:
            self.empty_lbl = ui.Label(frame=(16, y, 260, 22))
            self.empty_lbl.text = 'Include items with no date'
            self.empty_lbl.text_color = 'white'
            self.empty_lbl.font = ('<System>', 14)
            self.add_subview(self.empty_lbl)

            self.empty_sw = ui.Switch(frame=(self.width - 16 - 51, y - 3, 51, 31), flex='L')
            self.empty_sw.value = self.include_empty
            self.empty_sw.action = self._toggle_empty
            self.add_subview(self.empty_sw)
            y += 44

        self._layout_mode_seg()
        self._refresh_mode_seg()
        self._refresh_visibility()

    def layout(self):
        self.mode_seg.width = self.width - 32
        self._layout_mode_seg()

        self.on_btn.width = self.width - 32

        half_w = (self.width - 48) / 2
        self.from_btn.width = half_w
        self.to_btn.width = half_w
        self.to_btn.x = 16 + half_w + 16

        if self.allow_include_empty:
            self.empty_sw.x = self.width - 16 - 51

    def _style_field_btn(self, b):
        b.corner_radius = 8
        b.border_width = 1
        b.border_color = (0.55, 0.55, 0.65)
        b.background_color = (0.17, 0.17, 0.19)
        b.tint_color = 'white'
        b.font = ('<System>', 14)

    def _layout_mode_seg(self):
        gap = 6
        n = len(self.mode_btns)
        w = (self.mode_seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.mode_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _refresh_mode_seg(self):
        for (b, v) in self.mode_btns:
            if v == self.mode:
                b.background_color = (0.28, 0.28, 0.32)
                try:
                    b.border_color = hex_to_ui_color('#D4AF37')
                except Exception:
                    b.border_color = (0.9, 0.8, 0.4)
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _refresh_visibility(self):
        self.on_btn.hidden = (self.mode != 'on')
        self.from_btn.hidden = (self.mode != 'range')
        self.to_btn.hidden   = (self.mode != 'range')

    def _title_for(self, iso, prefix):
        if not (iso or '').strip():
            return f'{prefix}: Any'
        d = parse_iso_or_now(iso)
        return f'{prefix}: {d.strftime("%d %b %Y")}'

    # ---- pickers ----
    def _pick_on(self, sender):
        self._pick_date('On Date', self.on_iso, target='on')

    def _pick_from(self, sender):
        self._pick_date('From Date', self.from_iso, target='from')

    def _pick_to(self, sender):
        self._pick_date('To Date', self.to_iso, target='to')

    def _pick_date(self, title, current_iso, target='on'):
        # Build an initial ISO that seeds time for range picks
        init_iso = current_iso or ''
        if not init_iso.strip():
            base = parse_iso_or_now('')
            base = base.replace(second=0, microsecond=0)
            if target in ('on', 'from'):
                base = base.replace(hour=0, minute=0)
            else:
                base = base.replace(hour=23, minute=59)
            init_iso = to_iso_seconds(base)

        def _apply(value):
            if value is None:
                return

            if not (value or '').strip():
                if target == 'on':
                    self.on_iso = ''
                    self.on_btn.title = self._title_for('', 'On')
                elif target == 'from':
                    self.from_iso = ''
                    self.from_btn.title = self._title_for('', 'From')
                else:
                    self.to_iso = ''
                    self.to_btn.title = self._title_for('', 'To')
                return

            dt = parse_iso_or_now(value).replace(second=0, microsecond=0)

            # Normalise stored filter times
            if target in ('on', 'from'):
                dt = dt.replace(hour=0, minute=0)        # 12:00 AM default
            else:
                dt = dt.replace(hour=23, minute=59)      # 11:59 PM default

            iso_final = to_iso_seconds(dt)

            if target == 'on':
                self.on_iso = iso_final
                self.on_btn.title = self._title_for(self.on_iso, 'On')
            elif target == 'from':
                self.from_iso = iso_final
                self.from_btn.title = self._title_for(self.from_iso, 'From')
            else:
                self.to_iso = iso_final
                self.to_btn.title = self._title_for(self.to_iso, 'To')

        # On Date -> DATE ONLY, Range -> full DATETIME
        picker_mode = 'date' if target == 'on' else 'datetime'

        picker = DateTimePicker(
            title=title,
            initial_iso=init_iso,
            allow_clear=True,
            min_iso=None,
            mode=picker_mode,
            minute_step=1,
            on_result=_apply
        )
        _safe_push(self.navigation_view, picker)

    def _toggle_empty(self, sender):
        self.include_empty = bool(sender.value)

    # ---- clear/save ----
    def _clear(self, sender):
        self.mode = 'any'
        self.on_iso = ''
        self.from_iso = ''
        self.to_iso = ''
        if self.allow_include_empty:
            self.include_empty = False
            self.empty_sw.value = False

        self._refresh_mode_seg()
        self._refresh_visibility()
        self.on_btn.title = self._title_for('', 'On')
        self.from_btn.title = self._title_for('', 'From')
        self.to_btn.title   = self._title_for('', 'To')

        self._save(sender)

    def _save(self, sender):
        af = self.owner.adv_filter or {}

        if self.kind == 'created':
            af['created_mode'] = self.mode
            af['created_on']   = self.on_iso if self.mode == 'on' else ''
            af['created_from'] = self.from_iso if self.mode == 'range' else ''
            af['created_to']   = self.to_iso if self.mode == 'range' else ''
        else:
            af['due_mode'] = self.mode
            af['due_on']   = self.on_iso if self.mode == 'on' else ''
            af['due_from'] = self.from_iso if self.mode == 'range' else ''
            af['due_to']   = self.to_iso if self.mode == 'range' else ''
            af['due_include_empty'] = bool(self.include_empty)

        af['enabled'] = bool(
            (af.get('name_values') or []) or
            (af.get('created_on') or '').strip() or
            (af.get('created_from') or '').strip() or (af.get('created_to') or '').strip() or
            (af.get('due_on') or '').strip() or
            (af.get('due_from') or '').strip() or (af.get('due_to') or '').strip()
        )

        self.owner.adv_filter = af

        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass

        try:
            haptic_success()
        except Exception:
            pass

        if callable(self.on_done):
            self.on_done()
        if self.navigation_view:
            self.navigation_view.pop_view()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()

# =========================================================
# DETAIL: DONE FILTER
# =========================================================

class DoneFilterDetailView(ui.View):
    def __init__(self, owner, on_done=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Completed / Not'
        self.background_color = 'black'
        self.owner = owner
        self.on_done = on_done
        self.mode = owner.filter_done or 'all'

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        y = 20
        lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        lbl.text = 'Filter by completed status'
        lbl.text_color = 'white'
        lbl.font = ('<System-Bold>', 18)
        self.add_subview(lbl)
        y += 36

        self.seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.seg)

        self.seg_btns = []
        def make_action(val):
            def a(sender):
                self.mode = val
                self._refresh_seg()
                haptic_selection()
            return a

        for label, val in [('All', 'all'), ('Active', 'active'), ('Done', 'done')]:
            b = ui.Button(title=label, action=make_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 12)
            self.seg.add_subview(b)
            self.seg_btns.append((b, val))

        self._layout_seg()
        self._refresh_seg()

    def layout(self):
        self.seg.width = self.width - 32
        self._layout_seg()

    def _layout_seg(self):
        gap = 6
        n = len(self.seg_btns)
        w = (self.seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.seg_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _refresh_seg(self):
        for (b, v) in self.seg_btns:
            if v == self.mode:
                b.background_color = (0.28, 0.28, 0.32)
                b.border_color = hex_to_ui_color('#D4AF37')
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _clear(self, sender):
        self.mode = 'all'
        self._refresh_seg()
        self._save(sender)

    def _save(self, sender):
        self.owner.filter_done = self.mode
        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass
        haptic_success()
        if callable(self.on_done):
            self.on_done()
        if self.navigation_view:
            self.navigation_view.pop_view()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()

# -------------------------
# Item Details (view/edit)
# -------------------------
class ItemDetailView(ui.View):
    def __init__(self, item, categories, on_save=None, on_cats_change=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Item Details'
        self.background_color = 'white'
        self.item = item
        self.categories = categories
        self.on_save = on_save
        self.on_cats_change = on_cats_change

        self.editing_enabled = False
        self._snapshot = None
        self._working = None
        self._renaming = False

        self._btn_back = ui.ButtonItem(title='Back', action=self._back)
        self._btn_edit = ui.ButtonItem(title='Edit', action=self._toggle_edit)
        self.left_button_items = [self._btn_back]
        self.right_button_items = [self._btn_edit]

        self.title_lbl = ui.Label(frame=(16, 16, self.width - 32, 28), flex='W')
        self.title_lbl.text = 'Item'
        self.title_lbl.font = ('<System-Bold>', 22)
        self.add_subview(self.title_lbl)

        y = 56
        self.swatch = ui.View(frame=(16, y, 64, 64))
        self.swatch.corner_radius = 8
        self.swatch.border_width = 1
        self.swatch.border_color = (0.85, 0.85, 0.9)
        self.add_subview(self.swatch)

        self.cat_lbl = ui.Label(frame=(96, y, self.width - 112, 24), flex='W')
        self.cat_lbl.font = ('<System>', 16)
        self.add_subview(self.cat_lbl)

        self.btn_change_color = ui.Button(frame=(96, y + 32, 140, 32))
        self.btn_change_color.title = 'Change Colour'
        self.btn_change_color.action = self._change_colour
        self._style_btn(self.btn_change_color)
        self.add_subview(self.btn_change_color)

        self.btn_rename_cat = ui.Button(frame=(244, y + 32, 140, 32))
        self.btn_rename_cat.title = 'Rename Category'
        self.btn_rename_cat.action = self._rename_category
        self._style_btn(self.btn_rename_cat)
        self.add_subview(self.btn_rename_cat)

        y += 88
        self.name_lbl = ui.Label(frame=(16, y, 100, 22))
        self.name_lbl.text = 'Name'
        self.add_subview(self.name_lbl)

        self.name_tf = ui.TextField(frame=(16, y + 24, self.width - 32, 36), flex='W')
        self.name_tf.clear_button_mode = 'while_editing'
        set_textfield_rounded(self.name_tf)
        self.add_subview(self.name_tf)

        y += 70
        self.created_lbl = ui.Label(frame=(16, y, 200, 22))
        self.created_lbl.text = 'Created At'
        self.created_lbl.font = ('<System-Bold>', 16)
        self.add_subview(self.created_lbl)

        self.created_value = ui.Label(frame=(16, y + 24, self.width - 32 - 160, 24), flex='W')
        self.add_subview(self.created_value)

        self.btn_change_created = ui.Button(frame=(self.width - 16 - 150, y + 18, 150, 32), flex='L')
        self.btn_change_created.title = 'Change Date/Time'
        self.btn_change_created.action = self._change_created_at
        self._style_btn(self.btn_change_created)
        self.add_subview(self.btn_change_created)

        tappable_w = self.width - 32 - 160 - 8
        self.created_row_tap = ui.Button(frame=(16, y, tappable_w, 54), flex='W')
        self.created_row_tap.background_color = (0, 0, 0, 0)
        self.created_row_tap.action = self._change_created_at
        self.created_row_tap.tint_color = (0, 0, 0, 0)
        self.add_subview(self.created_row_tap)

                # Due at
        y += 66
        self.due_lbl = ui.Label(frame=(16, y, 200, 22))
        self.due_lbl.text = 'Due'
        self.due_lbl.font = ('<System-Bold>', 16)
        self.add_subview(self.due_lbl)

        self.due_value = ui.Label(frame=(16, y + 24, self.width - 32 - 160, 24), flex='W')
        self.add_subview(self.due_value)

        self.btn_change_due = ui.Button(frame=(self.width - 16 - 150, y + 18, 150, 32), flex='L')
        self.btn_change_due.title = 'Change Date/Time'
        self.btn_change_due.action = self._change_due_at
        self._style_btn(self.btn_change_due)
        self.add_subview(self.btn_change_due)

        tappable_w = self.width - 32 - 160 - 8
        self.due_row_tap = ui.Button(frame=(16, y, tappable_w, 54), flex='W')
        self.due_row_tap.background_color = (0, 0, 0, 0)
        self.due_row_tap.action = self._change_due_at
        self.due_row_tap.tint_color = (0, 0, 0, 0)
        self.add_subview(self.due_row_tap)

        y += 66
        self.done_lbl = ui.Label(frame=(16, y, 120, 22))
        self.done_lbl.text = 'Completed'
        self.add_subview(self.done_lbl)

        self.done_sw = ui.Switch(frame=(140, y - 6, 51, 31))
        self.done_sw.action = self._on_done_toggled
        self.add_subview(self.done_sw)

        self.done_tap = ui.Button(frame=self.done_lbl.frame)
        self.done_tap.background_color = (0, 0, 0, 0)
        self.done_tap.action = self._toggle_done_from_label
        self.add_subview(self.done_tap)

        self.done_status = ui.Label(frame=(200, y, 140, 22))
        self.done_status.font = ('<System>', 14)
        self.add_subview(self.done_status)

        self._load_from_item()
        self._apply_edit_state()
        self.done_sw.bring_to_front()

    def layout(self):
        self.title_lbl.width = self.width - 32
        self.name_tf.width = self.width - 32
        self.created_value.width = self.width - 32 - 160
        self.btn_change_created.frame = (self.width - 16 - 150, self.created_value.y - 6, 150, 32)
        self.due_value.width = self.width - 32 - 160
        self.btn_change_due.frame = (self.width - 16 - 150, self.due_value.y - 6, 150, 32)
        self.done_tap.frame = self.done_lbl.frame
        self.created_value.width = self.width - 32 - 160
        self.btn_change_created.frame = (self.width - 16 - 150, self.created_value.y - 6, 150, 32)
        tappable_w = self.width - 32 - 160 - 8
        self.created_row_tap.frame = (16, self.created_lbl.y, tappable_w, 54)

    def _style_btn(self, btn):
        btn.corner_radius = 8
        btn.border_width = 1
        btn.border_color = (0.85, 0.85, 0.9)
        btn.background_color = (0.96, 0.96, 0.98)
        btn.tint_color = (0.1, 0.1, 0.2)

    def _ensure_working(self):
        if self._working is None:
            self._working = self._snapshot_from_item()

    def _display_category_name(self, hx):
        name = (self.categories.get(hx, '') or '').strip()
        return name or next((n for n, h in _PALETTE if h == hx), 'Category')

    def _update_done_status_text(self, is_done):
        self.done_status.text = 'Yes' if is_done else 'No'
        self.done_status.text_color = (0, 0.5, 0) if is_done else (0.5, 0, 0)

    def _load_from_state(self, state):
        hx = state.get('color', '#8E8E93')
        try:
            self.swatch.background_color = hex_to_ui_color(hx)
        except Exception:
            self.swatch.background_color = 'white'
        self.cat_lbl.text = f'Category: {self._display_category_name(hx)}'
        self.name_tf.text = state.get('title', '')
        self.created_value.text = _fmt_dt_for_label(state.get('created_at', ''))
        self.due_value.text     = _fmt_dt_for_label(state.get('due_at', ''))
        dv = bool(state.get('done', False))
        self.done_sw.value = dv
        self._update_done_status_text(dv)

    def _load_from_item(self):
        self._load_from_state(self.item)

    def _apply_edit_state(self):
        e = self.editing_enabled
        self.name_tf.enabled = e
        self.btn_change_color.enabled = e
        self.btn_rename_cat.enabled = e
        self.btn_change_created.enabled = e
        self.btn_change_due.enabled = e
        self.done_sw.enabled = e
        self.done_sw.touch_enabled = e
        self.done_sw.alpha = 1.0 if e else 0.5
        self.done_tap.enabled = e
        self.done_tap.touch_enabled = e
        self.done_sw.bring_to_front()
        self._btn_edit.title = 'Save' if e else 'Edit'

    def _snapshot_from_item(self):
        return {
            'title': self.item.get('title', ''),
            'created_at': self.item.get('created_at', ''),
            'due_at': self.item.get('due_at', ''),
            'done': bool(self.item.get('done', False)),
            'color': self.item.get('color', '#8E8E93'),
        }

    def _state_from_ui(self):
        in_edit = self.editing_enabled and (self._working is not None)
        color = (self._working.get('color') if in_edit else self.item.get('color'))
        done  = (bool(self._working.get('done')) if in_edit else bool(self.done_sw.value))
        created_at = (self._working.get('created_at') if in_edit else self.item.get('created_at', ''))
        due_at     = (self._working.get('due_at')     if in_edit else self.item.get('due_at', ''))
        return {
            'title': (self.name_tf.text or '').strip(),
            'created_at': created_at or '',
            'due_at': due_at or '',
            'done': done,
            'color': color or '#8E8E93',
        }

    def _has_pending_changes(self):
        if not self.editing_enabled or not self._snapshot:
            return False
        cur = self._state_from_ui()
        snap = self._snapshot
        return any(cur[k] != snap.get(k) for k in ('title', 'created_at', 'due_at', 'done', 'color'))

    def _back(self, sender):
        if not self.editing_enabled:
            if self.navigation_view: self.navigation_view.pop_view()
            else: self.close()
            return
        if self._has_pending_changes():
            if dialogs.yes_no_alert('Discard changes?', 'You have unsaved changes.', 'Discard', 'Keep Editing'):
                self.editing_enabled = False
                self._working = None
                self._load_from_item()
                self._apply_edit_state()
                if self.navigation_view: self.navigation_view.pop_view()
                else: self.close()
            return
        self.editing_enabled = False
        self._working = None
        self._apply_edit_state()
        if self.navigation_view: self.navigation_view.pop_view()
        else: self.close()

    def _toggle_edit(self, sender):
        if not self.editing_enabled:
            self._snapshot = self._snapshot_from_item()
            self._working = dict(self._snapshot)
            self.editing_enabled = True
            self._load_from_state(self._working)
            self._apply_edit_state()
            return
        state = self._state_from_ui()
        if not state['title']:
            dialogs.hud_alert('Name cannot be empty.', 'error', 1.0)
            return
        self.item['title'] = state['title']
        self.item['created_at'] = state['created_at']
        self.item['due_at'] = state['due_at']
        self.item['done'] = state['done']
        self.item['color'] = state['color']
        if callable(self.on_save):
            self.on_save(self.item)
        self.editing_enabled = False
        self._working = None
        self._snapshot = None
        self._load_from_item()
        self._apply_edit_state()
        dialogs.hud_alert('Saved', 'success', 0.6)

    def _on_done_toggled(self, sender):
        if not self.editing_enabled:
            sender.value = bool(self.item.get('done', False))
            dialogs.hud_alert('Tap Edit to change.', 'warning', 0.6)
            return
        self._ensure_working()
        self._working['done'] = bool(sender.value)
        self._update_done_status_text(self._working['done'])
        haptic_success()

    def _toggle_done_from_label(self, sender):
        if not self.editing_enabled:
            dialogs.hud_alert('Tap Edit to change.', 'warning', 0.6)
            return
        new_val = not bool(self.done_sw.value)
        self.done_sw.value = new_val
        self._on_done_toggled(self.done_sw)

    def _change_colour(self, sender):
        if not self.editing_enabled:
            return
        def picked(hex_val, _label):
            self._ensure_working()
            self._working['color'] = hex_val
            self._load_from_state(self._working)
        picker = ColorPicker(_PALETTE, self.categories, on_pick=picked, title='Pick a Colour')
        if self.navigation_view:
            _safe_push(self.navigation_view, picker)
        else:
            ui.NavigationView(picker).present('fullscreen')

    def _rename_category(self, sender):
        if not self.editing_enabled or self._renaming:
            return
        hx = (self._working['color'] if self._working else self.item.get('color', '#8E8E93'))
        self._renaming = True
        @ui.in_background
        def _worker():
            changed = False
            try:
                changed = reuse_rename_category(hx, self.categories, _PALETTE, title_prefix='Rename')
            finally:
                def _apply():
                    self._renaming = False
                    if changed:
                        if callable(self.on_cats_change):
                            self.on_cats_change(self.categories)
                        state = self._working if self._working else self._snapshot_from_item()
                        self._load_from_state(state)
                        dialogs.hud_alert('Category updated', 'success', 0.6)
                ui.delay(_apply, 0.0)
        _worker()

    def _pick_dt(self, title, initial_iso, allow_clear, set_field_key):
        def _apply_result(value):
            if value is None:
                return
            self._ensure_working()
            self._working[set_field_key] = value
            if set_field_key == 'created_at':
                self.created_value.text = _fmt_dt_for_label(value)
            elif set_field_key == 'due_at':
                self.due_value.text = _fmt_dt_for_label(value)
        picker = DateTimePicker(
            title=title,
            initial_iso=initial_iso,
            allow_clear=allow_clear,
            min_iso=None if set_field_key == 'created_at' else None,
            mode='datetime',
            minute_step=1,
            on_result=_apply_result
        )
        if self.navigation_view:
            _safe_push(self.navigation_view, picker)
        else:
            ui.NavigationView(picker).present('fullscreen')

    def _change_created_at(self, sender):
        if not self.editing_enabled: return
        cur = (self._working.get('created_at') if self._working else self.item.get('created_at', ''))
        self._pick_dt('Set Created', cur, allow_clear=False, set_field_key='created_at')

    def _change_due_at(self, sender):
        if not self.editing_enabled: return
        cur = (self._working.get('due_at') if self._working else self.item.get('due_at', ''))
        self._pick_dt('Set Due Date', cur, allow_clear=True, set_field_key='due_at')

# -------------------------
# New Entry (black) — Due date with new picker
# -------------------------
class NewEntryView(ui.View):
    def __init__(self, on_save, cats):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'New Entry'
        self.background_color = 'black'
        self.on_save = on_save
        self.cats = cats
        self.selected_hex = '#007AFF'
        self.selected_name = 'blue'
        self.due_at_iso = ''

        self.lbl = ui.Label(frame=(16, 5, self.width - 32, 60), flex='W')
        self.lbl.font = ('Arial-BoldMT', 36)
        self.lbl.text = 'New Entry'
        self.lbl.text_color = hex_to_ui_color('#D4AF37')
        self.lbl.alignment = ui.ALIGN_LEFT
        self.add_subview(self.lbl)
        
        self.name_lbl = ui.Label(frame=(16, 90, 120, 30))
        self.name_lbl.text = 'Name'
        self.name_lbl.text_color = 'white'
        self.name_lbl.font = ('<system-bold>', 16)  # correct bold system font
        self.add_subview(self.name_lbl)
        
        
        self.name_tf = ui.TextField(frame=(16, 120, self.width - 32, 40), flex='W')
        self.name_tf.placeholder = 'Enter task name...'
        self.name_tf.clear_button_mode = 'while_editing'
        self.name_tf.background_color = 'white'
        self.name_tf.text_color = 'black'
        self.name_tf.tint_color = 'black'
        self.name_tf.corner_radius = 8
        self.add_subview(self.name_tf)

        self.color_lbl = ui.Label(frame=(16, 174, 120, 30))
        self.color_lbl.text = 'Colour'
        self.color_lbl.text_color = 'white'
        self.add_subview(self.color_lbl)
        self.color_lbl.font = ('<system-bold>',16)

        self.swatch = ui.View(frame=(16, 206, 60, 36))
        self.swatch.border_width = 1
        self.swatch.corner_radius = 6
        self.swatch.border_color = (0.9, 0.9, 0.9)
        self._update_swatch(self.selected_hex)
        self.add_subview(self.swatch)

        self.pick_btn = ui.Button(frame=(90, 206, 170, 36))
        self.pick_btn.title = 'Choose Colour'
        self.pick_btn.action = self.choose_colour
        self._style_button(self.pick_btn)
        self.add_subview(self.pick_btn)

        self.cat_lbl = ui.Label(frame=(16, 250, self.width - 32, 24), flex='W')
        self.cat_lbl.text_color = 'white'
        self._refresh_category_label()
        self.add_subview(self.cat_lbl)

        y = 280
        self.due_lbl = ui.Label(frame=(16, y, 120, 30))
        self.due_lbl.text = 'Due'
        self.due_lbl.text_color = 'white'
        self.due_lbl.font = ('<system-bold>', 16)
        self.add_subview(self.due_lbl)

        self.due_value = ui.Label(frame=(16, y + 28, self.width - 32 - 180, 24), flex='W')
        self.due_value.text = _fmt_dt_for_label('')
        self.due_value.text_color = 'white'
        self.add_subview(self.due_value)

        self.due_btn = ui.Button(frame=(self.width - 16 - 160, y + 22, 160, 36), flex='L')
        self.due_btn.title = 'Set Due...'
        self.due_btn.action = self._set_due
        self._style_button(self.due_btn)
        self.add_subview(self.due_btn)

        self.left_button_items = [ui.ButtonItem(title='Cancel', action=self.cancel)]
        self.right_button_items = [ui.ButtonItem(title='Save', action=self.save)]

    def layout(self):
        self.lbl.width = self.width - 32
        self.name_tf.width = self.width - 32
        self.cat_lbl.width = self.width - 32
        self.due_value.width = self.width - 32 - 180
        self.due_btn.frame = (self.width - 16 - 160, self.due_value.y - 6, 160, 36)

    def _style_button(self, btn):
        btn.tint_color = 'white'
        btn.border_width = 1
        btn.corner_radius = 8
        btn.border_color = (0.9, 0.9, 0.9)
        btn.background_color = (0.12, 0.12, 0.12)

    def _update_swatch(self, hexc):
        try:
            self.swatch.background_color = hex_to_ui_color(hexc)
        except Exception:
            self.swatch.background_color = 'white'

    def _refresh_category_label(self):
        cat = (self.cats.get(self.selected_hex, '') or '').strip()
        self.cat_lbl.text = f'Category: {cat if cat else "No category"}'

    def choose_colour(self, sender):
        def picked(hex_val, label):
            self.selected_hex = hex_val
            self.selected_name = label
            self._update_swatch(hex_val)
            self._refresh_category_label()
        picker = ColorPicker(_PALETTE, self.cats, on_pick=picked, title='Pick a Colour')
        if self.navigation_view:
            _safe_push(self.navigation_view, picker)
        else:
            ui.NavigationView(picker).present('fullscreen')

    def _set_due(self, sender):
        def _apply(value):
            if value is None:
                return
            self.due_at_iso = value
            self.due_value.text = _fmt_dt_for_label(value)
        picker = DateTimePicker(
            title='Set Due Date',
            initial_iso=self.due_at_iso,
            allow_clear=True,
            min_iso=None,
            mode='datetime',
            minute_step=1,
            on_result=_apply
        )
        if self.navigation_view:
            _safe_push(self.navigation_view, picker)
        else:
            ui.NavigationView(picker).present('fullscreen')

    def cancel(self, sender=None):
        if self.navigation_view: self.navigation_view.pop_view()
        else: self.close()

    def save(self, sender):
        title = (self.name_tf.text or '').strip()
        if not title:
            dialogs.hud_alert('Please enter a name.', 'error', 1.0)
            return
        if callable(self.on_save):
            self.on_save(
                title=title,
                hexc=self.selected_hex,
                created_at=datetime.now().isoformat(),
                due_at=self.due_at_iso
            )
        self.cancel()

# -------------------------
# Table DataSource — custom “•••” pill
# -------------------------
class TodoDataSource(object):
    def __init__(self, items, owner):
        self.items = items
        self.owner = owner
        self.filtered_indices = []
        self.refresh()

    def _match_done(self, it):
        f = self.owner.filter_done
        if f == 'active': return not it.get('done', False)
        if f == 'done':   return bool(it.get('done', False))
        return True

    def _match_category(self, it):
        sel = self.owner.filter_category_hexes
        return True if not sel else (it.get('color') in sel)

    def _match_name(self, it):
        terms = getattr(self.owner, 'filter_name_terms', [])
        if not terms:
            return True
        title = (it.get('title', '') or '').lower()
        return any(t in title for t in terms)

    def _match_created(self, it):
        cf = getattr(self.owner, 'filter_created_from', None)
        ct = getattr(self.owner, 'filter_created_to', None)
        if not cf and not ct:
            return True
        s = it.get('created_at', '') or ''
        if not s:
            return False
        try:
            created = parse_iso_or_now(s)
        except Exception:
            return False
        if cf and created < cf:
            return False
        if ct and created > ct:
            return False
        return True

    def _match_due(self, it):
        df = getattr(self.owner, 'filter_due_from', None)
        dtv = getattr(self.owner, 'filter_due_to', None)
        if not df and not dtv:
            return True
        s = it.get('due_at', '') or ''
        if not s:
            return False
        try:
            due = parse_iso_or_now(s)
        except Exception:
            return False
        if df and due < df:
            return False
        if dtv and due > dtv:
            return False
        return True

    def refresh(self):
        self.filtered_indices = [
            i for i, it in enumerate(self.items)
            if self._match_done(it)
            and self._match_category(it)
            and self._match_name(it)
            and self._match_created(it)
            and self._match_due(it)
        ]

    def tableview_number_of_sections(self, tv): return 1
    def tableview_number_of_rows(self, tv, section): return len(self.filtered_indices)

    def _item_at_row(self, row):
        return self.items[self.filtered_indices[row]]

    def tableview_cell_for_row(self, tv, section, row):
        cell = ui.TableViewCell()
        item = self._item_at_row(row)

        title = item['title']
        if item.get('done'):
            title = '✓ ' + title
            cell.text_label.alpha = 0.55
        else:
            cell.text_label.alpha = 1.0
        cell.text_label.text = title

        hexc = item.get('color', '#8E8E93')
        try:
            cell.background_color = hex_to_ui_color(hexc)
        except Exception:
            cell.background_color = 'white'
            hexc = '#8E8E93'
        fg = best_text_color_for_bg(hexc)
        cell.text_label.text_color = fg

        for sv in list(cell.content_view.subviews):
            if getattr(sv, 'name', '') == 'more_btn':
                cell.content_view.remove_subview(sv)

        BTN_W, BTN_H = 36, 24
        btn = ui.Button(title='•••')
        btn.name = 'more_btn'
        btn.width, btn.height = BTN_W, BTN_H
        btn.corner_radius = 6
        btn.border_width = 0
        btn.background_color = (0, 0, 0, 0)
        btn.tint_color = fg
        btn.font = ('<System-Bold>', int(BTN_H * 0.9))
        x = cell.content_view.width - BTN_W - 12
        y = int((cell.content_view.height - BTN_H) / 2)
        btn.frame = (x, y, BTN_W, BTN_H)
        btn.flex = 'L'
        btn.action = (lambda s, r=row: self._open_detail_for_row(tv, r))
        cell.content_view.add_subview(btn)
        return cell

    def _open_detail_for_row(self, tv, row):
        orig_idx = self.filtered_indices[row]
        item_ref = self.items[orig_idx]

        def on_save(_updated_item):
            save_items(self.items)
            self.refresh()
            tv.reload_data()

        def on_cats_change(_cats):
            self.owner.categories = _cats
            self.owner._rebuild_filter_summary()
            tv.reload_data()

        detail = ItemDetailView(item=item_ref, categories=self.owner.categories,
                                on_save=on_save, on_cats_change=on_cats_change)
        if self.owner.navigation_view:
            _safe_push(self.owner.navigation_view, detail)
        else:
            ui.NavigationView(detail).present('fullscreen')

    def tableview_can_delete(self, tv, section, row): return True
    def tableview_delete(self, tv, section, row):
        try:
            del self.items[self.filtered_indices[row]]
            save_items(self.items)
        finally:
            self.refresh()
            tv.reload_data()

    def tableview_did_select(self, tv, section, row):
        it = self._item_at_row(row)
        new_done = not it.get('done')
        it['done'] = new_done
        save_items(self.items)
        haptic_success()
        self.refresh()
        tv.reload_data()

# -------------------------
# Main App View
# -------------------------
class TodoApp(ui.View):
    def __init__(self):
        super().__init__()
        self.name = 'To-Do'
        self.background_color = 'white'

        self.items = load_items()
        self.categories = load_categories()

        # Advanced filter state
        self.filter_done = 'all'
        self.filter_category_hexes = set()
        self.filter_name_terms = []
        self.filter_created_from = None
        self.filter_created_to = None
        self.filter_due_from = None
        self.filter_due_to = None

        self.ds = TodoDataSource(self.items, self)

        gold = '#D4AF37'
        dark_gold = '#6E5A12'
        self.banner = ui.View(frame=(12, 8, self.width - 24, 64), flex='W')
        self.banner.background_color = 'black'
        self.banner.corner_radius = 12
        self.banner.border_width = 1
        self.banner.border_color = hex_to_ui_color(gold)
        self.add_subview(self.banner)

        self.banner_shadow = ui.Label(frame=(18, 14, self.banner.width - 36, 36), flex='W')
        self.banner_shadow.text = "Matt’s To Do List📋"
        self.banner_shadow.font = ('Arial-BoldMT', 28)
        self.banner_shadow.text_color = hex_to_ui_color(dark_gold)
        self.banner_shadow.alignment = ui.ALIGN_CENTER
        self.banner.add_subview(self.banner_shadow)

        self.banner_title = ui.Label(frame=(16, 12, self.banner.width - 32, 36), flex='W')
        self.banner_title.text = "Matt’s To Do List📋"
        self.banner_title.font = ('Arial-BoldMT', 28)
        self.banner_title.text_color = hex_to_ui_color(gold)
        self.banner_title.alignment = ui.ALIGN_CENTER
        self.banner.add_subview(self.banner_title)

        self.banner_underline = ui.View(frame=(12, self.banner.y + self.banner.height + 4, self.width - 24, 2), flex='W')
        self.banner_underline.background_color = hex_to_ui_color(gold)
        self.add_subview(self.banner_underline)

        self.header = ui.View(frame=(12, self.banner_underline.y + 8, self.width - 24, 152), flex='W')
        self.header.background_color = (0.95, 0.95, 0.97)
        self.header.corner_radius = 12
        self.header.border_width = 1
        self.header.border_color = (0.86, 0.86, 0.9)
        self.add_subview(self.header)

        self.title_lbl = ui.Label(frame=(16, 10, self.header.width - 32, 20), flex='W')
        self.title_lbl.text = 'Actions'
        self.title_lbl.font = ('<System-Bold>', 16)
        self.header.add_subview(self.title_lbl)

        self.seg_container = ui.View(frame=(16, 34, self.header.width - 32, 32), flex='W')
        self.header.add_subview(self.seg_container)
        self.seg_btns = []

        def make_seg_action(value):
            return lambda sender: self._set_done_filter(value)

        for label, val in [('All', 'all'), ('Active', 'active'), ('Done', 'done')]:
            b = ui.Button()
            b.title = label
            b.action = make_seg_action(val)
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.8, 0.8, 0.85)
            b.background_color = (1, 1, 1)
            b.tint_color = (0.1, 0.1, 0.2)
            self.seg_container.add_subview(b)
            self.seg_btns.append((b, val))

        # Header action buttons in one clean row
        self.btn_cats      = self._make_btn('Categories', self.action_categories)
        self.btn_filter    = self._make_btn('Filter', self.action_filter_category)
        self.btn_clearflt  = self._make_btn('Clear Filter', self.action_clear_filter)
        self.btn_knowledge = self._make_btn('Knowledge', self.action_knowledge)

        for b in (self.btn_cats, self.btn_filter, self.btn_clearflt, self.btn_knowledge):
            self.header.add_subview(b)

        self.section_lbl = ui.Label(frame=(16, self.header.y + self.header.height + 13, self.width - 32, 22), flex='W')
        self.section_lbl.text = 'Your Tasks'
        self.section_lbl.font = ('<System-Bold>', 25)
        self.add_subview(self.section_lbl)

        self.filters_lbl = ui.Label(frame=(16, self.section_lbl.y + 25, self.width - 32, 16), flex='W')
        self.filters_lbl.font = ('<System>', 12)
        self.filters_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.filters_lbl)

        self.chip_bar = ui.View(frame=(16, self.filters_lbl.y + 20, self.width - 32, 20), flex='W')
        self.add_subview(self.chip_bar)
        self.chip_bar.hidden = True

        self.chip_bar_btn = ui.Button(frame=self.chip_bar.bounds, flex='WH')
        self.chip_bar_btn.background_color = (0, 0, 0, 0)
        self.chip_bar_btn.action = self._chip_bar_tapped_clear
        self.chip_bar.add_subview(self.chip_bar_btn)

        self.list_card = ui.View(frame=(12, self.chip_bar.y + 5, self.width - 24, self.height - (self.chip_bar.y + 12 + 5)), flex='WH')
        self.list_card.background_color = (0.98, 0.98, 0.99)
        self.list_card.corner_radius = 12
        self.list_card.border_width = 1
        self.list_card.border_color = (0.9, 0.9, 0.93)
        self.add_subview(self.list_card)

        self.table = ui.TableView(frame=self.list_card.bounds, flex='WH')
        self.table.data_source = self.ds
        self.table.delegate = self.ds
        self.table.row_height = 46
        self.list_card.add_subview(self.table)

        self._set_done_filter('all')
        self._rebuild_filter_summary()

        self.plus_btn = ui.Button()
        self.plus_btn.title = '+'
        self.plus_btn.action = self.action_add
        self.plus_btn.width = self.plus_btn.height = 60
        self.plus_btn.corner_radius = 60
        self.plus_btn.border_width = 0
        self.plus_btn.border_color = (0.8, 0.8, 0.85)
        self.plus_btn.background_color = (1, 1, 1)
        self.plus_btn.tint_color = (0, 0, 0)
        self.plus_btn.font = ('<System-Bold>', 47)
        self.add_subview(self.plus_btn)

    def _make_btn(self, title, action):
        b = ui.Button()
        b.title = title
        b.action = action
        b.corner_radius = 8
        b.border_width = 1
        b.border_color = (0.8, 0.8, 0.85)
        b.background_color = (1, 1, 1)
        b.tint_color = (0.1, 0.1, 0.2)
        return b

    def _layout_hline(self, buttons, y):
        n = len(buttons)
        if n == 0:
            return
        left, right, gap = 16, self.header.width - 16, 8
        w = (right - left - gap * (n - 1)) / float(n)
        x = left
        for b in buttons:
            b.frame = (x, y, w, 36)
            x += w + gap

    def _layout_segmented(self):
        n = len(self.seg_btns)
        left, right, gap = 0, self.seg_container.width, 6
        w = (right - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.seg_btns:
            b.frame = (x, 0, w, 32)
            x += w + gap

    def _selected_names(self):
        names = []
        for base_name, hx in _PALETTE:
            if hx in self.filter_category_hexes:
                names.append(self.categories.get(hx, '') or base_name)
        return names

    def _rebuild_filter_summary(self):
        status = {'all': 'All', 'active': 'Active', 'done': 'Done'}[self.filter_done]
        sel = list(self.filter_category_hexes)

        if not sel:
            base = f'Status: {status} | Category: All Categories'
        else:
            names = self._selected_names()
            base = (
                f"Status: {status} | Category: {names[0]}" if len(names) == 1
                else f"Status: {status} | Categories: {len(names)} selected"
            )

        adv = []
        if self.filter_name_terms:
            adv.append('Name')
        if self.filter_created_from or self.filter_created_to:
            adv.append('Created')
        if self.filter_due_from or self.filter_due_to:
            adv.append('Due')
        if adv:
            base += ' | ' + ', '.join(adv) + ' filters'

        self.filters_lbl.text = base

        if not sel:
            self.chip_bar.hidden = True
            return

        self.chip_bar.hidden = False
        for v in list(self.chip_bar.subviews):
            if v is self.chip_bar_btn:
                continue
            self.chip_bar.remove_subview(v)

        MAX = 6
        padding = 4
        size = 16
        x = 0
        shown = 0
        for hx in sel[:MAX]:
            chip = ui.View(frame=(x, 0, size, size))
            chip.corner_radius = 4
            chip.border_width = 1
            chip.border_color = (0.8, 0.8, 0.85)
            try:
                chip.background_color = hex_to_ui_color(hx)
            except Exception:
                chip.background_color = 'white'
            self.chip_bar.add_subview(chip)
            x += size + padding
            shown += 1
        extra = len(sel) - shown
        if extra > 0:
            more_lbl = ui.Label(frame=(x, -2, 50, size + 4))
            more_lbl.text = f'+{extra}'
            more_lbl.font = ('<System>', 12)
            more_lbl.text_color = (0.35, 0.35, 0.4)
            self.chip_bar.add_subview(more_lbl)
            x += 24
        self.chip_bar_btn.frame = (0, 0, max(x, 44), size)

    def _set_done_filter(self, val):
        self.filter_done = val
        for (b, v) in self.seg_btns:
            if v == val:
                b.background_color = (0.92, 0.92, 0.96)
                b.border_color = (0.4, 0.4, 0.6)
            else:
                b.background_color = (1, 1, 1)
                b.border_color = (0.8, 0.8, 0.85)
        self.ds.refresh()
        self._rebuild_filter_summary()
        self.table.reload_data()

    def layout(self):
        self.banner.frame = (12, 8, self.width - 24, 64)
        self.banner_shadow.frame = (18, 14, self.banner.width - 36, 36)
        self.banner_title.frame  = (16, 12, self.banner.width - 32, 36)
        self.banner_underline.frame = (12, self.banner.y + self.banner.height + 4, self.width - 24, 2)

        self.header.frame = (12, self.banner_underline.y + 8, self.width - 24, 152)
        self.title_lbl.width = self.header.width - 32
        self.seg_container.frame = (16, 34, self.header.width - 32, 32)
        self._layout_segmented()
        # Now four header buttons, including Knowledge
        self._layout_hline([self.btn_cats, self.btn_filter, self.btn_clearflt, self.btn_knowledge], y=74)

        self.section_lbl.frame = (16, self.header.y + self.header.height + 13, self.width - 32, 22)
        self.filters_lbl.frame = (16, self.section_lbl.y + 25, self.width - 32, 16)
        self.chip_bar.frame = (16, self.filters_lbl.y + 20, self.width - 32, 20)
        self.chip_bar_btn.frame = self.chip_bar.bounds

        list_top = self.chip_bar.y + 5
        self.list_card.frame = (12, list_top, self.width - 24, self.height - (list_top + 12))
        self.table.frame = self.list_card.bounds

        pad_right_for_pill = 12
        size = self.plus_btn.width
        plus_x = self.list_card.x + self.list_card.width - pad_right_for_pill - size + 13
        plus_y = self.section_lbl.y + int((self.section_lbl.height - size) / 2) + 7
        self.plus_btn.frame = (plus_x, plus_y, size, size)
        self.plus_btn.bring_to_front()

    def _chip_bar_tapped_clear(self, sender):
        if not self.filter_category_hexes:
            return
        self.filter_category_hexes.clear()
        self.ds.refresh()
        self._rebuild_filter_summary()
        self.table.reload_data()
        dialogs.hud_alert('Color filter cleared', 'success', 0.6)

    def action_add(self, sender):
        def on_save(title, hexc, created_at, due_at):
            self.items.append({'title': title, 'done': False, 'color': hexc,
                               'created_at': created_at, 'due_at': due_at})
            save_items(self.items)
            self.ds.items = self.items
            self.ds.refresh()
            self.table.reload_data()
        view = NewEntryView(on_save=on_save, cats=self.categories)
        _safe_push(self.navigation_view, view)

    def action_categories(self, sender):
        def on_change(cats):
            self.categories = cats
            self._rebuild_filter_summary()
            self.table.reload_data()
        view = CategoriesView(_PALETTE, self.categories, on_change=on_change)
        _safe_push(self.navigation_view, view)

    def action_filter_category(self, sender):
        view = FilterView(self)
        _safe_push(self.navigation_view, view)

    def action_clear_filter(self, sender):
        self.filter_category_hexes.clear()
        self.filter_name_terms = []
        self.filter_created_from = None
        self.filter_created_to = None
        self.filter_due_from = None
        self.filter_due_to = None
        self._set_done_filter('all')
        dialogs.hud_alert('All filters cleared', 'success', 0.6)

    def action_knowledge(self, sender):
        """Open the Knowledge section from the main To Do screen."""
        view = KnowledgeCenterView()
        nav = self.navigation_view
        if nav:
            _safe_push(nav, view)
        else:
            view.present('sheet')

    def will_close(self):
        save_items(self.items)
        save_categories(self.categories)

# -------------------------
# Presentation guards
# -------------------------
_APP_PRESENTING = False
_LAST_PUSH_TS = 0.0

def _safe_present_root(nav_view, mode='fullscreen'):
    global _APP_PRESENTING
    if getattr(nav_view, 'superview', None) is not None or _APP_PRESENTING:
        return
    _APP_PRESENTING = True
    def _do():
        global _APP_PRESENTING
        try:
            nav_view.present(mode)
        except ValueError as e:
            if 'already being presented' not in str(e) and 'animation is in progress' not in str(e):
                raise
        finally:
            _APP_PRESENTING = False
    ui.delay(_do, 0.30)

def _safe_push(nav_view, child_view, min_gap=0.30):
    global _LAST_PUSH_TS
    now = time.monotonic()
    gap = now - _LAST_PUSH_TS
    def _do_push():
        global _LAST_PUSH_TS
        try:
            nav_view.push_view(child_view)
        except ValueError as e:
            if 'animation is in progress' in str(e) or 'already being presented' in str(e):
                ui.delay(lambda: _safe_push(nav_view, child_view, min_gap), min_gap)
                return
            else:
                raise
        _LAST_PUSH_TS = time.monotonic()
    if gap < min_gap:
        ui.delay(_do_push, min_gap - gap)
    else:
        _do_push()

# -------------------------
# Entry point (safe present)
# -------------------------
if __name__ == '__main__':
    try:
        ui.cancel_delays()
    except Exception:
        pass
    root = TodoApp()
    nav = ui.NavigationView(root)
    nav.navigation_bar_hidden = False
    _safe_present_root(nav, 'fullscreen')