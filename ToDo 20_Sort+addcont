# file: todo_pythonista.py
# version: 3.5
# - Safer navigation pushes: global 0.3s guard to prevent double-present / "animation in progress" errors
# - DateTimePicker title shown above header; month/year stays in header
# - Bigger/easier Back button on New Entry
# - Categories actions (Rename / Clear / Cancel) fully wired
# - Colour picker remains fixed-palette (no custom hex entry)
# - New FilterView for advanced filtering (name, dates, colour, completed)h
#Current theme colour: #D4AF37

import ui
import dialogs
import json
import os
import webbrowser
import re
import time
from datetime import datetime, date, timedelta
from calendar import monthrange
from pathlib import Path
from objc_util import ObjCInstance, ObjCClass
import calendar

def ensure_additional_content_fields(item):
    """
    Make sure the item dict has the three additional-content fields
    we rely on everywhere: description (str), links (list), media (list).
    This lets both NEW entries and mEDITED items talk the same language.
    """
    if item is None:
        return
    if 'description' not in item or not isinstance(item.get('description'), str):
        # normalise old None/False/etc to ''
        item['description'] = item.get('description') or ''
    if 'links' not in item or not isinstance(item.get('links'), list):
        raw = item.get('links') or []
        # normalise any tuple/single value to a list
        if isinstance(raw, (str, dict)):
            raw = [raw]
        item['links'] = list(raw)
    if 'media' not in item or not isinstance(item.get('media'), list):
        raw = item.get('media') or []
        if isinstance(raw, (str, dict)):
            raw = [raw]
        item['media'] = list(raw)


# Knowledge centre storage
KNOWLEDGE_DATA_FILE = Path(__file__).with_name('knowledge_store.json')

# ==== 1) DROP-IN: Haptics helper ====
try:
    from objc_util import ObjCClass
    _UINotif  = ObjCClass('UINotificationFeedbackGenerator')
    _UIImpact = ObjCClass('UIImpactFeedbackGenerator')
    _UISelect = ObjCClass('UISelectionFeedbackGenerator')
except Exception:
    _UINotif = _UIImpact = _UISelect = None

def _make_safe_summary(content, max_len=80):
    """
    Turn arbitrary content into a safe, single line summary.

    - Handles None, empty strings, and whitespace
    - Never raises IndexError
    """
    if content is None:
        return ''
    text = str(content).strip()
    if not text:
        return ''
    lines = text.splitlines()
    if not lines:
        return ''
    return lines[0][:max_len]

def haptic_success():
    try:
        if not _UINotif: return
        _UINotif.new().notificationOccurred_(0)
    except Exception:
        pass

def haptic_selection():
    try:
        if not _UISelect: return
        _UISelect.new().selectionChanged()
    except Exception:
        pass

def haptic_impact_light():
    try:
        if not _UIImpact: return
        _UIImpact.alloc().initWithStyle_(0).impactOccurred()
    except Exception:
        pass

# -------------------------
# Paths
# -------------------------
DATA_PATH = Path(os.path.expanduser('~/Documents')) / 'todo_data.json'
CATS_PATH = Path(os.path.expanduser('~/Documents')) / 'todo_categories.json'
SETTINGS_PATH = Path(os.path.expanduser('~/Documents')) / 'todo_settings.json'

# Sort mode constants
SORT_MODE_MANUAL   = 'manual'
SORT_MODE_DUE_DATE = 'due_date'
SORT_MODE_CATEGORY = 'category'
SORT_MODE_TITLE    = 'title'
SORT_MODE_CREATED  = 'created_at'
SORT_MODE_STATUS   = 'status'

# -------------------------
# Palette + helpers  (White REMOVED)
# -------------------------
_PALETTE = [
    ('Red',    '#FF3B30'),
    ('Orange', '#FF9500'),
    ('Yellow', '#FFCC00'),
    ('Green',  '#34C759'),
    ('Teal',   '#30B0C7'),
    ('Blue',   '#007AFF'),
    ('Purple', '#AF52DE'),
    ('Pink',   '#FF2D55'),
    ('Gray',   '#8E8E93'),
]

HEX_RE = re.compile(r'^\s*#?([0-9a-fA-F]{6})\s*$')

def hex_to_rgb(hex_str):
    m = HEX_RE.match(str(hex_str or ''))
    if not m:
        raise ValueError('Invalid hex')
    h = m.group(1)
    return tuple(int(h[i:i+2], 16) for i in (0, 2, 4))

def hex_to_ui_color(hex_str):
    r, g, b = hex_to_rgb(hex_str)
    return (r/255.0, g/255.0, b/255.0)
    
def style_colour_label(label, hx):
    """
    Apply text styling for a category/colour label.

    - Normal colours use the hex colour for the text.
    - Pure black uses black text with a thin white border so it is visible.
    """
    try:
        hx_norm = (hx or '').strip().lower()
        if hx_norm == '#000000':
            # Black text on black background needs help
            label.text_color = 'black'
            label.background_color = 'black'
            label.border_width = 1
            label.border_color = (1.0, 1.0, 1.0, 0.8)
            try:
                label.corner_radius = 4
            except Exception:
                pass
        else:
            label.text_color = hex_to_ui_color(hx)
            label.border_width = 0
            # Keep background transparent for non black
            # so it blends with the existing theme
    except Exception:
        label.text_color = (0.85, 0.85, 0.9)

def best_text_color_for_bg(hex_str):
    r, g, b = hex_to_rgb(hex_str)
    luminance = 0.2126*r + 0.7152*g + 0.0722*b
    return 'black' if luminance > 140 else 'white'

def set_textfield_rounded(tf):
    try:
        bs = getattr(ui, 'TEXT_FIELD_ROUNDED', None)
        tf.border_style = bs if isinstance(bs, int) else 3
    except Exception:
        pass

# -------------------------
# ISO timestamp helpers + pretty labels
# -------------------------
ISO_RE = re.compile(r'^\s*(\d{4})-(\d{2})-(\d{2})[T ](\d{2}):(\d{2})(?::(\d{2}))?\s*$')

def parse_iso_or_now(s):
    if not s:
        return datetime.now()
    m = ISO_RE.match(s)
    if not m:
        return datetime.now()
    y, mo, d, h, mi, ss = m.groups()
    return datetime(int(y), int(mo), int(d), int(h), int(mi), int(ss or 0))

def to_iso_seconds(dt):
    return dt.strftime('%Y-%m-%dT%H:%M:%S')

def _fmt_dt_for_label(iso_str):
    if not (iso_str or '').strip():
        return 'Not set'
    dt = parse_iso_or_now(iso_str)
    today = datetime.now().date()
    d = dt.date()
    if d == today:
        day = 'Today'
    elif d == today + timedelta(days=1):
        day = 'Tomorrow'
    else:
        day = dt.strftime('%a %d %b %Y')
    t = dt.strftime('%I:%M %p').lstrip('0')
    return f'{day} {t}'


# -------------------------
# Persistence
# -------------------------
def load_items():
    if DATA_PATH.exists():
        try:
            with open(DATA_PATH, 'r', encoding='utf-8') as f:
                data = json.load(f)
        except Exception:
            data = []
        items = []
        for it in data:
            if isinstance(it, dict):
                title = str(it.get('title', 'Untitled'))
                done = bool(it.get('done', False))
                color = (it.get('color') or '#8E8E93')
                try:
                    hex_to_rgb(color)
                except Exception:
                    color = '#8E8E93'
                created_at = it.get('created_at') or datetime.now().isoformat()
                due_at = it.get('due_at', '')

                # New fields for additional content
                description = str(it.get('description', '') or '')
                raw_links = it.get('links') or []
                links = []
                if isinstance(raw_links, list):
                    for l in raw_links:
                        if isinstance(l, dict):
                            label = str(l.get('label', '') or '')
                            url = str(l.get('url', '') or '')
                            if url:
                                links.append({'label': label, 'url': url})
                        elif isinstance(l, str):
                            # backwards-compatible: plain strings = urls
                            if l.strip():
                                links.append({'label': '', 'url': l.strip()})

                items.append({
                    'title': title,
                    'done': done,
                    'color': color,
                    'created_at': created_at,
                    'due_at': due_at,
                    'description': description,
                    'links': links,
                })
        return items

    # Default items if no file yet
    now = datetime.now().isoformat()
    return [
        {'title': 'Swipe left to delete', 'done': False, 'color': '#FFCC00',
         'created_at': now, 'due_at': '', 'description': '', 'links': []},
        {'title': 'Example (gray)',       'done': True,  'color': '#8E8E93',
         'created_at': now, 'due_at': '', 'description': '', 'links': []},
        {'title': 'Orange sample',        'done': False, 'color': '#FF9500',
         'created_at': now, 'due_at': '', 'description': '', 'links': []},
        {'title': 'Blue sample',          'done': False, 'color': '#007AFF',
         'created_at': now, 'due_at': '', 'description': '', 'links': []},
    ]




    
def save_items(items):
    try:
        with open(DATA_PATH, 'w', encoding='utf-8') as f:
            json.dump(items, f, indent=2, ensure_ascii=False)
    except Exception as e:
        dialogs.hud_alert(f'Could not save items: {e}', 'error', 1.2)

def load_categories():
    if CATS_PATH.exists():
        try:
            with open(CATS_PATH, 'r', encoding='utf-8') as f:
                data = json.load(f)
            cats = {}
            for k, v in (data.items() if isinstance(data, dict) else []):
                try:
                    hex_to_rgb(k)
                    cats[k] = str(v or '').strip()
                except Exception:
                    pass
            return cats
        except Exception:
            pass
    return {}

def save_categories(cats):
    try:
        with open(CATS_PATH, 'w', encoding='utf-8') as f:
            json.dump(cats, f, indent=2, ensure_ascii=False)
    except Exception as e:
        dialogs.hud_alert(f'Could not save categories: {e}', 'error', 1.2)

# -------------------------
# CATEGORY RENAME HELPER
# -------------------------
def reuse_rename_category(hex_color, categories, palette, title_prefix='Rename'):
    try:
        _ = hex_to_rgb(hex_color)
    except Exception:
        dialogs.hud_alert('Invalid colour selected.', 'error', 1.0)
        return False
    base_name = next((n for n, h in palette if h == hex_color), 'Colour')
    current_custom = (categories.get(hex_color, '') or '').strip()
    prefill = current_custom or base_name
    try:
        new_name = dialogs.input_alert(f'{title_prefix} {base_name}',
                                       'Enter category name:', prefill)
    except Exception:
        return False
    new_name = (new_name or '').strip()
    if new_name == current_custom:
        return False
    categories[hex_color] = new_name
    try:
        save_categories(categories)
    except Exception:
        dialogs.hud_alert('Could not save category.', 'error', 1.2)
        return False
    return True
    

def _open_category_rename(self, sender):
    view = CategoryRenameView(self, _PALETTE, title='Edit Categories')
    _safe_push(self.navigation_view, view)
    

# -------------------------
# Shared palette renderer (multi-select)
# -------------------------
class _PaletteDataSource(object):
    """
    Data source + delegate for the colour palette table (used by MultiColorPicker).

    palette        : list of (base_name, hex)
    categories     : dict hex -> custom name (optional)
    selected_hexes : set of hex strings currently selected
    on_toggle      : callback(new_selected_set) when a colour is toggled
    """

    def __init__(self, palette, categories, selected_hexes=None, on_toggle=None):
        # Build a stable list of (display_name, hex) for rows
        self._items = []
        categories = categories or {}
        for base_name, hx in (palette or []):
            display_name = categories.get(hx, '') or base_name
            self._items.append((display_name, hx))

        self._selected = set(selected_hexes or [])
        self._on_toggle = on_toggle

    # --- table basics ---
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._items)

    def tableview_cell_for_row(self, tv, section, row):
        name, hx = self._items[row]
        cell = ui.TableViewCell()
        cell.background_color = 'black'

        # Name label in its own colour
        cell.text_label.text = name
        cell.text_label.font = ('<System>', 15)
        try:
            cell.text_label.text_color = hex_to_ui_color(hx)
        except Exception:
            cell.text_label.text_color = (0.85, 0.85, 0.9)

        # Square colour chip on the right
        chip = ui.View()
        chip_size = 18
        chip.frame = (
            cell.content_view.width - chip_size - 16,
            (tv.row_height - chip_size) / 2.0,
            chip_size,
            chip_size,
        )
        chip.flex = 'L'
        chip.corner_radius = 4
        chip.border_width = 1
        chip.border_color = (0.8, 0.8, 0.85)
        try:
            chip.background_color = hex_to_ui_color(hx)
        except Exception:
            chip.background_color = 'white'
        cell.content_view.add_subview(chip)

        # Checkmark if selected
        cell.accessory_type = 'checkmark' if hx in self._selected else 'none'
        return cell

    def tableview_did_select(self, tv, section, row):
        name, hx = self._items[row]

        # Toggle selection
        if hx in self._selected:
            self._selected.remove(hx)
        else:
            self._selected.add(hx)

        # Notify parent picker
        if callable(self._on_toggle):
            try:
                self._on_toggle(set(self._selected))
            except Exception:
                pass

        tv.reload_data()
        try:
            haptic_selection()
        except Exception:
            pass

    # Helper for parent to reset selected set after Clear
    def set_selected(self, selected_hexes):
        self._selected = set(selected_hexes or [])


# -------------------------
# Color picker (single pick)
# -------------------------
class ColorPicker(ui.View):
    """
    Simple single-colour picker.

    - One row per palette entry
    - Text is in the category colour
    - Colour chip on the right
    - Tap row to return (hex, label) and pop
    """

    def __init__(self, palette, cats, on_pick=None, title='Pick a Colour'):
        super().__init__(frame=(0, 0, 420, 520))
        self.name = title
        self.background_color = 'black'
        self.on_pick = on_pick
        self.cats = cats or {}
        self.palette = list(palette or [])

        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 48
        self.table.data_source = self
        self.table.delegate = self
        self.add_subview(self.table)

        self.left_button_items = [ui.ButtonItem(title='Cancel', action=self._cancel)]

    def layout(self):
        self.table.frame = self.bounds

    def _cancel(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _choose_and_pop(self, hexc, label):
        if callable(self.on_pick):
            try:
                self.on_pick(hexc, label)
            except Exception:
                pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    # table data source / delegate
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self.palette)

    def tableview_cell_for_row(self, tv, section, row):
        base_name, hexc = self.palette[row]
        display = self.cats.get(hexc, '') or base_name

        cell = ui.TableViewCell()
        cell.background_color = 'black'
        cell.text_label.text = display
        cell.text_label.font = ('<System>', 15)
        try:
            cell.text_label.text_color = hex_to_ui_color(hexc)
        except Exception:
            cell.text_label.text_color = (0.85, 0.85, 0.9)

        chip = ui.View()
        chip_size = 18
        chip.frame = (
            cell.content_view.width - chip_size - 16,
            (tv.row_height - chip_size) / 2.0,
            chip_size,
            chip_size,
        )
        chip.flex = 'L'
        chip.corner_radius = 4
        chip.border_width = 1
        chip.border_color = (0.8, 0.8, 0.85)
        try:
            chip.background_color = hex_to_ui_color(hexc)
        except Exception:
            chip.background_color = 'white'
        cell.content_view.add_subview(chip)

        return cell

    def tableview_did_select(self, tv, section, row):
        base_name, hexc = self.palette[row]
        label = self.cats.get(hexc, '') or base_name
        self._choose_and_pop(hexc, label)


# -------------------------
# Multi Color picker (uses _PaletteDataSource)
# -------------------------
# -------------------------
# Multi Color picker (uses _PaletteDataSource)-------------------------
class MultiColorPicker(ui.View):
    """
    Simple colour / category picker screen.

    palette        : list of (base_name, hex)
    categories     : dict hex -> custom name (optional)
    selected_hexes : set of selected hex strings
    on_apply       : callback(selected_hexes_set)
    title          : nav title
    """

    def __init__(self, palette, categories, selected_hexes=None, on_apply=None, title='Pick Colours'):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = title
        self.background_color = 'black'

        # Data
        self.palette = list(palette or [])
        self.categories = categories or {}
        self.selected_hexes = set(selected_hexes or [])
        self.on_apply = on_apply

        # Only right-side buttons: Clear + Save
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        # Table
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 48
        self.add_subview(self.table)

        # Data source that will keep self.selected_hexes in sync
        def _on_toggle(new_selected):
            self.selected_hexes = set(new_selected)

        self.ds = _PaletteDataSource(
            self.palette,
            self.categories,
            self.selected_hexes,
            on_toggle=_on_toggle
        )
        self.table.data_source = self.ds
        self.table.delegate = self.ds
        self.table.reload_data()

    def layout(self):
        self.table.frame = self.bounds

    # --- actions ---

    def _clear(self, sender):
        self.selected_hexes.clear()
        if hasattr(self, 'ds') and self.ds:
            self.ds.set_selected(self.selected_hexes)
        if hasattr(self, 'table') and self.table:
            self.table.reload_data()
        try:
            haptic_selection()
        except Exception:
            pass

    def _save(self, sender):
        # Apply selection
        if callable(self.on_apply):
            try:
                self.on_apply(set(self.selected_hexes))
            except Exception:
                pass

        try:
            haptic_success()
        except Exception:
            pass

        # Close picker – let NavigationView handle back
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()
            
# -------------------------
# Category rename data source + view
# -------------------------
class _CategoryRenameDataSource(object):
    """
    Data source + delegate for the CategoryRenameView.

    palette    : list of (base_name, hex)
    categories : dict hex -> custom name (optional)
    on_tap     : callback(row_index) when a row is tapped
    """

    def __init__(self, palette, categories, on_tap):
        self._items = []
        categories = categories or {}
        for base_name, hx in (palette or []):
            display_name = categories.get(hx, '') or base_name
            self._items.append((display_name, base_name, hx))

        self.on_tap = on_tap
        self.selected_index = None

    # --- table basics ---
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._items)

    def tableview_cell_for_row(self, tv, section, row):
        display_name, base_name, hx = self._items[row]

        cell = ui.TableViewCell()
        cell.background_color = 'black'

        # Full row is the hit box, no accessory / checkmark
        cell.text_label.text = display_name
        cell.text_label.font = ('<System>', 16)
        try:
            cell.text_label.text_color = hex_to_ui_color(hx)
        except Exception:
            cell.text_label.text_color = (0.85, 0.85, 0.9)

        # Subtle selected highlight
        if row == self.selected_index:
            cell.background_color = (0.20, 0.20, 0.24)
        else:
            cell.background_color = 'black'

        # Remove any reuse artefacts
        cell.accessory_type = 'none'
        return cell

    def tableview_did_select(self, tv, section, row):
        self.selected_index = row
        tv.reload_data()

        if callable(self.on_tap):
            try:
                self.on_tap(row)
            except Exception:
                pass

        try:
            haptic_selection()
        except Exception:
            pass


class CategoryRenameView(ui.View):
    """
    Category management screen for RENAMING categories.

    - Shows one row per colour / category (like MultiColorPicker)
    - Text is in the category colour
    - No checkmarks and no colour chip
    - Tap anywhere on a row to select it
    - Bottom button opens Rename / Clear / Cancel actions

    Usage example from your main view:
        view = CategoryRenameView(self, _PALETTE, title='Edit Categories')
        _safe_push(self.navigation_view, view)
    """

    def __init__(self, owner, palette, title='Edit Categories'):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = title
        self.background_color = 'black'

        self.owner = owner
        self.palette = list(palette or [])
        # This is your shared mapping hex -> custom name
        self.categories = getattr(owner, 'categories', {}) or {}
        self.selected_index = None  # which row is "active" for rename

        # Nav bar: simple Back only (no Save/Cancel here; edits apply instantly)
        self.left_button_items = [
            ui.ButtonItem(title='Back', action=self._back)
        ]

        # Table of categories
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 48
        self.add_subview(self.table)

        # Data source / delegate to draw rows and handle taps
        def _row_tapped(row_index):
            self._on_row_selected(row_index)

        self.ds = _CategoryRenameDataSource(
            self.palette,
            self.categories,
            on_tap=_row_tapped
        )
        self.table.data_source = self.ds
        self.table.delegate = self.ds

        # Bottom action button: Rename / Clear / Cancel
        self.action_btn = ui.Button(title='Rename / Clear / Cancel')
        self.action_btn.corner_radius = 10
        self.action_btn.border_width = 1
        try:
            self.action_btn.border_color = hex_to_ui_color('#D4AF37')
            self.action_btn.background_color = hex_to_ui_color('#D4AF37')
        except Exception:
            self.action_btn.border_color = (0.90, 0.80, 0.45)
            self.action_btn.background_color = (0.90, 0.80, 0.45)
        self.action_btn.tint_color = 'black'
        self.action_btn.font = ('<System-Bold>', 16)
        self.action_btn.enabled = False  # enabled once a row is tapped
        self.action_btn.action = self._action_pressed
        self.add_subview(self.action_btn)

    def layout(self):
        # Layout table + bottom button
        margin = 16
        btn_h = 48

        self.action_btn.width = self.width - 2 * margin
        self.action_btn.x = margin
        self.action_btn.y = self.height - btn_h - margin

        self.table.frame = (0, 0, self.width, self.action_btn.y - margin)

    # --- selection handling ---
    def _on_row_selected(self, row_index):
        self.selected_index = row_index
        self.ds.selected_index = row_index
        self.table.reload_data()
        self.action_btn.enabled = True

    # --- button: Rename / Clear / Cancel ---
    def _action_pressed(self, sender):
        if self.selected_index is None:
            dialogs.hud_alert('Select a category first.', 'warning', 0.7)
            return

        display_name, base_name, hx = self.ds._items[self.selected_index]

        # Primary action sheet: Rename / Clear / Cancel
        choice = dialogs.alert(
            'Edit category',
            f'Category: {display_name}',
            'Rename',
            'Clear name',
            'Cancel',
            hide_cancel_button=True
        )

        # choice: 1=Rename, 2=Clear name, 3=Cancel
        if choice == 1:
            self._rename_category(base_name, hx, display_name)
        elif choice == 2:
            self._clear_category_name(base_name, hx, display_name)
        else:
            # Cancel, do nothing
            try:
                haptic_selection()
            except Exception:
                pass

    def _rename_category(self, base_name, hx, current_display):
        # Prompt for new name; use current display as default text
        try:
            new_name = dialogs.input_alert(
                'Rename category',
                'Enter a new category name:',
                current_display
            )
        except KeyboardInterrupt:
            # User cancelled out of dialog
            return
        except Exception:
            new_name = None

        if not new_name:
            return

        new_name = new_name.strip()
        if not new_name:
            return

        # Save into categories dict
        self.categories[hx] = new_name
        self._after_edit()

    def _clear_category_name(self, base_name, hx, current_display):
        # Remove custom label, back to base name
        if hx in self.categories:
            del self.categories[hx]
        self._after_edit()

    def _after_edit(self):
        # Rebuild items for table
        self.ds = _CategoryRenameDataSource(
            self.palette,
            self.categories,
            on_tap=self._on_row_selected
        )
        self.table.data_source = self.ds
        self.table.delegate = self.ds
        self.table.reload_data()

        # Keep same index highlighted if still valid
        if self.selected_index is not None and self.selected_index < len(self.ds._items):
            self.ds.selected_index = self.selected_index
        else:
            self.selected_index = None
            self.action_btn.enabled = False

        # Try to persist + refresh owner views
        try:
            # If you have a dedicated categories-save method, it will be called here.
            if hasattr(self.owner, '_save_categories'):
                self.owner._save_categories()
        except Exception:
            pass

        try:
            if hasattr(self.owner, 'ds') and hasattr(self.owner.ds, 'refresh'):
                self.owner.ds.refresh()
            if hasattr(self.owner, 'table') and self.owner.table:
                self.owner.table.reload_data()
            if hasattr(self.owner, '_rebuild_filter_summary'):
                self.owner._rebuild_filter_summary()
        except Exception:
            pass

        try:
            haptic_success()
        except Exception:
            pass

    # --- nav back ---
    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()


# =========================================================
# NEW: Date/Time Picker (dark, with month/year popup)
# =========================================================
def _round_minutes(minute, step):
    return int(round(minute / float(step)) * step) % 60

def _start_of_week(d):  # Monday as start
    return d - timedelta(days=d.weekday())

def _days_for_month_grid(year, month):
    first = date(year, month, 1)
    start = _start_of_week(first)  # Monday
    grid = [start + timedelta(days=i) for i in range(42)]
    return grid


class DateTimePicker(ui.View):
    """
    Theme matched picker that returns:
      - ISO string (e.g. '2025-02-19T17:00:00') on Save
      - '' on Clear (if allow_clear)
      - None on Cancel

    Args:
      title        : Nav title
      initial_iso  : Initial ISO datetime string or ''
      allow_clear  : Show Clear button that returns ''
      min_iso      : Optional minimum ISO (dates before disabled)
      mode         : 'datetime' or 'date'
                     - 'datetime'  -> calendar + time selector
                     - 'date'      -> calendar only, no time UI
      minute_step  : Time selection step size (for datetime mode)
      on_result    : Callback(result)

    Use by pushing into a NavigationView, or present() directly.
    """

    class _ListDataSource(object):
        """
        Simple list data source for month/year popup.

        values      : list of items
        on_select   : callback(value)
        format_func : optional function(value) -> string
                      used to show month names instead of numbers
        """
        def __init__(self, values, on_select, format_func=None):
            self.values = list(values or [])
            self.on_select = on_select
            self.format_func = format_func
            self.selected_value = None

        def tableview_number_of_sections(self, tv):
            return 1

        def tableview_number_of_rows(self, tv, section):
            return len(self.values)

        def tableview_cell_for_row(self, tv, section, row):
            v = self.values[row]
            text = self.format_func(v) if self.format_func else str(v)
            cell = ui.TableViewCell()
            cell.background_color = (0.10, 0.10, 0.12)
            cell.text_label.text = text
            cell.text_label.alignment = ui.ALIGN_CENTER
            cell.text_label.font = ('<System>', 16)
            cell.text_label.text_color = 'white'
            if self.selected_value is not None and v == self.selected_value:
                cell.background_color = (0.24, 0.20, 0.10)
            return cell

        def tableview_did_select(self, tv, section, row):
            value = self.values[row]
            self.selected_value = value
            if callable(self.on_select):
                self.on_select(value)
            tv.reload_data()

    def __init__(self,
                 title='Select date/time',
                 initial_iso='',
                 allow_clear=True,
                 min_iso=None,
                 mode='datetime',
                 minute_step=5,
                 on_result=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.background_color = 'black'
        self.name = title

        self.allow_clear = allow_clear
        self.on_result = on_result
        self.mode = mode if mode in ('date', 'datetime') else 'datetime'
        self.minute_step = max(1, int(minute_step or 1))

        # Parse dates using helpers
        base_dt = parse_iso_or_now(initial_iso)
        base_dt = base_dt.replace(second=0, microsecond=0)
        # Snap minutes to step
        base_dt = base_dt.replace(minute=_round_minutes(base_dt.minute, self.minute_step))

        self.selected_dt = base_dt
        self.view_year = base_dt.year
        self.view_month = base_dt.month

        self.min_dt = None
        if min_iso:
            try:
                self.min_dt = parse_iso_or_now(min_iso)
            except Exception:
                self.min_dt = None

        # Month/year popup state
        self.month_year_popup = None
        self.month_table = None
        self.year_table = None
        self.month_ds = None
        self.year_ds = None

        # Navigation bar buttons
        left_items = [ui.ButtonItem(title='Cancel', action=self._cancel)]
        right_items = []
        if self.allow_clear:
            right_items.append(ui.ButtonItem(title='Clear', action=self._clear))
        right_items.append(ui.ButtonItem(title='Save', action=self._save))
        self.left_button_items = left_items
        self.right_button_items = right_items

        # Header: month/year navigation
        y = 0
        self.header = ui.View(frame=(0, y, self.width, 52), flex='W')
        self.header.background_color = (0.12, 0.12, 0.14)
        self.add_subview(self.header)

        # Year navigation buttons (double arrows)
        self.prev_year_btn = ui.Button(frame=(8, 10, 36, 32))
        self.prev_year_btn.title = '≪'
        self.prev_year_btn.tint_color = 'white'
        self.prev_year_btn.background_color = (0.18, 0.18, 0.2)
        self.prev_year_btn.corner_radius = 8
        self.prev_year_btn.action = self._prev_year
        self.header.add_subview(self.prev_year_btn)

        self.next_year_btn = ui.Button(frame=(self.width - 44, 10, 36, 32), flex='L')
        self.next_year_btn.title = '≫'
        self.next_year_btn.tint_color = 'white'
        self.next_year_btn.background_color = (0.18, 0.18, 0.2)
        self.next_year_btn.corner_radius = 8
        self.next_year_btn.action = self._next_year
        self.header.add_subview(self.next_year_btn)

        # Month navigation buttons (single arrows)
        self.prev_month_btn = ui.Button(frame=(0, 10, 32, 32))
        self.prev_month_btn.title = '◀︎'
        self.prev_month_btn.tint_color = 'white'
        self.prev_month_btn.background_color = (0.18, 0.18, 0.2)
        self.prev_month_btn.corner_radius = 8
        self.prev_month_btn.action = self._prev_month
        self.header.add_subview(self.prev_month_btn)

        self.next_month_btn = ui.Button(frame=(0, 10, 32, 32))
        self.next_month_btn.title = '▶︎'
        self.next_month_btn.tint_color = 'white'
        self.next_month_btn.background_color = (0.18, 0.18, 0.2)
        self.next_month_btn.corner_radius = 8
        self.next_month_btn.action = self._next_month
        self.header.add_subview(self.next_month_btn)

        # Position header buttons
        self._layout_header_buttons()

        # Month-year button in the centre (tappable to open popup)
        self.month_btn = ui.Button(frame=(0, 10, self.width, 32), flex='W')
        self.month_btn.background_color = (0, 0, 0, 0)
        self.month_btn.tint_color = 'white'
        self.month_btn.font = ('<System-Bold>', 17)
        self.month_btn.action = self._toggle_month_year_popup
        self.header.add_subview(self.month_btn)

        y += self.header.height

        # Weekday row
        self.weekdays_view = ui.View(frame=(0, y, self.width, 22), flex='W')
        self.add_subview(self.weekdays_view)
        y += self.weekdays_view.height

        # Calendar grid
        self.calendar_view = ui.View(frame=(0, y, self.width, 6 * 40), flex='W')
        self.add_subview(self.calendar_view)
        y += self.calendar_view.height + 8

        # Selected summary label
        self.summary_lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        self.summary_lbl.text_color = (0.85, 0.85, 0.9)
        self.summary_lbl.font = ('<System>', 14)
        self.summary_lbl.alignment = ui.ALIGN_CENTER
        self.add_subview(self.summary_lbl)
        y += 32

        # Time button (only for datetime mode)
        self.time_btn = ui.Button(frame=(16, y, self.width - 32, 44), flex='W')
        self.time_btn.corner_radius = 8
        self.time_btn.border_width = 1
        self.time_btn.border_color = (0.55, 0.55, 0.65)
        self.time_btn.background_color = (0.17, 0.17, 0.19)
        self.time_btn.tint_color = 'white'
        self.time_btn.font = ('<System>', 15)
        self.time_btn.action = self._pick_time
        self.add_subview(self.time_btn)

        if self.mode == 'date':
            # Hide the time UI entirely for date-only mode
            self.time_btn.hidden = True

        # Build weekdays and day buttons
        self._build_weekdays()
        self._build_day_buttons()
        self._refresh_month()
        self._refresh_selected_label()
        self._refresh_time_label()

    def layout(self):
        # Keep header and calendar stretched on rotation
        self.header.width = self.width
        self._layout_header_buttons()
        self.month_btn.width = self.width

        self.weekdays_view.width = self.width
        self.calendar_view.width = self.width

        self.summary_lbl.width = self.width - 32
        self.time_btn.width = self.width - 32

    def _layout_header_buttons(self):
        # Place year buttons at extreme left/right, month buttons inside them
        self.prev_year_btn.x = 8
        self.next_year_btn.x = self.width - self.next_year_btn.width - 8

        self.prev_month_btn.x = self.prev_year_btn.x + self.prev_year_btn.width + 4
        self.next_month_btn.x = self.next_year_btn.x - self.next_month_btn.width - 4

    # ---------------- Calendar UI helpers ----------------
    def _build_weekdays(self):
        for sv in list(self.weekdays_view.subviews):
            self.weekdays_view.remove_subview(sv)

        labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
        w = self.width / 7.0
        for i, text in enumerate(labels):
            lbl = ui.Label(frame=(i * w, 0, w, self.weekdays_view.height), flex='W')
            lbl.text = text
            lbl.font = ('<System>', 12)
            lbl.alignment = ui.ALIGN_CENTER
            lbl.text_color = (0.7, 0.7, 0.75)
            self.weekdays_view.add_subview(lbl)

    def _build_day_buttons(self):
        self.day_buttons = []
        for sv in list(self.calendar_view.subviews):
            self.calendar_view.remove_subview(sv)

        rows = 6
        cols = 7
        cell_w = self.width / cols
        cell_h = 40

        for r in range(rows):
            for c in range(cols):
                idx = r * cols + c
                b = ui.Button()
                b.frame = (c * cell_w, r * cell_h, cell_w, cell_h)
                b.font = ('<System>', 14)
                b.background_color = 'black'
                b.tint_color = 'white'
                b.border_width = 0
                b.action = self._day_tapped
                b.tag = idx  # index
                self.calendar_view.add_subview(b)
                self.day_buttons.append(b)

    def _refresh_month(self):
        # Title
        dt = datetime(self.view_year, self.view_month, 1)
        month_name = dt.strftime('%B')
        self.month_btn.title = f'{month_name} {self.view_year} ▾'

        # Prepare data for days
        grid_dates = _days_for_month_grid(self.view_year, self.view_month)

        # Clear / refill
        today = datetime.now().date()
        selected_date = self.selected_dt.date()

        for btn, d in zip(self.day_buttons, grid_dates):
            btn.enabled = True
            btn.title = str(d.day)
            btn.date_value = datetime(d.year, d.month, d.day,
                                      self.selected_dt.hour,
                                      self.selected_dt.minute)

            in_month = (d.month == self.view_month)

            # Min date restriction
            if self.min_dt and btn.date_value.date() < self.min_dt.date():
                btn.enabled = False
                btn.tint_color = (0.4, 0.4, 0.45)
            else:
                btn.tint_color = 'white'

            # Base style
            if not in_month:
                btn.alpha = 0.35
            else:
                btn.alpha = 1.0

            # Selected / today styles
            if d == selected_date:
                btn.background_color = (0.25, 0.25, 0.28)
                try:
                    btn.border_color = hex_to_ui_color('#D4AF37')
                except Exception:
                    btn.border_color = (0.9, 0.8, 0.4)
                btn.border_width = 1
            else:
                btn.background_color = 'black'
                # Ring today if not selected
                if d == today:
                    btn.border_width = 1
                    try:
                        btn.border_color = hex_to_ui_color('#D4AF37')
                    except Exception:
                        btn.border_color = (0.9, 0.8, 0.4)
                else:
                    btn.border_width = 0

    def _day_tapped(self, sender):
        if not getattr(sender, 'enabled', False):
            return
        d = getattr(sender, 'date_value', None)
        if not d:
            return
        # Preserve time
        self.selected_dt = self.selected_dt.replace(
            year=d.year, month=d.month, day=d.day
        )
        self.view_year = d.year
        self.view_month = d.month
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    def _prev_month(self, sender):
        y, m = self.view_year, self.view_month
        m -= 1
        if m < 1:
            m = 12
            y -= 1
        self.view_year, self.view_month = y, m
        self._refresh_month()
        try:
            haptic_selection()
        except Exception:
            pass

    def _next_month(self, sender):
        y, m = self.view_year, self.view_month
        m += 1
        if m > 12:
            m = 1
            y += 1
        self.view_year, self.view_month = y, m
        self._refresh_month()
        try:
            haptic_selection()
        except Exception:
            pass

    def _prev_year(self, sender):
        self.view_year -= 1
        self._refresh_month()
        try:
            haptic_selection()
        except Exception:
            pass

    def _next_year(self, sender):
        self.view_year += 1
        self._refresh_month()
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------------- Month/year popup ----------------
    def _toggle_month_year_popup(self, sender):
        if self.month_year_popup is not None:
            self._hide_month_year_popup()
        else:
            self._show_month_year_popup()

    def _show_month_year_popup(self):
        if self.month_year_popup is not None:
            return

        header_frame = self.header.frame
        popup_height = 260
        popup_width = self.width - 32
        x = 16
        y = header_frame.y + header_frame.height

        popup = ui.View(frame=(x, y, popup_width, popup_height))
        popup.background_color = (0.10, 0.10, 0.12)
        popup.corner_radius = 12
        popup.border_width = 1
        try:
            popup.border_color = hex_to_ui_color('#D4AF37')
        except Exception:
            popup.border_color = (0.9, 0.8, 0.4)
        popup.alpha = 0.0
        self.add_subview(popup)

        # Inner layout: two columns Month / Year
        padding = 8
        col_width = (popup_width - padding * 3) / 2.0
        label_h = 20
        list_top = padding + label_h + 4
        list_h = popup_height - list_top - padding

        # Month label
        month_label = ui.Label(frame=(padding, padding, col_width, label_h))
        month_label.text = 'Month'
        month_label.font = ('<System>', 13)
        month_label.text_color = 'white'
        month_label.alignment = ui.ALIGN_CENTER
        popup.add_subview(month_label)

        # Year label
        year_label = ui.Label(frame=(padding * 2 + col_width, padding, col_width, label_h))
        year_label.text = 'Year'
        year_label.font = ('<System>', 13)
        year_label.text_color = 'white'
        year_label.alignment = ui.ALIGN_CENTER
        popup.add_subview(year_label)

        # Month values 1..12
        months = list(range(1, 13))
        # Year values around current
        current_year = self.view_year
        years = list(range(current_year - 10, current_year + 11))

        def on_month_select(m):
            # Keep current year, update month
            self.view_month = int(m)
            self._refresh_month()
            self._refresh_selected_label()

        def on_year_select(y_val):
            self.view_year = int(y_val)
            self._refresh_month()
            self._refresh_selected_label()

        self.month_ds = DateTimePicker._ListDataSource(
            months,
            on_select=on_month_select,
            format_func=lambda m: calendar.month_name[m]
        )
        self.year_ds = DateTimePicker._ListDataSource(
            years,
            on_select=on_year_select,
            format_func=lambda y_val: str(y_val)
        )
        self.month_ds.selected_value = self.view_month
        self.year_ds.selected_value = self.view_year

        # Month table
        self.month_table = ui.TableView(frame=(padding, list_top, col_width, list_h))
        self.month_table.row_height = 30
        self.month_table.data_source = self.month_ds
        self.month_table.delegate = self.month_ds
        self.month_table.background_color = (0.10, 0.10, 0.12)
        self.month_table.separator_color = (0.20, 0.20, 0.22)
        popup.add_subview(self.month_table)

        # Year table
        self.year_table = ui.TableView(frame=(padding * 2 + col_width, list_top, col_width, list_h))
        self.year_table.row_height = 30
        self.year_table.data_source = self.year_ds
        self.year_table.delegate = self.year_ds
        self.year_table.background_color = (0.10, 0.10, 0.12)
        self.year_table.separator_color = (0.20, 0.20, 0.22)
        popup.add_subview(self.year_table)

        # Scroll roughly to current values
        def _scroll_to_current():
            try:
                m_index = months.index(self.view_month)
            except ValueError:
                m_index = 0
            try:
                y_index = years.index(self.view_year)
            except ValueError:
                y_index = 0

            self.month_table.content_offset = (
                0,
                max(0, m_index * self.month_table.row_height - self.month_table.height / 2),
            )
            self.year_table.content_offset = (
                0,
                max(0, y_index * self.year_table.row_height - self.year_table.height / 2),
            )

        ui.delay(_scroll_to_current, 0.01)

        self.month_year_popup = popup

        def anim():
            popup.alpha = 1.0
        ui.animate(anim, duration=0.2)
        try:
            haptic_selection()
        except Exception:
            pass

    def _hide_month_year_popup(self):
        if self.month_year_popup is None:
            return
        popup = self.month_year_popup

        def anim():
            popup.alpha = 0.0

        def cleanup():
            if popup.superview is not None:
                popup.superview.remove_subview(popup)
            self.month_year_popup = None
            self.month_table = None
            self.year_table = None
            self.month_ds = None
            self.year_ds = None

        ui.animate(anim, duration=0.2, completion=cleanup)
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------------- Time selection ----------------
    def _refresh_time_label(self):
        if self.mode == 'date':
            # No time UI in date mode
            self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y')
            return

        t_str = self.selected_dt.strftime('%I:%M %p').lstrip('0')
        self.time_btn.title = f'Time: {t_str}'
        self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y ') + t_str

    def _pick_time(self, sender):
        if self.mode == 'date':
            return  # safety

        # Simple time picker using dialogs.form_dialog
        h = self.selected_dt.hour
        m = self.selected_dt.minute
        am_pm = 'AM'
        if h >= 12:
            am_pm = 'PM'
        h12 = h % 12
        if h12 == 0:
            h12 = 12

        form_fields = [
            {'title': 'Hour', 'type': 'number', 'value': str(h12)},
            {'title': 'Minute', 'type': 'number', 'value': str(m)},
            {'title': 'AM/PM', 'type': 'segmented',
             'segments': ['AM', 'PM'], 'value': am_pm},
        ]
        res = dialogs.form_dialog(title='Select time', fields=form_fields)
        if not res:
            return

        try:
            new_h = int(res.get('Hour', h12))
        except Exception:
            new_h = h12
        try:
            new_m = int(res.get('Minute', m))
        except Exception:
            new_m = m
        new_am_pm = res.get('AM/PM', am_pm) or am_pm

        # Clamp values
        new_h = max(1, min(12, new_h))
        new_m = max(0, min(59, new_m))

        # Snap to minute_step
        step = self.minute_step
        new_m = int(round(new_m / float(step))) * step
        if new_m >= 60:
            new_m = 60 - step

        # Convert back to 24h
        if new_am_pm == 'AM':
            if new_h == 12:
                new_h = 0
        else:
            if new_h != 12:
                new_h += 12

        self.selected_dt = self.selected_dt.replace(hour=new_h, minute=new_m)
        self._refresh_time_label()
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------------- Summary label ----------------
    def _refresh_selected_label(self):
        if self.mode == 'date':
            self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y')
        else:
            self._refresh_time_label()

    # ---------------- Save / Clear / Cancel ----------------
    def _final_result(self, value):
        if callable(self.on_result):
            try:
                self.on_result(value)
            except Exception:
                pass

    def _save(self, sender):
        # Convert to ISO using helper
        iso_value = to_iso_seconds(self.selected_dt)
        self._final_result(iso_value)
        try:
            haptic_success()
        except Exception:
            pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _clear(self, sender):
        if not self.allow_clear:
            return
        self._final_result('')
        try:
            haptic_selection()
        except Exception:
            pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _cancel(self, sender):
        self._final_result(None)
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()
            
        def __init__(self, values, on_select, format_func=None):
            self.values = values
            self.on_select = on_select
            self.format_func = format_func
            self.selected_value = None

        def tableview_number_of_sections(self, tv):
            return 1

        def tableview_number_of_rows(self, tv, section):
            return len(self.values)

        def tableview_cell_for_row(self, tv, section, row):
            cell = ui.TableViewCell()
            v = self.values[row]
            if self.format_func:
                text = self.format_func(v)
            else:
                text = str(v)
            cell.text_label.text = text
            cell.text_label.alignment = ui.ALIGN_CENTER
            cell.text_label.font = ('<System>', 16)
            cell.background_color = (0.10, 0.10, 0.12)
            cell.text_label.text_color = 'white'
            if self.selected_value == v:
                cell.background_color = (0.24, 0.24, 0.28)
            return cell

        def tableview_did_select(self, tv, section, row):
            v = self.values[row]
            self.selected_value = v
            if callable(self.on_select):
                self.on_select(v)
            tv.reload_data()

    def __init__(self,
                 title='Select date/time',
                 initial_iso='',
                 allow_clear=True,
                 min_iso=None,
                 mode='datetime',
                 minute_step=5,
                 on_result=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.background_color = 'black'
        self.name = title

        self.allow_clear = allow_clear
        self.on_result = on_result
        self.mode = mode if mode in ('date', 'datetime') else 'datetime'
        self.minute_step = max(1, int(minute_step or 1))

        # Parse dates using your existing helpers
        base_dt = parse_iso_or_now(initial_iso)
        base_dt = base_dt.replace(second=0, microsecond=0)

        self.selected_dt = base_dt
        self.view_year = base_dt.year
        self.view_month = base_dt.month

        self.min_dt = None
        if min_iso:
            try:
                self.min_dt = parse_iso_or_now(min_iso)
            except Exception:
                self.min_dt = None

        # Month/year popup state
        self.monthyear_popup = None
        self.month_table = None
        self.year_table = None
        self.month_ds = None
        self.year_ds = None

        # Navigation bar buttons
        # Left: Cancel; Save/Clear are bottom buttons
        self.left_button_items = [ui.ButtonItem(title='Cancel', action=self._cancel)]
        self.right_button_items = []

        # Header: month + year navigation
        y = 0
        self.header = ui.View(frame=(0, y, self.width, 56), flex='W')
        self.header.background_color = (0.12, 0.12, 0.14)
        self.add_subview(self.header)

        # Year step buttons (double arrows)
        self.prev_year_btn = ui.Button(frame=(8, 10, 32, 36))
        self.prev_year_btn.title = '≪'
        self.prev_year_btn.tint_color = 'white'
        self.prev_year_btn.background_color = (0.18, 0.18, 0.2)
        self.prev_year_btn.corner_radius = 9
        self.prev_year_btn.font = ('<System-Bold>', 18)
        self.prev_year_btn.action = self._prev_year
        self.header.add_subview(self.prev_year_btn)

        self.next_year_btn = ui.Button(frame=(self.width - 40, 10, 32, 36), flex='L')
        self.next_year_btn.title = '≫'
        self.next_year_btn.tint_color = 'white'
        self.next_year_btn.background_color = (0.18, 0.18, 0.2)
        self.next_year_btn.corner_radius = 9
        self.next_year_btn.font = ('<System-Bold>', 18)
        self.next_year_btn.action = self._next_year
        self.header.add_subview(self.next_year_btn)

        # Month step buttons (single arrows)
        self.prev_btn = ui.Button(frame=(0, 10, 32, 36))
        self.prev_btn.title = '<'
        self.prev_btn.tint_color = 'white'
        self.prev_btn.background_color = (0.18, 0.18, 0.2)
        self.prev_btn.corner_radius = 9
        self.prev_btn.font = ('<System-Bold>', 18)
        self.prev_btn.action = self._prev_month
        self.header.add_subview(self.prev_btn)

        self.next_btn = ui.Button(frame=(0, 10, 32, 36))
        self.next_btn.title = '>'
        self.next_btn.tint_color = 'white'
        self.next_btn.background_color = (0.18, 0.18, 0.2)
        self.next_btn.corner_radius = 9
        self.next_btn.font = ('<System-Bold>', 18)
        self.next_btn.action = self._next_month
        self.header.add_subview(self.next_btn)

        # Month-year label as a button (clickable)
        # It will be resized in _layout_header_buttons so it does not cover arrows
        self.month_lbl = ui.Button(frame=(0, 10, self.width, 36), flex='W')
        self.month_lbl.alignment = ui.ALIGN_CENTER
        self.month_lbl.tint_color = 'white'
        self.month_lbl.background_color = (0, 0, 0, 0)
        self.month_lbl.font = ('<System-Bold>', 18)
        self.month_lbl.action = self._month_label_tapped
        self.header.add_subview(self.month_lbl)

        # Position header buttons
        self._layout_header_buttons()
        y += self.header.height

        # Weekday row
        self.weekdays_view = ui.View(frame=(0, y, self.width, 24), flex='W')
        self.add_subview(self.weekdays_view)
        y += self.weekdays_view.height

        # Calendar grid
        self.calendar_view = ui.View(frame=(0, y, self.width, 6 * 44), flex='W')
        self.add_subview(self.calendar_view)
        y += self.calendar_view.height + 10

        # Selected summary label
        self.summary_lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        self.summary_lbl.text_color = (0.82, 0.82, 0.88)
        self.summary_lbl.font = ('<System>', 14)
        self.add_subview(self.summary_lbl)
        y += 32

        # Time button (only for datetime mode)
        self.time_btn = ui.Button(frame=(16, y, self.width - 32, 42), flex='W')
        self.time_btn.corner_radius = 9
        self.time_btn.border_width = 1
        self.time_btn.border_color = (0.55, 0.55, 0.65)
        self.time_btn.background_color = (0.17, 0.17, 0.19)
        self.time_btn.tint_color = 'white'
        self.time_btn.font = ('<System>', 15)
        self.time_btn.action = self._pick_time
        self.add_subview(self.time_btn)

        if self.mode == 'date':
            self.time_btn.hidden = True

        # Footer: bottom Save / Clear buttons
        y_footer = y + (0 if self.mode == 'date' else 52)
        self.footer = ui.View(frame=(0, y_footer, self.width, 60), flex='W')
        self.add_subview(self.footer)

        btn_w = (self.width - 16 * 3) / 2.0
        btn_y = 10

        self.footer_clear = ui.Button(frame=(16, btn_y, btn_w, 40))
        self.footer_clear.corner_radius = 9
        self.footer_clear.border_width = 1
        self.footer_clear.border_color = (0.55, 0.55, 0.65)
        self.footer_clear.background_color = (0.17, 0.17, 0.19)
        self.footer_clear.tint_color = 'white'
        self.footer_clear.font = ('<System-Bold>', 16)
        self.footer_clear.title = 'Clear'
        self.footer_clear.action = self._clear
        self.footer.add_subview(self.footer_clear)
        if not self.allow_clear:
            self.footer_clear.hidden = True

        self.footer_save = ui.Button(frame=(16 + btn_w + 16, btn_y, btn_w, 40))
        self.footer_save.corner_radius = 9
        self.footer_save.border_width = 1
        try:
            self.footer_save.border_color = hex_to_ui_color('#D4AF37')
            self.footer_save.background_color = hex_to_ui_color('#D4AF37')
        except Exception:
            self.footer_save.border_color = (0.9, 0.8, 0.4)
            self.footer_save.background_color = (0.9, 0.8, 0.4)
        self.footer_save.tint_color = 'black'
        self.footer_save.font = ('<System-Bold>', 16)
        self.footer_save.title = 'Save'
        self.footer_save.action = self._save
        self.footer.add_subview(self.footer_save)

        # Build weekdays and day buttons
        self._build_weekdays()
        self._build_day_buttons()
        self._refresh_month()
        self._refresh_selected_label()
        self._refresh_time_label()

    def _layout_header_buttons(self):
        # Left cluster: year back then month back
        self.prev_year_btn.x = 8
        self.prev_btn.x = self.prev_year_btn.x + self.prev_year_btn.width + 4

        # Right cluster: month forward then year forward
        self.next_year_btn.x = self.header.width - 8 - self.next_year_btn.width
        self.next_btn.x = self.next_year_btn.x - 4 - self.next_btn.width

        # Month label between left and right arrow clusters
        left_edge = self.prev_btn.x + self.prev_btn.width + 8
        right_edge = self.next_btn.x - 8
        self.month_lbl.frame = (left_edge,
                                self.month_lbl.y,
                                max(60, right_edge - left_edge),
                                self.month_lbl.height)

    def layout(self):
        # Keep header and calendar stretched on rotation
        self.header.width = self.width
        self._layout_header_buttons()

        self.weekdays_view.width = self.width
        self.calendar_view.width = self.width

        self.summary_lbl.width = self.width - 32
        self.time_btn.width = self.width - 32

        self.footer.width = self.width
        btn_w = (self.width - 16 * 3) / 2.0
        self.footer_clear.width = btn_w
        self.footer_save.width = btn_w
        self.footer_save.x = 16 + btn_w + 16

        # Keep popup full width if visible
        if self.monthyear_popup is not None:
            self.monthyear_popup.width = self.width
            if self.monthyear_popup.subviews:
                inner = self.monthyear_popup.subviews[0]
                inner.width = self.width - 16

    # ---------------- Calendar UI helpers ----------------
    def _build_weekdays(self):
        for sv in list(self.weekdays_view.subviews):
            self.weekdays_view.remove_subview(sv)

        labels = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
        w = self.width / 7.0
        for i, text in enumerate(labels):
            lbl = ui.Label(frame=(i * w, 0, w, self.weekdays_view.height), flex='W')
            lbl.text = text
            lbl.font = ('<System>', 13)
            lbl.alignment = ui.ALIGN_CENTER
            lbl.text_color = (0.7, 0.7, 0.75)
            self.weekdays_view.add_subview(lbl)

    def _build_day_buttons(self):
        self.day_buttons = []
        for sv in list(self.calendar_view.subviews):
            self.calendar_view.remove_subview(sv)

        rows = 6
        cols = 7
        cell_w = self.width / cols
        cell_h = 44

        for r in range(rows):
            for c in range(cols):
                idx = r * cols + c
                b = ui.Button()
                b.frame = (c * cell_w, r * cell_h, cell_w, cell_h)
                b.font = ('<System>', 16)
                b.background_color = 'black'
                b.tint_color = 'white'
                b.border_width = 0
                b.action = self._day_tapped
                b.tag = idx  # index
                self.calendar_view.add_subview(b)
                self.day_buttons.append(b)

    def _refresh_month(self):
        # Title text with double down arrows on both sides
        dt = datetime(self.view_year, self.view_month, 1)
        center_text = dt.strftime('%B %Y')
        self.month_lbl.title = f'▾ {center_text} ▾'

        # Prepare data for days
        first_weekday, num_days = monthrange(self.view_year, self.view_month)
        start_col = first_weekday  # 0..6

        # Clear all buttons first
        for b in self.day_buttons:
            b.enabled = False
            b.title = ''
            b.background_color = 'black'
            b.border_width = 0
            b.border_color = 'clear'

        # Fill buttons
        day = 1
        for d in range(num_days):
            idx = start_col + d
            if idx >= len(self.day_buttons):
                break
            b = self.day_buttons[idx]
            b.title = str(day)
            b.enabled = True
            b.date_value = datetime(self.view_year, self.view_month, day,
                                    self.selected_dt.hour,
                                    self.selected_dt.minute)

            # Min date restriction
            if self.min_dt and b.date_value.date() < self.min_dt.date():
                b.enabled = False
                b.title = str(day)
                b.tint_color = (0.4, 0.4, 0.45)
            else:
                b.tint_color = 'white'

            day += 1

        self._highlight_selected_day()

    def _highlight_selected_day(self):
        for b in self.day_buttons:
            if not getattr(b, 'enabled', False) or not b.title:
                b.border_width = 0
                b.background_color = 'black'
                continue

            d = getattr(b, 'date_value', None)
            if d and d.date() == self.selected_dt.date():
                b.background_color = (0.26, 0.26, 0.30)
                try:
                    b.border_color = hex_to_ui_color('#D4AF37')
                except Exception:
                    b.border_color = (0.9, 0.8, 0.4)
                b.border_width = 1
            else:
                b.background_color = 'black'
                b.border_width = 0

    def _day_tapped(self, sender):
        if not getattr(sender, 'enabled', False):
            return
        d = getattr(sender, 'date_value', None)
        if not d:
            return
        # Preserve time
        self.selected_dt = self.selected_dt.replace(
            year=d.year, month=d.month, day=d.day
        )
        self.view_year = d.year
        self.view_month = d.month
        self._highlight_selected_day()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    # -------- year and month navigation buttons --------
    def _prev_year(self, sender):
        y = self.view_year - 1
        m = self.view_month
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.view_year = y
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    def _next_year(self, sender):
        y = self.view_year + 1
        m = self.view_month
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.view_year = y
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    def _prev_month(self, sender):
        y, m = self.view_year, self.view_month
        m -= 1
        if m < 1:
            m = 12
            y -= 1
        self.view_year, self.view_month = y, m
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    def _next_month(self, sender):
        y, m = self.view_year, self.view_month
        m += 1
        if m > 12:
            m = 1
            y += 1
        self.view_year, self.view_month = y, m
        day = min(self.selected_dt.day, monthrange(y, m)[1])
        self.selected_dt = self.selected_dt.replace(year=y, month=m, day=day)
        self._refresh_month()
        self._refresh_selected_label()
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------------- month/year popup via label tap ----------------
    def _month_label_tapped(self, sender):
        if self.monthyear_popup is not None:
            self._hide_monthyear_popup()
        else:
            self._show_monthyear_popup()

    def _show_monthyear_popup(self):
        if self.monthyear_popup is not None:
            return

        popup_h = 220
        header_bottom = self.header.y + self.header.height

        popup = ui.View(frame=(0, header_bottom, self.width, popup_h))
        popup.background_color = (0, 0, 0, 0.7)
        popup.alpha = 0.0
        self.add_subview(popup)

        inner = ui.View(frame=(8, 8, self.width - 16, popup_h - 16))
        inner.background_color = (0.10, 0.10, 0.12)
        inner.corner_radius = 10
        popup.add_subview(inner)

        col_pad = 8
        col_w = (inner.width - col_pad * 3) / 2.0
        top_pad = 8
        label_h = 18
        list_top = top_pad + label_h + 4
        list_h = inner.height - list_top - 40

        # Labels
        month_label = ui.Label(frame=(col_pad, top_pad, col_w, label_h))
        month_label.text = 'Month'
        month_label.font = ('<System>', 12)
        month_label.text_color = 'white'
        month_label.alignment = ui.ALIGN_CENTER
        inner.add_subview(month_label)

        year_label = ui.Label(frame=(col_pad * 2 + col_w, top_pad, col_w, label_h))
        year_label.text = 'Year'
        year_label.font = ('<System>', 12)
        year_label.text_color = 'white'
        year_label.alignment = ui.ALIGN_CENTER
        inner.add_subview(year_label)

        # Values
        months = list(range(1, 13))
        current_year = self.view_year
        years = list(range(current_year - 10, current_year + 11))

        # Data sources
        def on_month_sel(val):
            day = min(self.selected_dt.day, monthrange(self.view_year, val)[1])
            self.view_month = val
            self.selected_dt = self.selected_dt.replace(year=self.view_year, month=val, day=day)
            self._refresh_month()
            self._refresh_selected_label()

        def on_year_sel(val):
            day = min(self.selected_dt.day, monthrange(val, self.view_month)[1])
            self.view_year = val
            self.selected_dt = self.selected_dt.replace(year=val, month=self.view_month, day=day)
            self._refresh_month()
            self._refresh_selected_label()

        # Month list uses names here, without needing calendar module
        MONTH_NAMES = (
            'January', 'February', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'
        )

        self.month_ds = DateTimePicker._ListDataSource(
            months,
            on_month_sel,
            format_func=lambda m, names=MONTH_NAMES: names[m - 1]
        )
        self.year_ds = DateTimePicker._ListDataSource(
            years,
            on_year_sel,
            format_func=None
        )

        # Pre select current month/year
        self.month_ds.selected_value = self.view_month
        self.year_ds.selected_value = self.view_year

        # Month table
        self.month_table = ui.TableView(frame=(col_pad, list_top, col_w, list_h))
        self.month_table.row_height = 30
        self.month_table.data_source = self.month_ds
        self.month_table.delegate = self.month_ds
        self.month_table.background_color = (0.10, 0.10, 0.12)
        self.month_table.separator_color = (0.20, 0.20, 0.22)
        inner.add_subview(self.month_table)

        # Year table
        self.year_table = ui.TableView(frame=(col_pad * 2 + col_w, list_top, col_w, list_h))
        self.year_table.row_height = 30
        self.year_table.data_source = self.year_ds
        self.year_table.delegate = self.year_ds
        self.year_table.background_color = (0.10, 0.10, 0.12)
        self.year_table.separator_color = (0.20, 0.20, 0.22)
        inner.add_subview(self.year_table)

        # Scroll current selections into view
        def _scroll_to_current():
            try:
                mi = months.index(self.view_month)
            except ValueError:
                mi = 0
            try:
                yi = years.index(self.view_year)
            except ValueError:
                yi = 0

            self.month_table.content_offset = (
                0,
                max(0, mi * self.month_table.row_height - self.month_table.height / 2),
            )
            self.year_table.content_offset = (
                0,
                max(0, yi * self.year_table.row_height - self.year_table.height / 2),
            )
        ui.delay(_scroll_to_current, 0.02)

        # Confirm button
        confirm_btn = ui.Button()
        confirm_btn.title = 'Done'
        confirm_btn.font = ('<System-Bold>', 14)
        confirm_btn.tint_color = 'black'
        try:
            confirm_btn.background_color = hex_to_ui_color('#D4AF37')
        except Exception:
            confirm_btn.background_color = (0.9, 0.8, 0.4)
        confirm_btn.corner_radius = 8
        confirm_btn.frame = (col_pad,
                             inner.height - 32,
                             inner.width - col_pad * 2,
                             26)

        def _confirm(sender):
            self._hide_monthyear_popup()

        confirm_btn.action = _confirm
        inner.add_subview(confirm_btn)

        self.monthyear_popup = popup

        def anim():
            popup.alpha = 1.0

        ui.animate(anim, duration=0.22)
        try:
            haptic_selection()
        except Exception:
            pass

    def _hide_monthyear_popup(self):
        if self.monthyear_popup is None:
            return
        popup = self.monthyear_popup

        def anim():
            popup.alpha = 0.0

        def cleanup():
            if popup.superview:
                popup.superview.remove_subview(popup)
            self.monthyear_popup = None
            self.month_table = None
            self.year_table = None
            self.month_ds = None
            self.year_ds = None

        ui.animate(anim, duration=0.18, completion=cleanup)
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------------- Time selection ----------------
    def _refresh_time_label(self):
        if self.mode == 'date':
            self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y')
            return

        t_str = self.selected_dt.strftime('%I:%M %p').lstrip('0')
        self.time_btn.title = f'Time: {t_str}'
        self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y ') + t_str

    def _pick_time(self, sender):
        if self.mode == 'date':
            return  # safety

        # Simple time picker using dialogs.form_dialog
        h = self.selected_dt.hour
        m = self.selected_dt.minute
        am_pm = 'AM'
        if h >= 12:
            am_pm = 'PM'
        h12 = h % 12
        if h12 == 0:
            h12 = 12

        form_fields = [
            {'title': 'Hour', 'type': 'number', 'value': str(h12)},
            {'title': 'Minute', 'type': 'number', 'value': str(m)},
            {'title': 'AM/PM', 'type': 'segmented',
             'segments': ['AM', 'PM'], 'value': am_pm},
        ]
        res = dialogs.form_dialog(title='Select time', fields=form_fields)
        if not res:
            return

        try:
            new_h = int(res.get('Hour', h12))
        except Exception:
            new_h = h12
        try:
            new_m = int(res.get('Minute', m))
        except Exception:
            new_m = m
        new_am_pm = res.get('AM/PM', am_pm) or am_pm

        # Clamp values
        new_h = max(1, min(12, new_h))
        new_m = max(0, min(59, new_m))

        # Snap to minute_step
        step = self.minute_step
        new_m = int(round(new_m / float(step))) * step
        if new_m >= 60:
            new_m = 60 - step

        # Convert back to 24h
        if new_am_pm == 'AM':
            if new_h == 12:
                new_h = 0
        else:
            if new_h != 12:
                new_h += 12

        self.selected_dt = self.selected_dt.replace(hour=new_h, minute=new_m)
        self._refresh_time_label()
        try:
            haptic_selection()
        except Exception:
            pass

    # ---------------- Summary label ----------------
    def _refresh_selected_label(self):
        if self.mode == 'date':
            self.summary_lbl.text = self.selected_dt.strftime('Selected: %d %b %Y')
        else:
            self._refresh_time_label()

    # ---------------- Save / Clear / Cancel ----------------
    def _final_result(self, value):
        if callable(self.on_result):
            try:
                self.on_result(value)
            except Exception:
                pass

    def _save(self, sender):
        iso_value = to_iso_seconds(self.selected_dt)
        self._final_result(iso_value)
        try:
            haptic_success()
        except Exception:
            pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _clear(self, sender):
        if not self.allow_clear:
            return
        self._final_result('')
        try:
            haptic_selection()
        except Exception:
            pass
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _cancel(self, sender):
        self._final_result(None)
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()
            
                                    
# ==== KNOWLEDGE CENTRE =======================================================

# =========================
# Knowledge data file
# =========================
KNOWLEDGE_DATA_FILE = Path(__file__).with_name('knowledge_store.json')


# =========================
# Knowledge List Screen
# =========================
class KnowledgeCenterView(ui.View):
    """
    Light themed Knowledge list that matches the To Do app.

    - Title at the top left
    - "Add" button at the top right
    - List of items in a card style area
    """

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = 'Knowledge'
        self.background_color = 'white'
        self.flex = 'WH'

        self._items = []
        self._load_items()

        # Section title
        self.section_lbl = ui.Label()
        self.section_lbl.text = 'Knowledge'
        self.section_lbl.font = ('<System-Bold>', 25)
        self.section_lbl.text_color = (0.1, 0.1, 0.2)
        self.section_lbl.flex = 'W'
        self.add_subview(self.section_lbl)

        # Add button
        self.add_btn = ui.Button()
        self.add_btn.title = 'Add'
        self.add_btn.action = self._add_item_tapped
        self.add_btn.corner_radius = 8
        self.add_btn.border_width = 1
        self.add_btn.border_color = (0.8, 0.8, 0.85)
        self.add_btn.background_color = (1, 1, 1)
        self.add_btn.tint_color = (0.1, 0.1, 0.2)
        self.add_btn.flex = 'L'
        self.add_subview(self.add_btn)

        # Card style container for the list
        self.list_card = ui.View()
        self.list_card.background_color = (0.98, 0.98, 0.99)
        self.list_card.corner_radius = 12
        self.list_card.border_width = 1
        self.list_card.border_color = (0.9, 0.9, 0.93)
        self.list_card.flex = 'WH'
        self.add_subview(self.list_card)

        # Table of items
        self.table = ui.TableView()
        self.table.row_height = 56
        self.table.data_source = self
        self.table.delegate = self
        self.table.flex = 'WH'
        self.table.background_color = (0.98, 0.98, 0.99)
        self.list_card.add_subview(self.table)

    def layout(self):
        margin = 12
        btn_w, btn_h = 80, 32
        top = 8

        # Title and Add button
        self.section_lbl.frame = (margin, top, self.width - 3 * margin - btn_w, 28)
        self.add_btn.frame = (self.width - margin - btn_w, top, btn_w, btn_h)

        # Card and table fill the rest
        card_top = self.section_lbl.y + self.section_lbl.height + 8
        self.list_card.frame = (margin, card_top, self.width - 2 * margin, self.height - card_top - margin)
        self.table.frame = self.list_card.bounds

    # ----------------- Persistence -----------------
    def _load_items(self):
        try:
            if KNOWLEDGE_DATA_FILE.exists():
                with KNOWLEDGE_DATA_FILE.open('r', encoding='utf-8') as f:
                    self._items = json.load(f)
            else:
                self._items = []
        except Exception:
            # Corrupt file, start fresh
            self._items = []
            
    
            

    def _save_items(self):
        try:
            with KNOWLEDGE_DATA_FILE.open('w', encoding='utf-8') as f:
                json.dump(self._items, f, indent=2, ensure_ascii=False)
        except Exception:
            # Non fatal
            pass

    @property
    def items(self):
        return self._items

    def add_item(self, item):
        self._items.append(item)
        self._save_items()
        self.table.reload()

    def update_item(self, index, item):
        if 0 <= index < len(self._items):
            self._items[index] = item
            self._save_items()
            self.table.reload()

    def delete_item(self, index):
        if 0 <= index < len(self._items):
            self._items.pop(index)
            self._save_items()
            self.table.reload()

    # ----------------- Actions -----------------
    def _add_item_tapped(self, sender):
        editor = KnowledgeEditorView(parent_view=self, index=None, item=None)
        if self.navigation_view:
            _safe_push(self.navigation_view, editor)
        else:
            editor.present('sheet')

    # ----------------- TableView -----------------
    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._items)

    def tableview_cell_for_row(self, tv, section, row):
        cell = ui.TableViewCell('subtitle')
        item = self._items[row]

        # Title
        cell.text_label.text = item.get('title') or 'Untitled item'
        cell.text_label.text_color = (0.1, 0.1, 0.2)

        # Type and summary
        itype = item.get('kind') or 'Text'
        summary = item.get('summary') or ''

        if not summary:
            raw = item.get('content') or ''
            raw = raw.strip()
            if raw:
                lines = raw.splitlines()
                if lines:
                    summary = lines[0][:80]
                else:
                    summary = ''
            else:
                summary = ''

        # If still no summary, just show the type
        if summary:
            cell.detail_text_label.text = f'{itype} \u2022 {summary}'
        else:
            cell.detail_text_label.text = itype

        cell.detail_text_label.text_color = (0.35, 0.35, 0.4)
        cell.background_color = (0.98, 0.98, 0.99)
        return cell

    def tableview_did_select(self, tv, section, row):
        tv.selected_row = (-1, -1)
        editor = KnowledgeEditorView(parent_view=self, index=row, item=self._items[row])
        if self.navigation_view:
            _safe_push(self.navigation_view, editor)
        else:
            editor.present('sheet')

    def tableview_can_delete(self, tv, section, row):
        return True

    def tableview_commit(self, tv, editing_style, section, row):
        if editing_style == 'delete':
            self.delete_item(row)


# =========================
# Knowledge Editor Screen
# =========================
class KnowledgeEditorView(ui.View):
    """
    Editor for a single knowledge item.

    - Title field
    - Type segmented control
    - Multiline content box
    - Save, Delete, Duplicate buttons at bottom
    """

    KIND_OPTIONS = ['Text', 'Link', 'Phone', 'Image', 'Video', 'Other']

    def __init__(self, parent_view, index=None, item=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = 'Knowledge item'
        self.background_color = 'white'
        self.flex = 'WH'

        self.parent_view = parent_view
        self.index = index

        item = item or {}
        self._item = {
            'title': item.get('title', ''),
            'kind': item.get('kind', 'Text'),
            'content': item.get('content', ''),
            'summary': item.get('summary', ''),
            'meta': item.get('meta', {}),
        }

        # Title
        self.title_lbl = ui.Label(text='Title')
        self.title_lbl.font = ('<System>', 14)
        self.title_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.title_lbl)

        self.title_tf = ui.TextField()
        self.title_tf.text = self._item['title']
        self.title_tf.clear_button_mode = 'while_editing'
        
        # Set a rounded border style if the constant exists, otherwise skip
        bs = getattr(ui, 'TEXT_FIELD_BORDER_STYLE_ROUNDED_RECT', None)
        if bs is not None:
            try:
                self.title_tf.border_style = bs
            except Exception:
                pass
        
        self.add_subview(self.title_tf)

        # Type
        self.kind_lbl = ui.Label(text='Type')
        self.kind_lbl.font = ('<System>', 14)
        self.kind_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.kind_lbl)

        self.kind_seg = ui.SegmentedControl(segments=self.KIND_OPTIONS)
        if self._item['kind'] in self.KIND_OPTIONS:
            self.kind_seg.selected_index = self.KIND_OPTIONS.index(self._item['kind'])
        else:
            self.kind_seg.selected_index = 0
        self.add_subview(self.kind_seg)

        # Content
        self.content_lbl = ui.Label(text='Content / notes')
        self.content_lbl.font = ('<System>', 14)
        self.content_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.content_lbl)

        self.content_tv = ui.TextView()
        self.content_tv.text = self._item['content']
        self.add_subview(self.content_tv)

        # Buttons
        self.save_btn = ui.Button(title='Save')
        self.save_btn.action = self._save_tapped
        self.save_btn.corner_radius = 8
        self.save_btn.border_width = 1
        self.save_btn.border_color = (0.3, 0.5, 0.3)
        self.save_btn.background_color = (0.9, 1.0, 0.9)
        self.save_btn.tint_color = (0, 0.3, 0)
        self.add_subview(self.save_btn)

        self.delete_btn = ui.Button(title='Delete')
        self.delete_btn.action = self._delete_tapped
        self.delete_btn.corner_radius = 8
        self.delete_btn.border_width = 1
        self.delete_btn.border_color = (0.7, 0.2, 0.2)
        self.delete_btn.background_color = (1.0, 0.9, 0.9)
        self.delete_btn.tint_color = (0.5, 0, 0)
        self.add_subview(self.delete_btn)

        self.dup_btn = ui.Button(title='Duplicate')
        self.dup_btn.action = self._duplicate_tapped
        self.dup_btn.corner_radius = 8
        self.dup_btn.border_width = 1
        self.dup_btn.border_color = (0.8, 0.8, 0.85)
        self.dup_btn.background_color = (1, 1, 1)
        self.dup_btn.tint_color = (0.1, 0.1, 0.2)
        self.add_subview(self.dup_btn)

    def layout(self):
        margin = 16
        width = self.width - 2 * margin
        y = 8

        # Title
        self.title_lbl.frame = (margin, y, width, 20)
        y += 22
        self.title_tf.frame = (margin, y, width, 32)
        y += 40

        # Type
        self.kind_lbl.frame = (margin, y, width, 20)
        y += 22
        self.kind_seg.frame = (margin, y, width, 32)
        y += 40

        # Content label
        self.content_lbl.frame = (margin, y, width, 20)
        y += 22

        # Content box height adapts to screen, leaving room for buttons
        bottom_buttons_height = 40
        bottom_margin = 16
        content_height = self.height - y - bottom_buttons_height - bottom_margin * 2
        if content_height < 80:
            content_height = 80
        self.content_tv.frame = (margin, y, width, content_height)

        # Bottom buttons, equal sized, no overlap
        btn_y = self.height - bottom_buttons_height - bottom_margin
        gap = 8
        btn_w = (width - 2 * gap) / 3.0
        self.save_btn.frame = (margin, btn_y, btn_w, bottom_buttons_height)
        self.delete_btn.frame = (margin + btn_w + gap, btn_y, btn_w, bottom_buttons_height)
        self.dup_btn.frame = (margin + 2 * (btn_w + gap), btn_y, btn_w, bottom_buttons_height)

    # ----------------- Button actions -----------------
    def _save_tapped(self, sender):
        title = (self.title_tf.text or '').strip()
        kind = self.KIND_OPTIONS[self.kind_seg.selected_index]
        content = self.content_tv.text or ''
        summary = _make_safe_summary(content, 120)
        item = {
            'title': title,
            'kind': kind,
            'content': content,
            'summary': summary,
            'meta': self._item.get('meta', {}),
        }

        if self.index is None:
            self.parent_view.add_item(item)
        else:
            self.parent_view.update_item(self.index, item)

        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _delete_tapped(self, sender):
        if self.index is not None:
            self.parent_view.delete_item(self.index)
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _duplicate_tapped(self, sender):
        title = (self.title_tf.text or '').strip()
        kind = self.KIND_OPTIONS[self.kind_seg.selected_index]
        content = self.content_tv.text or ''
        summary = _make_safe_summary(content, 120)
        item = {
            'title': f"{title or 'Item'} (copy)",
            'kind': kind,
            'content': content,
            'summary': summary,
            'meta': self._item.get('meta', {}),
        }

        self.parent_view.add_item(item)

        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()
                        
                              
                                          
# -------------------------
# Categories (rename/clear per color)
# -------------------------
class CategoriesView(ui.View):
    def __init__(self, palette, cats, on_change=None):
        super().__init__(frame=(0, 0, 420, 520))
        self.name = 'Categories'
        self.background_color = 'black'
        self.palette = list(palette)
        self.cats = cats
        self.on_change = on_change
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 56
        self.table.data_source = self
        self.table.delegate = self
        self.add_subview(self.table)
        self.left_button_items  = [ui.ButtonItem(title='Done', action=self._done)]
        self.right_button_items = [ui.ButtonItem(title='Reset All', action=self._reset_all)]

    def tableview_number_of_sections(self, tv): return 1
    def tableview_number_of_rows(self, tv, section): return len(self.palette)

    def tableview_cell_for_row(self, tv, section, row):
        cell = ui.TableViewCell('subtitle')
        base_name, hexc = self.palette[row]
        cell.text_label.text = base_name
        current = self.cats.get(hexc, '')
        cell.detail_text_label.text = (current if current else 'No category')
        try:
            cell.background_color = hex_to_ui_color(hexc)
            fg = best_text_color_for_bg(hexc)
            cell.text_label.text_color = fg
            cell.detail_text_label.text_color = fg
        except Exception:
            cell.background_color = 'white'
            cell.text_label.text_color = 'black'
            cell.detail_text_label.text_color = 'black'
        cell.accessory_type = 'disclosure_indicator'
        return cell

    def tableview_did_select(self, tv, section, row):
        ui.delay(lambda r=row: self._present_category_actions(r), 0.01)

    @ui.in_background
    def _present_category_actions(self, row):
        try:
            base_name, hexc = self.palette[row]
        except Exception:
            return
        choice = dialogs.list_dialog(f'{base_name} Category', ['Rename', 'Clear', 'Cancel'])
        if not choice or choice == 'Cancel':
            ui.delay(self.table.reload_data, 0.0)
            return
        if choice == 'Clear':
            self.cats[hexc] = ''
            save_categories(self.cats)
            if callable(self.on_change): self.on_change(self.cats)
            ui.delay(self.table.reload_data, 0.0)
            return
        if choice == 'Rename':
            changed = reuse_rename_category(hexc, self.cats, _PALETTE, title_prefix='Rename')
            def _after():
                if changed and callable(self.on_change):
                    self.on_change(self.cats)
                self.table.reload_data()
            ui.delay(_after, 0.0)

    def _done(self, sender):
        if self.navigation_view: self.navigation_view.pop_view()
        else: self.close()

    def _reset_all(self, sender):
        if not dialogs.yes_no_alert('Reset All', 'Clear ALL category names?', 'Reset', 'Cancel'):
            return
        for _n, hx in self.palette:
            self.cats[hx] = ''
        save_categories(self.cats)
        if callable(self.on_change): self.on_change(self.cats)
        self.table.reload_data()
        dialogs.hud_alert('All category names cleared', 'success', 0.8)

class SortSettings(object):
    """Sort settings, including secondary key and separate directions."""

    def __init__(self,
                 mode=SORT_MODE_MANUAL,
                 direction_primary='asc',
                 secondary_mode=SORT_MODE_CREATED,
                 direction_secondary='asc',
                 show_headers=True,
                 user_default_mode=SORT_MODE_MANUAL,
                 user_default_direction_primary='asc',
                 user_default_secondary_mode=SORT_MODE_CREATED,
                 user_default_direction_secondary='asc'):
        # Current (active) sort
        self.mode = mode                          # primary sort mode
        self.direction_primary = direction_primary  # 'asc' or 'desc'
        self.secondary_mode = secondary_mode      # second key
        self.direction_secondary = direction_secondary  # 'asc' or 'desc'
        self.show_headers = show_headers          # group headers on/off

        # Saved default sort
        self.user_default_mode = user_default_mode
        self.user_default_direction_primary = user_default_direction_primary
        self.user_default_secondary_mode = user_default_secondary_mode
        self.user_default_direction_secondary = user_default_direction_secondary

    @classmethod
    def load_from_disk(cls):
        if not SETTINGS_PATH.exists():
            return cls()
        try:
            with open(SETTINGS_PATH, 'r', encoding='utf-8') as f:
                data = json.load(f) or {}
        except Exception:
            return cls()
        d = data.get('sort', {})
        return cls(
            mode=d.get('mode', SORT_MODE_MANUAL),
            direction_primary=d.get('direction_primary', d.get('direction', 'asc')),
            secondary_mode=d.get('secondary_mode', SORT_MODE_CREATED),
            direction_secondary=d.get('direction_secondary', 'asc'),
            show_headers=bool(d.get('show_headers', True)),
            user_default_mode=d.get('user_default_mode', SORT_MODE_MANUAL),
            user_default_direction_primary=d.get('user_default_direction_primary',
                                                 d.get('user_default_direction', 'asc')),
            user_default_secondary_mode=d.get('user_default_secondary_mode', SORT_MODE_CREATED),
            user_default_direction_secondary=d.get('user_default_direction_secondary', 'asc'),
        )

    def save_to_disk(self):
        """Persist the *default* sort settings."""
        data = {}
        if SETTINGS_PATH.exists():
            try:
                with open(SETTINGS_PATH, 'r', encoding='utf-8') as f:
                    data = json.load(f) or {}
            except Exception:
                data = {}
        data['sort'] = {
            'mode': self.mode,
            'direction_primary': self.direction_primary,
            'secondary_mode': self.secondary_mode,
            'direction_secondary': self.direction_secondary,
            'show_headers': bool(self.show_headers),
            'user_default_mode': self.user_default_mode,
            'user_default_direction_primary': self.user_default_direction_primary,
            'user_default_secondary_mode': self.user_default_secondary_mode,
            'user_default_direction_secondary': self.user_default_direction_secondary,
        }
        try:
            with open(SETTINGS_PATH, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception:
            pass

    def apply_user_default(self):
        """Use the saved default as the current sort."""
        self.mode = self.user_default_mode
        self.direction_primary = self.user_default_direction_primary
        self.secondary_mode = self.user_default_secondary_mode
        self.direction_secondary = self.user_default_direction_secondary


class SortPanelView(ui.View):
    """Sort and view panel.

    Lets the user:
    - choose primary sort
    - choose secondary sort (Then by)
    - choose direction for each key
    - toggle group headers
    - apply once
    - save as default sort
    - clear filters
    """

    def __init__(self, sort_settings, on_apply, on_clear_filters, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.name = 'Sort and view'
        self.background_color = 'white'
        self.flex = 'WH'

        self.sort_settings = sort_settings
        self.on_apply = on_apply
        self.on_clear_filters = on_clear_filters

        self.mode_values = [
            (SORT_MODE_MANUAL,   'Manual'),
            (SORT_MODE_DUE_DATE, 'Due date'),
            (SORT_MODE_CATEGORY, 'Category'),
            (SORT_MODE_TITLE,    'Title A-Z'),
            (SORT_MODE_CREATED,  'Created date'),
            (SORT_MODE_STATUS,   'Status'),
        ]

        self._build_ui()

    # ---------- UI ----------

    def _build_ui(self):
        padding = 16

        # Scroll container so everything is reachable
        scroll = ui.ScrollView(frame=self.bounds, flex='WH')
        scroll.shows_vertical_scroll_indicator = True
        scroll.content_size = (self.width, self.height)
        self.add_subview(scroll)

        y = padding

        # Primary sort
        lbl = ui.Label(frame=(padding, y, self.width - 2 * padding, 24),
                       flex='W',
                       text='Sort by',
                       font=('<System-Bold>', 16))
        scroll.add_subview(lbl)
        y += 28

        self.mode_buttons = []
        for value, label in self.mode_values:
            b = ui.Button(frame=(padding, y, self.width - 2 * padding, 32),
                          flex='W')
            b.name = value
            b.title = label
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.8, 0.8, 0.85)
            b.background_color = 'white'
            b.tint_color = (0.1, 0.1, 0.2)
            b.font = ('<System>', 15)
            b.action = self._mode_tapped
            scroll.add_subview(b)
            self.mode_buttons.append(b)
            y += 40

        y += 8

        # Primary direction
        dir1_lbl = ui.Label(frame=(padding, y, self.width - 2 * padding, 24),
                            flex='W',
                            text='Primary direction',
                            font=('<System-Bold>', 16))
        scroll.add_subview(dir1_lbl)
        y += 28

        self.dir1_seg = ui.SegmentedControl(frame=(padding, y, self.width - 2 * padding, 32),
                                            flex='W')
        self.dir1_seg.segments = ['Ascending', 'Descending']
        self.dir1_seg.action = self._dir1_changed
        scroll.add_subview(self.dir1_seg)
        y += 44

        # Secondary sort
        sec_lbl = ui.Label(frame=(padding, y, self.width - 2 * padding, 24),
                           flex='W',
                           text='Then by (second key)',
                           font=('<System-Bold>', 16))
        scroll.add_subview(sec_lbl)
        y += 28

        self.secondary_mode_buttons = []
        for value, label in self.mode_values:
            b = ui.Button(frame=(padding, y, self.width - 2 * padding, 32),
                          flex='W')
            b.name = value
            b.title = label
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.8, 0.8, 0.85)
            b.background_color = 'white'
            b.tint_color = (0.1, 0.1, 0.2)
            b.font = ('<System>', 15)
            b.action = self._secondary_mode_tapped
            scroll.add_subview(b)
            self.secondary_mode_buttons.append(b)
            y += 40

        y += 8

        # Secondary direction
        dir2_lbl = ui.Label(frame=(padding, y, self.width - 2 * padding, 24),
                            flex='W',
                            text='Secondary direction',
                            font=('<System-Bold>', 16))
        scroll.add_subview(dir2_lbl)
        y += 28

        self.dir2_seg = ui.SegmentedControl(frame=(padding, y, self.width - 2 * padding, 32),
                                            flex='W')
        self.dir2_seg.segments = ['Ascending', 'Descending']
        self.dir2_seg.action = self._dir2_changed
        scroll.add_subview(self.dir2_seg)
        y += 44

        # Headers switch
        self.headers_switch = ui.Switch(frame=(self.width - padding - 51, y, 51, 31),
                                        flex='L')
        headers_lbl = ui.Label(frame=(padding, y, self.width - padding - 60, 31),
                               flex='W',
                               text='Show group headers',
                               font=('<System>', 16))
        scroll.add_subview(headers_lbl)
        scroll.add_subview(self.headers_switch)
        y += 44

        # Apply + Save sort buttons
        half = (self.width - 3 * padding) / 2.0

        apply_btn = ui.Button(frame=(padding, y, half, 40),
                              flex='W')
        apply_btn.title = 'Apply'
        apply_btn.background_color = '#007AFF'
        apply_btn.tint_color = 'white'
        apply_btn.corner_radius = 8
        apply_btn.font = ('<System-Bold>', 16)
        apply_btn.action = self._apply_tapped
        scroll.add_subview(apply_btn)

        save_btn = ui.Button(frame=(padding * 2 + half, y, half, 40),
                             flex='W')
        save_btn.title = 'Save sort'
        save_btn.background_color = '#5856D6'
        save_btn.tint_color = 'white'
        save_btn.corner_radius = 8
        save_btn.font = ('<System-Bold>', 16)
        save_btn.action = self._save_sort_tapped
        scroll.add_subview(save_btn)
        y += 56

        # Clear filters
        clear_btn = ui.Button(frame=(padding, y, self.width - 2 * padding, 40),
                              flex='W')
        clear_btn.title = 'Clear filters'
        clear_btn.tint_color = '#FF3B30'
        clear_btn.border_width = 1
        clear_btn.corner_radius = 8
        clear_btn.font = ('<System>', 16)
        clear_btn.action = self._clear_filters_tapped
        scroll.add_subview(clear_btn)
        y += 52

        scroll.content_size = (self.width, max(self.height, y))
        self._scroll = scroll

        self._update_from_settings()

    # ---------- Wiring ----------

    def _update_from_settings(self):
        # Primary mode buttons
        for b in self.mode_buttons:
            if b.name == self.sort_settings.mode:
                b.background_color = '#E5F2FF'
                b.border_color = '#007AFF'
            else:
                b.background_color = 'white'
                b.border_color = (0.8, 0.8, 0.85)

        # Secondary mode buttons
        for b in self.secondary_mode_buttons:
            if b.name == self.sort_settings.secondary_mode:
                b.background_color = '#E5F2FF'
                b.border_color = '#007AFF'
            else:
                b.background_color = 'white'
                b.border_color = (0.8, 0.8, 0.85)

        self.dir1_seg.selected_index = 1 if self.sort_settings.direction_primary == 'desc' else 0
        self.dir2_seg.selected_index = 1 if self.sort_settings.direction_secondary == 'desc' else 0
        self.headers_switch.value = bool(self.sort_settings.show_headers)

    def _mode_tapped(self, sender):
        self.sort_settings.mode = sender.name
        self._update_from_settings()

    def _secondary_mode_tapped(self, sender):
        self.sort_settings.secondary_mode = sender.name
        self._update_from_settings()

    def _dir1_changed(self, sender):
        self.sort_settings.direction_primary = 'desc' if sender.selected_index == 1 else 'asc'

    def _dir2_changed(self, sender):
        self.sort_settings.direction_secondary = 'desc' if sender.selected_index == 1 else 'asc'

    def _apply_tapped(self, sender):
        # Apply once (do not change defaults)
        self.sort_settings.show_headers = bool(self.headers_switch.value)
        if callable(self.on_apply):
            self.on_apply(self.sort_settings, set_as_default=False)
        self.close()

    def _save_sort_tapped(self, sender):
        # Save as new default sort + apply
        self.sort_settings.show_headers = bool(self.headers_switch.value)
        self.sort_settings.user_default_mode = self.sort_settings.mode
        self.sort_settings.user_default_direction_primary = self.sort_settings.direction_primary
        self.sort_settings.user_default_secondary_mode = self.sort_settings.secondary_mode
        self.sort_settings.user_default_direction_secondary = self.sort_settings.direction_secondary

        if callable(self.on_apply):
            # Apply + persist defaults
            self.on_apply(self.sort_settings, set_as_default=True)

        # Let the user know it worked
        try:
            dialogs.hud_alert('Sort saved and applied', 'success', 0.7)
        except Exception:
            pass

        # Return to main screen
        nav = self.navigation_view
        if nav:
            nav.pop_view()
        else:
            self.close()

    def _clear_filters_tapped(self, sender):
        if callable(self.on_clear_filters):
            self.on_clear_filters()
        # Panel stays open
        
# =========================================================
# FILTER VIEW + DETAIL SCREENS (FULL UPDATED SET)
# =========================================================

class FilterView(ui.View):
    """
    Menu screen listing filter options.
    Pushes detail screens for each filter type (except colours, which go
    straight to MultiColorPicker).
    """

    def __init__(self, owner, on_apply=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Filters'
        self.background_color = 'black'
        self.owner = owner
        self.on_apply = on_apply  # optional

        # Ensure adv filter exists with new fields
        if not hasattr(owner, 'adv_filter') or not isinstance(owner.adv_filter, dict):
            owner.adv_filter = {
                'enabled': False,
                # Name filter
                'name_mode': 'contains',   # contains | equals | starts
                'name_values': [],         # list of strings
                'name_logic': 'or',        # or | and
                'name_value': '',          # legacy string (comma-joined)
                # Created date filter
                'created_mode': 'any',     # any | on | range
                'created_on': '',
                'created_from': '',
                'created_to': '',
                # Due date filter
                'due_mode': 'any',         # any | on | range
                'due_on': '',
                'due_from': '',
                'due_to': '',
                'due_include_empty': False,
            }

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [ui.ButtonItem(title='Clear All', action=self._clear_all)]

        # Table menu
        self.table = ui.TableView(frame=self.bounds, flex='WH')
        self.table.background_color = 'black'
        self.table.separator_color = (0.2, 0.2, 0.2)
        self.table.row_height = 58
        self.table.data_source = self
        self.table.delegate = self
        self.add_subview(self.table)

        # Bottom "Save filters" button (raised 20 higher)
        self.save_btn = ui.Button(title='Save filters')
        self.save_btn.corner_radius = 10
        self.save_btn.border_width = 1
        self.save_btn.border_color = hex_to_ui_color('#D4AF37')
        self.save_btn.background_color = hex_to_ui_color('#D4AF37')
        self.save_btn.tint_color = 'black'
        self.save_btn.font = ('<System-Bold>', 16)
        self.save_btn.action = self._save_filters
        self.add_subview(self.save_btn)

    def layout(self):
        margin = 16
        btn_h = 48

        # Raised 20 points from bottom
        self.save_btn.width = self.width - 2 * margin
        self.save_btn.x = margin
        self.save_btn.y = self.height - btn_h - margin - 20

        table_bottom = self.save_btn.y - margin
        self.table.frame = (0, 0, self.width, table_bottom)

    # ----- Menu rows -----
    def _rows(self):
        return [
            ('Item Name',            'name'),
            ('Item Created Date',    'created'),
            ('Item Due Date',        'due'),
            ('Colour / Category',    'colour'),
            ('Completed / Not',      'done'),
        ]

    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        return len(self._rows())

    def _subtitle_for_key(self, key):
        af = self.owner.adv_filter or {}

        if key == 'name':
            vals = [v.strip() for v in (af.get('name_values') or []) if v.strip()]
            if not vals:
                return 'Any'
            mode = af.get('name_mode', 'contains')
            mode_label = {
                'contains': 'Contains',
                'equals':   'Equals',
                'starts':   'Starts with',
            }.get(mode, 'Contains')
            logic = af.get('name_logic', 'or')
            joiner = ' OR ' if logic == 'or' else ' AND '
            preview = joiner.join(vals)
            if len(preview) > 30:
                preview = preview[:27] + '...'
            return f'{mode_label}: {preview}'

        if key == 'created':
            mode = af.get('created_mode', 'any')
            if mode == 'on':
                on_iso = (af.get('created_on') or '').strip()
                return f'On {_fmt_dt_for_label(on_iso)}' if on_iso else 'On (not set)'
            if mode == 'range':
                f = (af.get('created_from') or '').strip()
                t = (af.get('created_to') or '').strip()
                if f and t:
                    return f'{_fmt_dt_for_label(f)} to {_fmt_dt_for_label(t)}'
                if f:
                    return f'From {_fmt_dt_for_label(f)}'
                if t:
                    return f'To {_fmt_dt_for_label(t)}'
            return 'Any'

        if key == 'due':
            mode = af.get('due_mode', 'any')
            inc_empty = bool(af.get('due_include_empty', False))
            extra = ' (incl empty)' if inc_empty else ''
            if mode == 'on':
                on_iso = (af.get('due_on') or '').strip()
                return f'On {_fmt_dt_for_label(on_iso)}{extra}' if on_iso else f'On (not set){extra}'
            if mode == 'range':
                f = (af.get('due_from') or '').strip()
                t = (af.get('due_to') or '').strip()
                if f and t:
                    return f'{_fmt_dt_for_label(f)} to {_fmt_dt_for_label(t)}{extra}'
                if f:
                    return f'From {_fmt_dt_for_label(f)}{extra}'
                if t:
                    return f'To {_fmt_dt_for_label(t)}{extra}'
            return 'Any' + extra if inc_empty else 'Any'

        if key == 'colour':
            sel = set(getattr(self.owner, 'filter_category_hexes', set()) or [])
            count = len(sel)
            if count == 0:
                return 'All colours'

            # Ordered pairs based on palette
            pairs = []
            for base_name, hx in _PALETTE:
                if hx in sel:
                    name = self.owner.categories.get(hx, '') or base_name
                    pairs.append((name, hx))

            if not pairs:
                return 'All colours'

            # For many colours, just give a count
            if count > 4:
                return f'{count} colours selected'

            # For 1–4 colours, list their names
            names = [p[0] for p in pairs]
            return ', '.join(names)

        if key == 'done':
            v = getattr(self.owner, 'filter_done', 'all')
            return {'all': 'All', 'active': 'Active only', 'done': 'Completed only'}.get(v, 'All')

        return ''

    def tableview_cell_for_row(self, tv, section, row):
        title, key = self._rows()[row]

        # Basic cell with subtitle style
        cell = ui.TableViewCell('subtitle')
        cell.background_color = 'black'
        cell.text_label.text = title
        cell.text_label.text_color = 'white'
        cell.text_label.font = ('<System>', 17)

        # Default subtitle text for all keys
        subtitle_text = self._subtitle_for_key(key)
        cell.detail_text_label.text = subtitle_text
        cell.detail_text_label.text_color = (0.65, 0.65, 0.7)
        cell.detail_text_label.font = ('<System>', 12)
        cell.detail_text_label.hidden = False

        # Clean up any previous custom colour row from reused cells
        for sv in list(cell.content_view.subviews):
            if getattr(sv, 'name', '') == 'colour_row':
                cell.content_view.remove_subview(sv)

        # Special rendering for the colour row
        if key == 'colour':
            sel = set(getattr(self.owner, 'filter_category_hexes', set()) or [])
            count = len(sel)

            # Only draw custom chips when 1–4 colours selected.
            # For 0 colours, "All colours" subtitle shows.
            # For 5+ colours, "N colours selected" subtitle shows.
            if 1 <= count <= 4:
                # Build ordered list of (category_name, hex) based on palette order
                pairs = []
                for base_name, hx in _PALETTE:
                    if hx in sel:
                        name = self.owner.categories.get(hx, '') or base_name
                        pairs.append((name, hx))

                if pairs:
                    # Keep subtitle "alive" so the title layout does not move
                    # We leave the label visible but with transparent text.
                    cell.detail_text_label.text = ' '      # non empty string for layout
                    cell.detail_text_label.hidden = False
                    cell.detail_text_label.text_color = (0, 0, 0, 0)

                    # Create a container view that will be aligned to the subtitle frame
                    row_view = ui.View()
                    row_view.name = 'colour_row'
                    row_view.background_color = 'clear'
                    # Initial dummy frame, will be aligned after layout
                    row_view.frame = (0, 0, 0, 0)
                    row_view.flex = 'W'

                    # Provisional width for laying out chips
                    max_w = tv.bounds.width - 32
                    if max_w <= 0:
                        max_w = 200

                    x = 0
                    chip_size = 12
                    pad = 8
                    row_h = 18

                    # Build up to 4 [Name][Square] pairs
                    for (name, hx) in pairs[:4]:
                        lbl = ui.Label()
                        lbl.text = name
                        style_colour_label(lbl, hx)
                        lbl.font = ('<System>', 11)
                        lbl.size_to_fit()
                        lw = lbl.width

                        if x + lw + chip_size + pad > max_w and x > 0:
                            break

                        lbl.frame = (x, 0, lw, row_h)
                        row_view.add_subview(lbl)
                        x += lw + 4

                        chip = ui.View()
                        chip.frame = (x, (row_h - chip_size) / 2.0, chip_size, chip_size)
                        chip.corner_radius = 3
                        chip.border_width = 1
                        chip.border_color = (0.8, 0.8, 0.85)
                        try:
                            chip.background_color = hex_to_ui_color(hx)
                        except Exception:
                            chip.background_color = 'white'
                        row_view.add_subview(chip)
                        x += chip_size + pad

                    cell.content_view.add_subview(row_view)

                    # Align the row exactly where the subtitle label is,
                    # once the cell has done its layout.
                    def _align_row():
                        if not cell.superview:
                            return

                        dx, dy, dw, dh = cell.detail_text_label.frame

                        # Minimum sensible width so content is not crushed
                        min_w = cell.content_view.width - dx - 16
                        if min_w < 40:
                            min_w = 40

                        if dw <= 0 or dw < min_w * 0.5:
                            dw = min_w

                        if dh <= 0:
                            dh = row_h

                        row_view.frame = (dx, dy, dw, dh)

                    ui.delay(_align_row, 0)

        cell.accessory_type = 'disclosure_indicator'
        return cell

    def tableview_did_select(self, tv, section, row):
        _title, key = self._rows()[row]
        tv.reload_data()
        haptic_selection()

        if key == 'name':
            view = NameFilterDetailView(self.owner, on_done=self._detail_done)
            _safe_push(self.navigation_view, view)
            return

        if key == 'created':
            view = DateFilterDetailView(
                self.owner,
                kind='created',
                title='Filter Created Date',
                on_done=self._detail_done,
                allow_include_empty=False
            )
            _safe_push(self.navigation_view, view)
            return

        if key == 'due':
            view = DateFilterDetailView(
                self.owner,
                kind='due',
                title='Filter Due Date',
                on_done=self._detail_done,
                allow_include_empty=True
            )
            _safe_push(self.navigation_view, view)
            return

        if key == 'colour':
            # Open picker immediately (no extra screen)
            def applied(selected_hexes):
                self.owner.filter_category_hexes = set(selected_hexes)
                try:
                    self.owner.ds.refresh()
                    self.owner._rebuild_filter_summary()
                    self.owner.table.reload_data()
                except Exception:
                    pass
           

                haptic_success()
                self._detail_done()  # refresh subtitles

            picker = MultiColorPicker(
                _PALETTE,
                self.owner.categories,
                selected_hexes=getattr(self.owner, 'filter_category_hexes', set()),
                on_apply=applied,
                title='Filter by Colour'
            )
            _safe_push(self.navigation_view, picker)
            return

        if key == 'done':
            view = DoneFilterDetailView(self.owner, on_done=self._detail_done)
            _safe_push(self.navigation_view, view)
            return

    # ----- Callbacks from detail screens -----
    def _detail_done(self):
        self.table.reload_data()
        if callable(self.on_apply):
            try:
                self.on_apply(
                    self.owner.adv_filter,
                    set(self.owner.filter_category_hexes),
                    self.owner.filter_done
                )
            except Exception:
                pass

    def _save_filters(self, sender):
        """
        Global apply button at the bottom of the filter menu.
        Treats the current adv_filter + category + done settings
        as the active filter and closes the filter view.
        """
        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass

        if callable(self.on_apply):
            try:
                self.on_apply(
                    self.owner.adv_filter,
                    set(self.owner.filter_category_hexes),
                    self.owner.filter_done
                )
            except Exception:
                pass

        dialogs.hud_alert('Filters applied', 'success', 0.6)
        haptic_success()

        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()

    def _clear_all(self, sender):
        self.owner.filter_category_hexes.clear()
        self.owner.filter_done = 'all'
        self.owner.adv_filter = {
            'enabled': False,
            'name_mode': 'contains',
            'name_values': [],
            'name_logic': 'or',
            'name_value': '',
            'created_mode': 'any',
            'created_on': '',
            'created_from': '',
            'created_to': '',
            'due_mode': 'any',
            'due_on': '',
            'due_from': '',
            'due_to': '',
            'due_include_empty': False,
        }
        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass
        self.table.reload_data()
        dialogs.hud_alert('All filters cleared', 'success', 0.6)
        haptic_success()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()


# =========================================================
# DETAIL: NAME FILTER (MULTIPLE TERMS + AND/OR)
# =========================================================

class NameFilterDetailView(ui.View):
    """
    Filter by item name, supports multiple terms plus AND / OR logic.
    """
    def __init__(self, owner, on_done):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Item Name'
        self.background_color = 'black'
        self.owner = owner
        self.on_done = on_done

        af = owner.adv_filter or {}

        self.mode = af.get('name_mode', 'contains')
        self.values = list(af.get('name_values') or [])
        self.logic = af.get('name_logic', 'or')  # or | and

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        y = 20

        lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        lbl.text = 'Filter by name'
        lbl.text_color = 'white'
        lbl.font = ('<System-Bold>', 18)
        self.add_subview(lbl)
        y += 34

        # Text field + "Add" button
        self.tf = ui.TextField(frame=(16, y, self.width - 32 - 84, 36), flex='W')
        self.tf.placeholder = 'Enter a word or phrase'
        self.tf.clear_button_mode = 'while_editing'
        self.tf.background_color = 'white'
        self.tf.text_color = 'black'
        self.tf.tint_color = 'black'
        self.tf.corner_radius = 8
        self.add_subview(self.tf)

        self.add_btn = ui.Button(frame=(self.tf.x + self.tf.width + 8, y, 76, 36), flex='L')
        self.add_btn.title = 'Add'
        self.add_btn.corner_radius = 8
        self.add_btn.border_width = 1
        self.add_btn.border_color = (0.6, 0.6, 0.7)
        self.add_btn.background_color = (0.18, 0.18, 0.2)
        self.add_btn.tint_color = 'white'
        self.add_btn.font = ('<System>', 14)
        self.add_btn.action = self._add_term
        self.add_subview(self.add_btn)
        y += 50

        # Mode segmented (Contains / Equals / Starts)
        self.seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.seg)

        self.seg_btns = []
        def make_action(val):
            def a(sender):
                self.mode = val
                self._refresh_seg()
                haptic_selection()
            return a

        for label, val in [('Contains', 'contains'), ('Equals', 'equals'), ('Starts', 'starts')]:
            b = ui.Button(title=label, action=make_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 12)
            self.seg.add_subview(b)
            self.seg_btns.append((b, val))

        y += 40

        # Tokens container (words added to filter)
        self.tokens_view = ui.View(frame=(16, y, self.width - 32, 80), flex='W')
        self.add_subview(self.tokens_view)
        y += 90

        # AND / OR segmented (only visible if at least one word)
        self.logic_hint = ui.Label(frame=(16, y, self.width - 32, 18), flex='W')
        self.logic_hint.text = 'Combine words with:'
        self.logic_hint.text_color = 'white'
        self.logic_hint.font = ('<System>', 12)
        self.add_subview(self.logic_hint)
        y += 22

        self.logic_seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.logic_seg)

        self.logic_btns = []
        def make_logic_action(val):
            def a(sender):
                self.logic = val
                self._refresh_logic_seg()
                haptic_selection()
            return a

        for label, val in [('OR (any match)', 'or'), ('AND (all match)', 'and')]:
            b = ui.Button(title=label, action=make_logic_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 12)
            self.logic_seg.add_subview(b)
            self.logic_btns.append((b, val))

        # Layout + initial state
        self._layout_seg()
        self._layout_logic_seg()
        self._refresh_seg()
        self._refresh_tokens()
        self._refresh_logic_seg()
        self._update_logic_visibility()

    def layout(self):
        self.tf.width = self.width - 32 - 84
        self.add_btn.x = self.tf.x + self.tf.width + 8

        self.seg.width = self.width - 32
        self._layout_seg()

        self.tokens_view.width = self.width - 32

        self.logic_hint.width = self.width - 32
        self.logic_seg.width = self.width - 32
        self._layout_logic_seg()

    # ----- segment layouts -----
    def _layout_seg(self):
        gap = 6
        n = len(self.seg_btns)
        if n <= 0:
            return
        w = (self.seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.seg_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _layout_logic_seg(self):
        gap = 6
        n = len(self.logic_btns)
        if n <= 0:
            return
        w = (self.logic_seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.logic_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _refresh_seg(self):
        for (b, v) in self.seg_btns:
            if v == self.mode:
                b.background_color = (0.28, 0.28, 0.32)
                b.border_color = hex_to_ui_color('#D4AF37')
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _refresh_logic_seg(self):
        for (b, v) in self.logic_btns:
            if v == self.logic:
                b.background_color = (0.28, 0.28, 0.32)
                b.border_color = hex_to_ui_color('#D4AF37')
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _update_logic_visibility(self):
        has_terms = len(self.values) > 0
        self.logic_hint.hidden = not has_terms
        self.logic_seg.hidden = not has_terms

    # ----- token handling -----
    def _refresh_tokens(self):
        for sv in list(self.tokens_view.subviews):
            self.tokens_view.remove_subview(sv)

        x = 0
        y = 0
        row_h = 26
        max_w = self.tokens_view.width or 300
        pad = 6

        for term in self.values:
            label = term
            if len(label) > 18:
                label = label[:15] + '...'

            b = ui.Button()
            b.title = label + '  ✕'
            b.font = ('<System>', 11)
            b.corner_radius = 12
            b.border_width = 1
            b.border_color = (0.6, 0.6, 0.7)
            b.background_color = (0.2, 0.2, 0.24)
            b.tint_color = 'white'
            b.size_to_fit()
            w = b.width + 12

            if x + w > max_w and x > 0:
                x = 0
                y += row_h + 4

            b.frame = (x, y, w, row_h)
            x += w + pad

            def make_remove(t=term):
                def _r(sender):
                    try:
                        self.values.remove(t)
                    except ValueError:
                        pass
                    self._refresh_tokens()
                    self._update_logic_visibility()
                return _r
            b.action = make_remove()
            self.tokens_view.add_subview(b)

        self._update_logic_visibility()

    def _add_term(self, sender):
        txt = (self.tf.text or '').strip()
        if not txt:
            dialogs.hud_alert('Enter a word first.', 'warning', 0.7)
            return
        self.values.append(txt)
        self.tf.text = ''
        self._refresh_tokens()
        self._update_logic_visibility()
        haptic_selection()

    # ----- clear/save -----
    def _clear(self, sender):
        self.tf.text = ''
        self.mode = 'contains'
        self.logic = 'or'
        self.values = []
        self._refresh_seg()
        self._refresh_logic_seg()
        self._refresh_tokens()
        self._update_logic_visibility()
        self._save(sender)

    def _save(self, sender):
        vals = [v.strip() for v in self.values if v.strip()]
        af = self.owner.adv_filter or {}

        af['name_mode'] = self.mode
        af['name_values'] = vals
        af['name_logic'] = self.logic if vals else 'or'
        af['name_value'] = ', '.join(vals) if vals else ''

        af['enabled'] = bool(
            vals or
            (af.get('created_on') or '').strip() or
            (af.get('created_from') or '').strip() or (af.get('created_to') or '').strip() or
            (af.get('due_on') or '').strip() or
            (af.get('due_from') or '').strip() or (af.get('due_to') or '').strip()
        )
        self.owner.adv_filter = af

        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass

        haptic_success()
        if callable(self.on_done):
            self.on_done()
        if self.navigation_view:
            self.navigation_view.pop_view()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()


# =========================================================
# DETAIL: DATE FILTER (WITH DATE-ONLY "ON DATE")
# =========================================================

class DateFilterDetailView(ui.View):
    """
    kind = 'created' or 'due'

    Modes:
      - any   (no date filter)
      - on    (single date, date-only picker)
      - range (from/to, datetime picker)

    Time defaults:
      - On / From -> 12:00 AM
      - To        -> 11:59 PM
    """
    def __init__(self, owner, kind='created', title='Filter Dates', on_done=None, allow_include_empty=False):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = title
        self.background_color = 'black'
        self.owner = owner
        self.kind = kind
        self.on_done = on_done
        self.allow_include_empty = allow_include_empty

        af = owner.adv_filter or {}

        if kind == 'created':
            self.mode = af.get('created_mode', 'any')
            self.on_iso = af.get('created_on', '')
            self.from_iso = af.get('created_from', '')
            self.to_iso   = af.get('created_to', '')
            self.include_empty = False
        else:
            self.mode = af.get('due_mode', 'any')
            self.on_iso = af.get('due_on', '')
            self.from_iso = af.get('due_from', '')
            self.to_iso   = af.get('due_to', '')
            self.include_empty = bool(af.get('due_include_empty', False))

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        y = 20

        lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        lbl.text = 'Select mode'
        lbl.text_color = 'white'
        lbl.font = ('<System-Bold>', 18)
        self.add_subview(lbl)
        y += 34

        # Mode segmented
        self.mode_seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.mode_seg)
        self.mode_btns = []

        def make_mode_action(val):
            def a(sender):
                self.mode = val
                self._refresh_mode_seg()
                self._refresh_visibility()
                try:
                    haptic_selection()
                except Exception:
                    pass
            return a

        for label, val in [('Any', 'any'), ('On Date', 'on'), ('Range', 'range')]:
            b = ui.Button(title=label, action=make_mode_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 13)
            self.mode_seg.add_subview(b)
            self.mode_btns.append((b, val))
        y += 46

        # Single date button (On)
        self.on_btn = ui.Button(frame=(16, y, self.width - 32, 38), flex='W')
        self._style_field_btn(self.on_btn)
        self.on_btn.title = self._title_for(self.on_iso, 'On')
        self.on_btn.action = self._pick_on
        self.add_subview(self.on_btn)
        y += 50

        # Range buttons (From/To)
        half_w = (self.width - 48) / 2
        self.from_btn = ui.Button(frame=(16, y, half_w, 38), flex='W')
        self.to_btn   = ui.Button(frame=(16 + half_w + 16, y, half_w, 38), flex='W')
        self._style_field_btn(self.from_btn)
        self._style_field_btn(self.to_btn)
        self.from_btn.title = self._title_for(self.from_iso, 'From')
        self.to_btn.title   = self._title_for(self.to_iso, 'To')
        self.from_btn.action = self._pick_from
        self.to_btn.action   = self._pick_to
        self.add_subview(self.from_btn)
        self.add_subview(self.to_btn)
        y += 58

        # Include-empty toggle for due
        if self.allow_include_empty:
            self.empty_lbl = ui.Label(frame=(16, y, 260, 22))
            self.empty_lbl.text = 'Include items with no date'
            self.empty_lbl.text_color = 'white'
            self.empty_lbl.font = ('<System>', 14)
            self.add_subview(self.empty_lbl)

            self.empty_sw = ui.Switch(frame=(self.width - 16 - 51, y - 3, 51, 31), flex='L')
            self.empty_sw.value = self.include_empty
            self.empty_sw.action = self._toggle_empty
            self.add_subview(self.empty_sw)
            y += 44

        self._layout_mode_seg()
        self._refresh_mode_seg()
        self._refresh_visibility()

    def layout(self):
        self.mode_seg.width = self.width - 32
        self._layout_mode_seg()

        self.on_btn.width = self.width - 32

        half_w = (self.width - 48) / 2
        self.from_btn.width = half_w
        self.to_btn.width = half_w
        self.to_btn.x = 16 + half_w + 16

        if self.allow_include_empty:
            self.empty_sw.x = self.width - 16 - 51

    def _style_field_btn(self, b):
        b.corner_radius = 8
        b.border_width = 1
        b.border_color = (0.55, 0.55, 0.65)
        b.background_color = (0.17, 0.17, 0.19)
        b.tint_color = 'white'
        b.font = ('<System>', 14)

    def _layout_mode_seg(self):
        gap = 6
        n = len(self.mode_btns)
        w = (self.mode_seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.mode_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _refresh_mode_seg(self):
        for (b, v) in self.mode_btns:
            if v == self.mode:
                b.background_color = (0.28, 0.28, 0.32)
                try:
                    b.border_color = hex_to_ui_color('#D4AF37')
                except Exception:
                    b.border_color = (0.9, 0.8, 0.4)
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _refresh_visibility(self):
        self.on_btn.hidden = (self.mode != 'on')
        self.from_btn.hidden = (self.mode != 'range')
        self.to_btn.hidden   = (self.mode != 'range')

    def _title_for(self, iso, prefix):
        if not (iso or '').strip():
            return f'{prefix}: Any'
        d = parse_iso_or_now(iso)
        return f'{prefix}: {d.strftime("%d %b %Y")}'

    # ---- pickers ----
    def _pick_on(self, sender):
        self._pick_date('On Date', self.on_iso, target='on')

    def _pick_from(self, sender):
        self._pick_date('From Date', self.from_iso, target='from')

    def _pick_to(self, sender):
        self._pick_date('To Date', self.to_iso, target='to')

    def _pick_date(self, title, current_iso, target='on'):
        # Build an initial ISO that seeds time for range picks
        init_iso = current_iso or ''
        if not init_iso.strip():
            base = parse_iso_or_now('')
            base = base.replace(second=0, microsecond=0)
            if target in ('on', 'from'):
                base = base.replace(hour=0, minute=0)
            else:
                base = base.replace(hour=23, minute=59)
            init_iso = to_iso_seconds(base)

        def _apply(value):
            if value is None:
                return

            if not (value or '').strip():
                if target == 'on':
                    self.on_iso = ''
                    self.on_btn.title = self._title_for('', 'On')
                elif target == 'from':
                    self.from_iso = ''
                    self.from_btn.title = self._title_for('', 'From')
                else:
                    self.to_iso = ''
                    self.to_btn.title = self._title_for('', 'To')
                return

            dt = parse_iso_or_now(value).replace(second=0, microsecond=0)

            # Normalise stored filter times
            if target in ('on', 'from'):
                dt = dt.replace(hour=0, minute=0)        # 12:00 AM default
            else:
                dt = dt.replace(hour=23, minute=59)      # 11:59 PM default

            iso_final = to_iso_seconds(dt)

            if target == 'on':
                self.on_iso = iso_final
                self.on_btn.title = self._title_for(self.on_iso, 'On')
            elif target == 'from':
                self.from_iso = iso_final
                self.from_btn.title = self._title_for(self.from_iso, 'From')
            else:
                self.to_iso = iso_final
                self.to_btn.title = self._title_for(self.to_iso, 'To')

        # On Date -> DATE ONLY, Range -> full DATETIME
        picker_mode = 'date' if target == 'on' else 'datetime'

        picker = DateTimePicker(
            title=title,
            initial_iso=init_iso,
            allow_clear=True,
            min_iso=None,
            mode=picker_mode,
            minute_step=1,
            on_result=_apply
        )
        _safe_push(self.navigation_view, picker)

    def _toggle_empty(self, sender):
        self.include_empty = bool(sender.value)

    # ---- clear/save ----
    def _clear(self, sender):
        self.mode = 'any'
        self.on_iso = ''
        self.from_iso = ''
        self.to_iso = ''
        if self.allow_include_empty:
            self.include_empty = False
            self.empty_sw.value = False

        self._refresh_mode_seg()
        self._refresh_visibility()
        self.on_btn.title = self._title_for('', 'On')
        self.from_btn.title = self._title_for('', 'From')
        self.to_btn.title   = self._title_for('', 'To')

        self._save(sender)

    def _save(self, sender):
        af = self.owner.adv_filter or {}

        if self.kind == 'created':
            af['created_mode'] = self.mode
            af['created_on']   = self.on_iso if self.mode == 'on' else ''
            af['created_from'] = self.from_iso if self.mode == 'range' else ''
            af['created_to']   = self.to_iso if self.mode == 'range' else ''
        else:
            af['due_mode'] = self.mode
            af['due_on']   = self.on_iso if self.mode == 'on' else ''
            af['due_from'] = self.from_iso if self.mode == 'range' else ''
            af['due_to']   = self.to_iso if self.mode == 'range' else ''
            af['due_include_empty'] = bool(self.include_empty)

        af['enabled'] = bool(
            (af.get('name_values') or []) or
            (af.get('created_on') or '').strip() or
            (af.get('created_from') or '').strip() or (af.get('created_to') or '').strip() or
            (af.get('due_on') or '').strip() or
            (af.get('due_from') or '').strip() or (af.get('due_to') or '').strip()
        )

        self.owner.adv_filter = af

        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass

        try:
            haptic_success()
        except Exception:
            pass

        if callable(self.on_done):
            self.on_done()
        if self.navigation_view:
            self.navigation_view.pop_view()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()

# =========================================================
# DETAIL: DONE FILTER
# =========================================================

class DoneFilterDetailView(ui.View):
    def __init__(self, owner, on_done=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Completed / Not'
        self.background_color = 'black'
        self.owner = owner
        self.on_done = on_done
        self.mode = owner.filter_done or 'all'

        self.left_button_items  = [ui.ButtonItem(title='Back', action=self._back)]
        self.right_button_items = [
            ui.ButtonItem(title='Clear', action=self._clear),
            ui.ButtonItem(title='Save',  action=self._save),
        ]

        y = 20
        lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        lbl.text = 'Filter by completed status'
        lbl.text_color = 'white'
        lbl.font = ('<System-Bold>', 18)
        self.add_subview(lbl)
        y += 36

        self.seg = ui.View(frame=(16, y, self.width - 32, 30), flex='W')
        self.add_subview(self.seg)

        self.seg_btns = []
        def make_action(val):
            def a(sender):
                self.mode = val
                self._refresh_seg()
                haptic_selection()
            return a

        for label, val in [('All', 'all'), ('Active', 'active'), ('Done', 'done')]:
            b = ui.Button(title=label, action=make_action(val))
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.5, 0.5, 0.6)
            b.background_color = (0.16, 0.16, 0.18)
            b.tint_color = 'white'
            b.font = ('<System>', 12)
            self.seg.add_subview(b)
            self.seg_btns.append((b, val))

        self._layout_seg()
        self._refresh_seg()

    def layout(self):
        self.seg.width = self.width - 32
        self._layout_seg()

    def _layout_seg(self):
        gap = 6
        n = len(self.seg_btns)
        w = (self.seg.width - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.seg_btns:
            b.frame = (x, 0, w, 30)
            x += w + gap

    def _refresh_seg(self):
        for (b, v) in self.seg_btns:
            if v == self.mode:
                b.background_color = (0.28, 0.28, 0.32)
                b.border_color = hex_to_ui_color('#D4AF37')
            else:
                b.background_color = (0.16, 0.16, 0.18)
                b.border_color = (0.5, 0.5, 0.6)

    def _clear(self, sender):
        self.mode = 'all'
        self._refresh_seg()
        self._save(sender)

    def _save(self, sender):
        self.owner.filter_done = self.mode
        try:
            self.owner.ds.refresh()
            self.owner._rebuild_filter_summary()
            self.owner.table.reload_data()
        except Exception:
            pass
        haptic_success()
        if callable(self.on_done):
            self.on_done()
        if self.navigation_view:
            self.navigation_view.pop_view()

    def _back(self, sender):
        if self.navigation_view:
            self.navigation_view.pop_view()


class DescriptionEditorView(ui.View):
    def __init__(self, text='', on_done=None):
        super().__init__()
        self.name = 'Item Description'
        self.background_color = 'white'
        self.on_done = on_done
        self._orig_text = text or ''

        margin = 12
        top = 12

        self.title_label = ui.Label(frame=(margin, top, self.width - 2*margin, 24), flex='W')
        self.title_label.text = 'Item description'
        self.title_label.font = ('<System-Bold>', 16)
        self.add_subview(self.title_label)
        top += 28

        self.textview = ui.TextView(frame=(margin, top, self.width - 2*margin, self.height - top - 60),
                                    flex='WH')
        self.textview.font = ('<System>', 14)
        self.textview.text = self._orig_text
        self.add_subview(self.textview)

        self.done_btn = ui.Button(title='Save')
        self.done_btn.font = ('<System-Bold>', 16)
        self.done_btn.corner_radius = 8
        self.done_btn.border_width = 1
        self.done_btn.border_color = (0.8, 0.8, 0.85)
        self.done_btn.background_color = (0.96, 0.96, 0.99)
        self.done_btn.tint_color = (0.1, 0.1, 0.2)
        self.done_btn.action = self._action_done
        self.add_subview(self.done_btn)

    def layout(self):
        margin = 12
        self.title_label.frame = (margin, 12, self.width - 2*margin, 24)
        self.textview.frame = (margin, 12 + 28, self.width - 2*margin, self.height - (12 + 28) - 60)
        self.done_btn.frame = (margin, self.height - 44, self.width - 2*margin, 32)

    def _action_done(self, sender):
        txt = self.textview.text or ''
        if self.on_done:
            self.on_done(txt)
        self.close()


# -------------------------
# Links Editor (crash safe)
# -------------------------

class LinksEditorView(ui.View):
    def __init__(self, parent_item, on_update):
        super().__init__()
        self.name = 'Links'
        self.background_color = 'white'
        self.on_update = on_update

        # Make parent_item safe and always a dict
        try:
            if parent_item is None:
                safe_parent = {}
            else:
                safe_parent = ensure_additional_content_fields(parent_item)
        except Exception as e:
            print('ensure_additional_content_fields error in LinksEditorView:', e)
            safe_parent = {}

        if not isinstance(safe_parent, dict):
            safe_parent = {}

        self.parent_item = safe_parent

        # Table
        self.table = ui.TableView()
        self.table.flex = 'WH'
        self.table.data_source = self
        self.table.delegate = self
        self.add_subview(self.table)

        # Add link button
        self.add_btn = ui.Button(title='Add Link')
        self.add_btn.action = self.action_add_link
        self.add_btn.corner_radius = 8
        self.add_btn.border_width = 1
        self.add_btn.border_color = (0.8, 0.8, 0.85)
        self.add_btn.background_color = (0.98, 0.98, 1.0)
        self.add_btn.tint_color = (0.1, 0.1, 0.2)
        self.add_subview(self.add_btn)

    def layout(self):
        # Button at top, table fills the rest
        self.add_btn.frame = (16, 8, self.width - 32, 36)
        self.table.frame = (0, 52, self.width, self.height - 52)

    # Data helpers

    @property
    def _links(self):
        """
        Always return a list stored in self.parent_item['links'].

        If parent_item is bad or links is missing, fix it in place
        so later code can safely mutate it.
        """
        parent = self.parent_item

        # Ensure parent is a dict
        if not isinstance(parent, dict):
            parent = {}
            self.parent_item = parent

        links = parent.get('links')

        # If links missing or wrong type, normalise to a list
        if not isinstance(links, list):
            links = []
            parent['links'] = links

        return links

    # Table data source methods

    def tableview_number_of_sections(self, tv):
        return 1

    def tableview_number_of_rows(self, tv, section):
        try:
            return len(self._links)
        except Exception as e:
            print('LinksEditorView.tableview_number_of_rows error:', e)
            return 0

    def tableview_cell_for_row(self, tv, section, row):
        cell = ui.TableViewCell()
        try:
            link = self._links[row]
        except Exception as e:
            print('LinksEditorView.cell_for_row index error:', e)
            link = {}

        label = link.get('label') or link.get('url') or '(no label)'
        cell.text_label.text = label
        cell.accessory_type = 'detail_disclosure_button'
        return cell

    def tableview_did_select(self, tv, section, row):
        self._edit_link(row)

    def tableview_accessory_button_tapped(self, tv, section, row):
        self._edit_link(row)

    def tableview_can_delete(self, tv, section, row):
        return True

    def tableview_delete(self, tv, section, row):
        links = self._links   # one lookup, keeps reference
        try:
            del links[row]
        except Exception as e:
            print('LinksEditorView.delete error:', e)
            return

        if self.on_update:
            self.on_update()
        self.table.reload_data()

    # Actions

    def action_add_link(self, sender):
        self._edit_link(None)
        
    def _edit_link(self, existing):
        """Create or edit a single link.
    
        existing is either None (new link) or an index into self.links.
        This version is safe if the user cancels a dialog; it just returns.
        """
        # Work out initial values
        label_val = ''
        url_val = ''
        idx = None
    
        if isinstance(existing, int):
            idx = existing
            try:
                link = self.links[idx]
                label_val = link.get('label', '') or ''
                url_val = link.get('url', '') or ''
            except Exception:
                pass
    
        # Prompt user for label and URL; quietly exit if they cancel
        try:
            if hasattr(dialogs, 'input_alert'):
                label = dialogs.input_alert('Link label', '', label_val)
                if label is None:
                    return  # user cancelled in some implementations
                url = dialogs.input_alert('Link URL', '', url_val)
                if url is None:
                    return
            else:
                # Fallback; no editing if dialogs not available
                label = label_val
                url = url_val
        except KeyboardInterrupt:
            # User cancelled either dialog; don't treat as an error
            return
        except Exception:
            # Any other dialog-related failure; also just bail out
            return
    
        label = (label or '').strip()
        url = (url or '').strip()
        if not url:
            # Don't save empty URLs
            return
    
        new_link = {'label': label, 'url': url}
    
        if idx is None:
            self.links.append(new_link)
        else:
            self.links[idx] = new_link
    
        # Notify parent and refresh view
        if callable(self.on_update):
            self.on_update()
    
        self.table.reload_data()


# -------------------------
# Additional Content UI: Menu
# -------------------------

class AdditionalContentMenuView(ui.View):
    def __init__(self, parent_item, on_update):
        super().__init__()
        self.name = 'Additional Content'
        self.background_color = 'white'

        # Make sure we always have a mutable dict to work with.
        # If this is called from a "New Entry" flow with no item yet,
        # parent_item might be None. In that case, use an empty dict.
        if parent_item is None:
            parent_item = {}

        # Ensure description / media / links keys all exist
        ensure_additional_content_fields(parent_item)

        # Store the same dict so edits mutate the original item
        self.parent_item = parent_item
        self.on_update = on_update

        lbl = ui.Label(frame=(16, 10, self.width - 32, 24), flex='W')
        lbl.text = 'Add or edit extra content for this item'
        lbl.font = ('<System>', 14)
        lbl.text_color = (0.2, 0.2, 0.25)
        self.add_subview(lbl)

        self.btn_desc = self._make_btn('Description', self.action_desc)
        self.btn_photos = self._make_btn('Photo/s', self.action_photos)
        self.btn_videos = self._make_btn('Video/s', self.action_videos)
        self.btn_links = self._make_btn('Links', self.action_links)

        for b in (self.btn_desc, self.btn_photos, self.btn_videos, self.btn_links):
            self.add_subview(b)

    def _make_btn(self, title, action):
        b = ui.Button()
        b.title = title
        b.action = action
        b.corner_radius = 8
        b.border_width = 1
        b.border_color = (0.85, 0.85, 0.9)
        b.background_color = (0.98, 0.98, 1.0)
        b.tint_color = (0.1, 0.1, 0.2)
        return b

    def layout(self):
        y = 44
        gap = 12
        w = self.width - 32
        for b in (self.btn_desc, self.btn_photos, self.btn_videos, self.btn_links):
            b.frame = (16, y, w, 40)
            y += 40 + gap

    # Open sub-editors

    def action_desc(self, sender):
        v = DescriptionEditorView(self.parent_item.get('description', ''),
                                  on_save=self._save_description)
        _safe_push(self.navigation_view, v)

    def _save_description(self, new_text):
        self.parent_item['description'] = new_text
        ensure_additional_content_fields(self.parent_item)
        if self.on_update:
            self.on_update(self.parent_item)

    def action_photos(self, sender):
        v = MediaEditorView(self.parent_item, media_type='image', on_update=self._media_updated)
        _safe_push(self.navigation_view, v)

    def action_videos(self, sender):
        v = MediaEditorView(self.parent_item, media_type='video', on_update=self._media_updated)
        _safe_push(self.navigation_view, v)

    def _media_updated(self):
        ensure_additional_content_fields(self.parent_item)
        if self.on_update:
            self.on_update(self.parent_item)

    def action_links(self, sender):
        v = LinksEditorView(self.parent_item, on_update=self._links_updated)
        _safe_push(self.navigation_view, v)

    def _links_updated(self):
        ensure_additional_content_fields(self.parent_item)
        if self.on_update:
            self.on_update(self.parent_item)


# -------------------------
# Description Editor (rich-text via markup)
# -------------------------

class DescriptionEditorView(ui.View):
    def __init__(self, initial_text, on_save):
        super().__init__()
        self.name = 'Description'
        self.background_color = 'white'
        self.on_save = on_save

        self.toolbar = ui.View()
        self.toolbar.background_color = (0.95, 0.95, 0.97)
        self.add_subview(self.toolbar)

        # Formatting buttons
        self.btn_bold = self._make_btn('B', self._fmt_bold)
        self.btn_italic = self._make_btn('I', self._fmt_italic)
        self.btn_underline = self._make_btn('U', self._fmt_underline)
        self.btn_bullet = self._make_btn('•', self._fmt_bullet)
        self.btn_highlight = self._make_btn('HL', self._fmt_highlight)

        for b in (self.btn_bold, self.btn_italic, self.btn_underline, self.btn_bullet, self.btn_highlight):
            self.toolbar.add_subview(b)

        # Text area
        self.textview = ui.TextView()
        self.textview.text = initial_text or ''
        self.textview.flex = 'WH'
        self.textview.font = ('<System>', 14)
        self.add_subview(self.textview)

        # Save button
        self.save_btn = ui.Button(title='Save')
        self.save_btn.action = self.action_save
        self.save_btn.corner_radius = 8
        self.save_btn.border_width = 1
        self.save_btn.border_color = (0.8, 0.8, 0.85)
        self.save_btn.background_color = (0.98, 0.98, 1.0)
        self.save_btn.tint_color = (0.1, 0.1, 0.2)
        self.add_subview(self.save_btn)

    def _make_btn(self, title, action):
        b = ui.Button(title=title)
        b.action = action
        b.font = ('<System-Bold>', 14)
        b.corner_radius = 6
        b.border_width = 1
        b.border_color = (0.8, 0.8, 0.85)
        b.background_color = (1, 1, 1)
        b.tint_color = (0.1, 0.1, 0.2)
        return b

    def layout(self):
        tb_h = 40
        self.toolbar.frame = (0, 0, self.width, tb_h)
        # Layout toolbar buttons
        btns = [self.btn_bold, self.btn_italic, self.btn_underline, self.btn_bullet, self.btn_highlight]
        x = 8
        for b in btns:
            b.frame = (x, 6, 40, tb_h - 12)
            x += 44
        # Save button at top-right
        self.save_btn.frame = (self.width - 70, 6, 62, tb_h - 12)
        # Text area
        self.textview.frame = (0, tb_h, self.width, self.height - tb_h)

    # Formatting helpers (wrap selection with tags)

    def _wrap_selection(self, prefix, suffix=None):
        tv = self.textview
        if suffix is None:
            suffix = prefix
        sel_start, sel_end = tv.selected_range
        text = tv.text or ''
        if sel_start == sel_end:
            # No selection, insert tags and place cursor between
            tv.text = text[:sel_start] + prefix + suffix + text[sel_end:]
            tv.selected_range = (sel_start + len(prefix), sel_start + len(prefix))
        else:
            selected = text[sel_start:sel_end]
            new = prefix + selected + suffix
            tv.text = text[:sel_start] + new + text[sel_end:]
            tv.selected_range = (sel_start, sel_start + len(new))

    def _fmt_bold(self, sender):
        self._wrap_selection('*')

    def _fmt_italic(self, sender):
        self._wrap_selection('_')

    def _fmt_underline(self, sender):
        self._wrap_selection('~')

    def _fmt_bullet(self, sender):
        tv = self.textview
        sel_start, sel_end = tv.selected_range
        text = tv.text or ''
        # Insert bullet at beginning of the current line
        line_start = text.rfind('\n', 0, sel_start) + 1
        tv.text = text[:line_start] + '• ' + text[line_start:]
        offset = 2
        tv.selected_range = (sel_start + offset, sel_end + offset)

    def _fmt_highlight(self, sender):
        self._wrap_selection('==')

    def action_save(self, sender):
        if self.on_save:
            self.on_save(self.textview.text or '')
        if self.navigation_view:
            self.navigation_view.pop_view()
        else:
            self.close()


# -------------------------
# Item Details (view/edit)
# -------------------------
class ItemDetailView(ui.View):
    def __init__(self, item, categories, on_save=None, on_cats_change=None):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'Item Details'
        self.background_color = 'white'
        self.item = item
        self.categories = categories
        self.on_save = on_save
        self.on_cats_change = on_cats_change

        self.editing_enabled = False
        self._snapshot = None
        self._working = None
        self._renaming = False

        self._btn_back = ui.ButtonItem(title='Back', action=self._back)
        self._btn_edit = ui.ButtonItem(title='Edit', action=self._toggle_edit)
        self.right_button_items = [self._btn_edit]
        self.left_button_items = [self._btn_back]

        y = 16
        self.title_lbl = ui.Label(frame=(16, y, self.width - 32, 32), flex='W')
        self.title_lbl.font = ('<System-Bold>', 24)
        self.add_subview(self.title_lbl)
        y += 40

        self.cat_lbl = ui.Label(frame=(16, y, self.width - 32, 24), flex='W')
        self.cat_lbl.font = ('<System>', 16)
        self.add_subview(self.cat_lbl)
        y += 30

        self.swatch = ui.View(frame=(16, y, 64, 32))
        self.swatch.corner_radius = 8
        self.swatch.border_width = 1
        self.swatch.border_color = (0.8, 0.8, 0.8)
        self.add_subview(self.swatch)

        self.btn_change_color = ui.Button(frame=(96, y, 140, 32))
        self.btn_change_color.title = 'Change Colour'
        self.btn_change_color.action = self._change_colour
        self._style_btn(self.btn_change_color)
        self.add_subview(self.btn_change_color)

        self.btn_rename_cat = ui.Button(frame=(244, y, 140, 32))
        self.btn_rename_cat.title = 'Rename Category'
        self.btn_rename_cat.action = self._rename_category
        self._style_btn(self.btn_rename_cat)
        self.add_subview(self.btn_rename_cat)

        y += 48
        self.name_lbl = ui.Label(frame=(16, y, 100, 22))
        self.name_lbl.text = 'Name'
        self.name_lbl.font = ('<System-Bold>', 16)
        self.add_subview(self.name_lbl)

        self.name_tf = ui.TextField(frame=(16, y + 28, self.width - 32, 32), flex='W')
        self.name_tf.placeholder = 'Item name'
        self.name_tf.clear_button_mode = 'while_editing'
        self.add_subview(self.name_tf)

        y += 72
        self.created_lbl = ui.Label(frame=(16, y, 200, 22))
        self.created_lbl.text = 'Created At'
        self.created_lbl.font = ('<System-Bold>', 16)
        self.add_subview(self.created_lbl)

        self.created_value = ui.Label(frame=(16, y + 24, self.width - 32 - 160, 24), flex='W')
        self.add_subview(self.created_value)

        self.btn_change_created = ui.Button(frame=(self.width - 16 - 150, y + 18, 150, 32), flex='L')
        self.btn_change_created.title = 'Change Date/Time'
        self.btn_change_created.action = self._change_created_at
        self._style_btn(self.btn_change_created)
        self.add_subview(self.btn_change_created)

        tappable_w = self.width - 32 - 160 - 8
        self.created_row_tap = ui.Button(frame=(16, y, tappable_w, 54), flex='W')
        self.created_row_tap.background_color = (0, 0, 0, 0)
        self.created_row_tap.action = self._change_created_at
        self.created_row_tap.tint_color = (0, 0, 0, 0)
        self.add_subview(self.created_row_tap)

        y += 66
        self.due_lbl = ui.Label(frame=(16, y, 200, 22))
        self.due_lbl.text = 'Due'
        self.due_lbl.font = ('<System-Bold>', 16)
        self.add_subview(self.due_lbl)

        self.due_value = ui.Label(frame=(16, y + 24, self.width - 32 - 160, 24), flex='W')
        self.add_subview(self.due_value)

        self.btn_change_due = ui.Button(frame=(self.width - 16 - 150, y + 18, 150, 32), flex='L')
        self.btn_change_due.title = 'Change Date/Time'
        self.btn_change_due.action = self._change_due_at
        self._style_btn(self.btn_change_due)
        self.add_subview(self.btn_change_due)

        tappable_w = self.width - 32 - 160 - 8
        self.due_row_tap = ui.Button(frame=(16, y, tappable_w, 54), flex='W')
        self.due_row_tap.background_color = (0, 0, 0, 0)
        self.due_row_tap.action = self._change_due_at
        self.due_row_tap.tint_color = (0, 0, 0, 0)
        self.add_subview(self.due_row_tap)

        y += 66
        self.done_lbl = ui.Label(frame=(16, y, 120, 22))
        self.done_lbl.text = 'Completed'
        self.add_subview(self.done_lbl)

        self.done_sw = ui.Switch(frame=(140, y - 6, 51, 31))
        self.done_sw.action = self._on_done_toggled
        self.add_subview(self.done_sw)

        self.done_status_lbl = ui.Label(frame=(200, y, self.width - 216, 22), flex='W')
        self.done_status_lbl.font = ('<System>', 14)
        self.add_subview(self.done_status_lbl)

        self.done_tap = ui.Button(frame=self.done_lbl.frame)
        self.done_tap.background_color = (0, 0, 0, 0)
        self.done_tap.action = self._toggle_done_from_label
        self.add_subview(self.done_tap)

        # --- Additional Content: button + card section ---
        self.content_section_title = ui.Label(frame=(16, y + 60, self.width - 32, 22), flex='W')
        self.content_section_title.text = 'Additional content'
        self.content_section_title.font = ('<System-Bold>', 16)
        self.add_subview(self.content_section_title)

        # Main button for the new model
        self.btn_more_content = ui.Button(title='Add more content')
        self.btn_more_content.action = self.action_add_more_content
        self.btn_more_content.corner_radius = 8
        self.btn_more_content.border_width = 1
        self.btn_more_content.border_color = (0.8, 0.8, 0.85)
        self.btn_more_content.background_color = (0.98, 0.98, 1.0)
        self.btn_more_content.tint_color = (0.1, 0.1, 0.2)
        self.add_subview(self.btn_more_content)

        # Card that shows description + media summary + links
        self.additional_content_view = ui.View()
        self.additional_content_view.background_color = (0.97, 0.97, 0.99)
        self.additional_content_view.corner_radius = 8
        self.additional_content_view.border_width = 1
        self.additional_content_view.border_color = (0.9, 0.9, 0.93)
        self.add_subview(self.additional_content_view)

        # Inside the card: description label
        self._desc_label = ui.Label()
        self._desc_label.font = ('<System>', 14)
        self._desc_label.number_of_lines = 0
        self.additional_content_view.add_subview(self._desc_label)

        # Media summary label
        self._media_label = ui.Label()
        self._media_label.font = ('<System>', 13)
        self._media_label.text_color = (0.3, 0.3, 0.4)
        self.additional_content_view.add_subview(self._media_label)

        # Links stack (container view that will hold link buttons)
        self._links_stack = ui.View()
        self.additional_content_view.add_subview(self._links_stack)

        # Ensure the item has the extra fields (description/media/links)
        ensure_additional_content_fields(self.item)
        self._refresh_additional_content_display()

        # Load initial state
        self._load_from_item()
        self._apply_edit_state()
        self.done_sw.bring_to_front()

    def _style_btn(self, b):
        b.corner_radius = 6
        b.border_width = 1
        b.border_color = (0.8, 0.8, 0.8)
        b.background_color = (0.95, 0.95, 0.97)
        b.font = ('<System>', 14)

    def _display_category_name(self, hex_color):
        """Return the display name for a category colour.

        Your app stores categories as a dict: {hex: name}, so we use that first.
        We also include a fallback for any older list-of-dicts format, just in case.
        """
        # Normal path: dict of {hex: name}
        if isinstance(self.categories, dict):
            nm = (self.categories.get(hex_color) or '').strip()
            return nm if nm else 'Uncategorised'

        # Fallback: list of dicts with {'color': ..., 'name': ...}
        try:
            for c in self.categories:
                if isinstance(c, dict) and c.get('color') == hex_color:
                    nm = (c.get('name') or '').strip()
                    return nm if nm else 'Uncategorised'
        except Exception:
            pass

        return 'Uncategorised'

    def _rename_category(self, sender):
        """Use the existing reuse_rename_category helper to rename a category.

        This works with your categories dict and keeps everything in sync with
        the rest of the app.
        """
        if not self.editing_enabled or self._renaming:
            return

        # Current colour hex for this item
        hx = (self._working['color'] if self._working is not None
              else self.item.get('color', '#8E8E93'))

        self._renaming = True

        @ui.in_background
        def _worker():
            changed = False
            try:
                # This helper already knows how to rename categories in your dict
                changed = reuse_rename_category(
                    hx,
                    self.categories,
                    _PALETTE,
                    title_prefix='Rename'
                )
            finally:
                def _apply():
                    self._renaming = False
                    if changed:
                        # Let the owner know categories changed
                        if callable(self.on_cats_change):
                            self.on_cats_change(self.categories)

                        # Refresh the current view from working/snapshot state
                        state = self._working if self._working else self._snapshot_from_item()
                        self._load_from_state(state)
                        dialogs.hud_alert('Category updated', 'success', 0.6)
                ui.delay(_apply, 0.0)

        _worker()

    def layout(self):
        self.title_lbl.width = self.width - 32
        self.name_tf.width = self.width - 32
        self.created_value.width = self.width - 32 - 160
        self.btn_change_created.frame = (self.width - 16 - 150, self.created_value.y - 6, 150, 32)
        self.due_value.width = self.width - 32 - 160
        self.btn_change_due.frame = (self.width - 16 - 150, self.due_value.y - 6, 150, 32)
        self.done_tap.frame = self.done_lbl.frame
        self.created_value.width = self.width - 32 - 160
        self.btn_change_created.frame = (self.width - 16 - 150, self.created_value.y - 6, 150, 32)
        tappable_w = self.width - 32 - 160 - 8
        self.created_row_tap.frame = (16, self.created_lbl.y, tappable_w, 54)

        # --- Layout for Additional Content ---
        btn_h = 36

        # Position the button a bit below the "Completed" row
        top_y = self.done_lbl.frame[1] + 60
        self.btn_more_content.frame = (16, top_y, self.width - 32, btn_h)

        # Card fills remaining height with padding
        ac_top = top_y + btn_h + 8
        ac_h = self.height - ac_top - 16
        if ac_h < 80:
            ac_h = 80
        self.additional_content_view.frame = (16, ac_top, self.width - 32, ac_h)

        # Inside additional_content_view: stack description, media label, links
        inner_w = self.additional_content_view.width - 24
        y = 8

        # Description
        self._desc_label.frame = (12, y, inner_w, 0)
        self._desc_label.size_to_fit()
        y = self._desc_label.y + self._desc_label.height + 8

        # Media summary
        self._media_label.frame = (12, y, inner_w, 18)
        y += 22

        # Links stacked as buttons
        self._links_stack.frame = (12, y, inner_w, self.additional_content_view.height - y - 8)
        for i, v in enumerate(list(self._links_stack.subviews)):
            v.frame = (0, i * 30, inner_w, 28)

        # --- Additional Content logic ---

    # --- Additional Content logic ---

    def action_add_more_content(self, sender):
        """Open the AdditionalContentMenuView to edit description, media and links."""
        # Make sure the item has the extra fields
        ensure_additional_content_fields(self.item)

        menu = AdditionalContentMenuView(self.item,
                                         on_update=self._on_additional_content_updated)
        if self.navigation_view:
            _safe_push(self.navigation_view, menu)
        else:
            nav = ui.NavigationView(menu)
            nav.present('sheet')

    def _on_additional_content_updated(self, updated_item):
        """
        Callback from AdditionalContentMenuView and its sub-editors.

        The editor views mutate the item in-place, but we still:
          - re-ensure the extra fields
          - update self.item
          - persist the owner's items list
          - refresh the summary card and layout
        """
        ensure_additional_content_fields(updated_item)
        self.item = updated_item

        # If this detail view has an external save callback (for synced edit),
        # call it so the parent list / owner can react.
        if hasattr(self, 'on_save') and callable(self.on_save):
            self.on_save(self.item)

        # Persist to disk if we know about the owning app/items
        if hasattr(self, 'owner') and hasattr(self.owner, 'items'):
            save_items(self.owner.items)

        # Refresh the "Additional content" summary card
        self._refresh_additional_content_display()
        self.set_needs_display()
        self.layout()  # force layout refresh so the card resizes to content

    def _strip_description_markup(self, text):
        """
        Basic cleanup of lightweight formatting markers used in DescriptionEditorView.

        This keeps the summary card readable by stripping simple * _ ~ and
        ==highlight== markers.
        """
        if not text:
            return ''
        # Remove simple bold/italic/underline-like markers
        for ch in ('*', '_', '~'):
            text = text.replace(ch, '')
        # Replace ==highlight== markers with plain text
        text = text.replace('==', '')
        return text

    def _refresh_additional_content_display(self):
        """
        Refresh the content of the Additional Content card based on self.item.

        Shows:
          - Description text or "(none)"
          - A media summary ("2 photo(s), 1 video(s)" etc) or "(none)"
          - A stack of buttons for each link, clickable to open/copy.
        """
        ensure_additional_content_fields(self.item)

        desc = (self.item.get('description') or '').strip()
        links = self.item.get('links') or []
        media = self.item.get('media') or []

        # --- Description ---
        if desc:
            cleaned = self._strip_description_markup(desc)
            self._desc_label.text = 'Description:\n' + cleaned
        else:
            self._desc_label.text = 'Description: (none)'

        # --- Media summary ---
        if media:
            img_count = sum(1 for m in media
                            if isinstance(m, dict) and m.get('type') == 'image')
            vid_count = sum(1 for m in media
                            if isinstance(m, dict) and m.get('type') == 'video')
            parts = []
            if img_count:
                parts.append(f'{img_count} photo(s)')
            if vid_count:
                parts.append(f'{vid_count} video(s)')
            self._media_label.text = 'Media: ' + ', '.join(parts)
        else:
            self._media_label.text = 'Media: (none)'

        # --- Links stack ---
        # Clear old buttons
        for v in list(self._links_stack.subviews):
            self._links_stack.remove_subview(v)

        if links:
            for idx, ln in enumerate(links):
                if not isinstance(ln, dict):
                    continue
                b = ui.Button()
                label = ln.get('label') or ln.get('url') or f'Link {idx+1}'
                b.title = label
                b.alignment = ui.ALIGN_LEFT
                b.tint_color = (0, 0.2, 0.6)
                b.background_color = (1, 1, 1)
                b.corner_radius = 6
                b.border_width = 1
                b.border_color = (0.85, 0.85, 0.9)
                b.font = ('<System>', 13)
                b.content_edge_insets = (0, 8, 0, 8)
                b.action = self._make_link_tap_handler(ln)
                self._links_stack.add_subview(b)

    def _make_link_tap_handler(self, link_dict):
        """
        Return a handler that shows options for the given link:
          - Open link
          - Copy URL
          - Copy label
        """
        def handler(sender):
            label = (link_dict.get('label') or link_dict.get('url') or '').strip()
            url = (link_dict.get('url') or '').strip()

            choices = []
            if url:
                choices.append('Open link')
                choices.append('Copy URL')
            if label:
                choices.append('Copy label')
            choices.append('Cancel')

            choice = dialogs.list_dialog('Link', choices)
            if choice == 'Open link' and url:
                webbrowser.open(url)
            elif choice == 'Copy URL' and url:
                clipboard.set(url)
                dialogs.hud_alert('URL copied', 'success', 0.6)
            elif choice == 'Copy label' and label:
                clipboard.set(label)
                dialogs.hud_alert('Label copied', 'success', 0.6)

        return handler

    def _load_from_state(self, state):
        # Category colour
        hx = state.get('color') or '#8E8E93'
        try:
            self.swatch.background_color = hex_to_ui_color(hx)
        except Exception:
            self.swatch.background_color = 'white'
        self.cat_lbl.text = f'Category: {self._display_category_name(hx)}'
        self.name_tf.text = state.get('title', '')
        self.created_value.text = _fmt_dt_for_label(state.get('created_at', ''))
        self.due_value.text = _fmt_dt_for_label(state.get('due_at', ''))
        dv = bool(state.get('done', False))
        self.done_sw.value = dv
        self._update_done_status_text(dv)

        # Additional content card always uses self.item; refresh it
        self._refresh_additional_content_display()

    def _update_done_status_text(self, done_bool):
        if done_bool:
            self.done_status_lbl.text = 'Marked as completed'
            self.done_status_lbl.text_color = (0.1, 0.5, 0.1)
        else:
            self.done_status_lbl.text = 'Not completed'
            self.done_status_lbl.text_color = (0.4, 0.4, 0.4)

    def _load_from_item(self):
        self._load_from_state(self.item)

    def _apply_edit_state(self):
        e = self.editing_enabled
        self.name_tf.enabled = e
        self.btn_change_color.enabled = e
        self.btn_rename_cat.enabled = e
        self.btn_change_created.enabled = e
        self.btn_change_due.enabled = e
        self.done_sw.enabled = e
        self.done_sw.touch_enabled = e
        self.done_sw.alpha = 1.0 if e else 0.5
        self.done_tap.enabled = e
        self.done_tap.touch_enabled = e
        self._btn_edit.title = 'Save' if e else 'Edit'

    def _snapshot_from_item(self):
        return {
            'title': self.item.get('title', ''),
            'created_at': self.item.get('created_at', ''),
            'due_at': self.item.get('due_at', ''),
            'done': bool(self.item.get('done', False)),
            'color': self.item.get('color', '#8E8E93'),
        }

    def _state_from_ui(self):
        in_edit = self.editing_enabled and (self._working is not None)
        color = (self._working.get('color') if in_edit else self.item.get('color'))
        done = (bool(self._working.get('done')) if in_edit else bool(self.done_sw.value))
        created_at = (self._working.get('created_at') if in_edit else self.item.get('created_at', ''))
        due_at = (self._working.get('due_at') if in_edit else self.item.get('due_at', ''))
        return {
            'title': (self.name_tf.text or '').strip(),
            'created_at': created_at or '',
            'due_at': due_at or '',
            'done': done,
            'color': color or '#8E8E93',
        }

    def _has_pending_changes(self):
        if not self.editing_enabled or not self._snapshot:
            return False
        cur = self._state_from_ui()
        snap = self._snapshot
        return any(cur[k] != snap.get(k) for k in ('title', 'created_at', 'due_at', 'done', 'color'))

    def _back(self, sender):
        if not self.editing_enabled:
            if self.navigation_view:
                self.navigation_view.pop_view()
            else:
                self.close()
            return
        if not self._has_pending_changes():
            self.editing_enabled = False
            self._working = None
            self._snapshot = None
            self._load_from_item()
            self._apply_edit_state()
            if self.navigation_view:
                self.navigation_view.pop_view()
            else:
                self.close()
            return
        b = dialogs.alert('Discard changes?', '', 'Discard', 'Cancel', hide_cancel_button=False)
        if b == 1:
            self.editing_enabled = False
            self._working = None
            self._snapshot = None
            self._load_from_item()
            self._apply_edit_state()
            if self.navigation_view:
                self.navigation_view.pop_view()
            else:
                self.close()

    def _toggle_edit(self, sender):
        if not self.editing_enabled:
            self.editing_enabled = True
            self._snapshot = self._snapshot_from_item()
            self._working = dict(self._snapshot)
            self._apply_edit_state()
        else:
            state = self._state_from_ui()
            self.item['title'] = state['title']
            self.item['created_at'] = state['created_at']
            self.item['due_at'] = state['due_at']
            self.item['done'] = state['done']
            self.item['color'] = state['color']
            if callable(self.on_save):
                self.on_save(self.item)
            self.editing_enabled = False
            self._working = None
            self._snapshot = None
            self._load_from_item()
            self._apply_edit_state()
            dialogs.hud_alert('Saved', 'success', 0.6)

    def _on_done_toggled(self, sender):
        if not self.editing_enabled:
            sender.value = bool(self.item.get('done', False))
            dialogs.hud_alert('Tap Edit to change.', 'warning', 0.6)
            return
        self._ensure_working()
        self._working['done'] = bool(sender.value)
        self._update_done_status_text(self._working['done'])
        haptic_success()

    def _toggle_done_from_label(self, sender):
        if not self.editing_enabled:
            dialogs.hud_alert('Tap Edit to change.', 'warning', 0.6)
            return
        self._ensure_working()
        new_val = not bool(self._working.get('done', False))
        self._working['done'] = new_val
        self.done_sw.value = new_val
        self._update_done_status_text(new_val)
        haptic_success()

    def _ensure_working(self):
        if self._working is None:
            self._working = self._snapshot_from_item()

    def _change_colour(self, sender):
        if not self.editing_enabled:
            dialogs.hud_alert('Tap Edit to change colour.', 'warning', 0.6)
            return
        def picked(hex_val, _label):
            self._ensure_working()
            self._working['color'] = hex_val
            self._load_from_state(self._working)
        picker = ColorPicker(_PALETTE, self.categories, on_pick=picked, title='Pick a Colour')
        if self.navigation_view:
            _safe_push(self.navigation_view, picker)
        else:
            ui.NavigationView(picker).present('fullscreen')

    def _change_created_at(self, sender):
        if not self.editing_enabled:
            return
        cur = (self._working.get('created_at') if self._working else self.item.get('created_at', ''))
        self._pick_dt('Set Created', cur, allow_clear=False, set_field_key='created_at')

    def _change_due_at(self, sender):
        if not self.editing_enabled:
            return
        cur = (self._working.get('due_at') if self._working else self.item.get('due_at', ''))
        self._pick_dt('Set Due Date', cur, allow_clear=True, set_field_key='due_at')

# -------------------------
# New Entry (black) — Due date with new picker
# -------------------------
class NewEntryView(ui.View):
    def __init__(self, on_save, cats):
        super().__init__(frame=(0, 0, 540, 720))
        self.name = 'New Entry'
        self.background_color = 'black'
        self.on_save = on_save
        self.cats = cats
        self.selected_hex = '#007AFF'
        self.selected_name = 'blue'
        self.due_at_iso = ''
        
        # Extra content fields
        self.description_text = ''
        self.photos = []
        self.videos = []
        self.links = []

        # Panel state for "Add more content"
        self.more_panel_visible = False

        self.lbl = ui.Label(frame=(16, 5, self.width - 32, 60), flex='W')
        self.lbl.font = ('Arial-BoldMT', 36)
        self.lbl.text = 'New Entry'
        self.lbl.text_color = hex_to_ui_color('#D4AF37')
        self.lbl.alignment = ui.ALIGN_LEFT
        self.add_subview(self.lbl)
        
        self.name_lbl = ui.Label(frame=(16, 90, 120, 30))
        self.name_lbl.text = 'Name'
        self.name_lbl.text_color = 'white'
        self.name_lbl.font = ('<system-bold>', 16)  # correct bold system font
        self.add_subview(self.name_lbl)
        
        
        self.name_tf = ui.TextField(frame=(16, 120, self.width - 32, 40), flex='W')
        self.name_tf.placeholder = 'Enter task name...'
        self.name_tf.clear_button_mode = 'while_editing'
        self.name_tf.background_color = 'white'
        self.name_tf.text_color = 'black'
        self.name_tf.tint_color = 'black'
        self.name_tf.corner_radius = 8
        self.add_subview(self.name_tf)

        self.color_lbl = ui.Label(frame=(16, 174, 120, 30))
        self.color_lbl.text = 'Colour'
        self.color_lbl.text_color = 'white'
        self.add_subview(self.color_lbl)
        self.color_lbl.font = ('<system-bold>',16)

        self.swatch = ui.View(frame=(16, 206, 60, 36))
        self.swatch.border_width = 1
        self.swatch.corner_radius = 6
        self.swatch.border_color = (0.9, 0.9, 0.9)
        self._update_swatch(self.selected_hex)
        self.add_subview(self.swatch)

        self.pick_btn = ui.Button(frame=(90, 206, 170, 36))
        self.pick_btn.title = 'Choose Colour'
        self.pick_btn.action = self.choose_colour
        self._style_button(self.pick_btn)
        self.add_subview(self.pick_btn)

        self.cat_lbl = ui.Label(frame=(16, 250, self.width - 32, 24), flex='W')
        self.cat_lbl.text_color = 'white'
        self._refresh_category_label()
        self.add_subview(self.cat_lbl)

        y = 280
        self.due_lbl = ui.Label(frame=(16, y, 120, 30))
        self.due_lbl.text = 'Due'
        self.due_lbl.text_color = 'white'
        self.due_lbl.font = ('<system-bold>', 16)
        self.add_subview(self.due_lbl)

        self.due_value = ui.Label(frame=(16, y + 28, self.width - 32 - 180, 24), flex='W')
        self.due_value.text = _fmt_dt_for_label('')
        self.due_value.text_color = 'white'
        self.add_subview(self.due_value)

        self.due_btn = ui.Button(frame=(self.width - 16 - 160, y + 22, 160, 36), flex='L')
        self.due_btn.title = 'Set Due...'
        self.due_btn.action = self._set_due
        self._style_button(self.due_btn)
        self.add_subview(self.due_btn)

        # "Add more content" button
        y_more = self.due_btn.frame[1] + 56
        self.more_btn = ui.Button(frame=(16, y_more, self.width - 32, 36), flex='W')
        self.more_btn.title = 'Add more content'
        self._style_button(self.more_btn)
        self.more_btn.action = self._toggle_more_panel
        self.add_subview(self.more_btn)

        # Hidden panel that drops down with options
        self.more_panel = ui.View(frame=(16, y_more + 44, self.width - 32, 140), flex='W')
        self.more_panel.background_color = (0.12, 0.12, 0.12)
        self.more_panel.corner_radius = 8
        self.more_panel.hidden = True
        self.add_subview(self.more_panel)

        option_y = 8
        self.btn_more_desc = ui.Button(frame=(8, option_y, self.more_panel.width - 16, 30),
                                       flex='W')
        self.btn_more_desc.title = 'Item description'
        self._style_button(self.btn_more_desc)
        self.btn_more_desc.action = self._edit_description
        self.more_panel.add_subview(self.btn_more_desc)
        option_y += 34

        self.btn_more_photos = ui.Button(frame=(8, option_y, self.more_panel.width - 16, 30),
                                         flex='W')
        self.btn_more_photos.title = 'Photo/s'
        self._style_button(self.btn_more_photos)
        self.btn_more_photos.action = self._add_photo_note
        self.more_panel.add_subview(self.btn_more_photos)
        option_y += 34

        self.btn_more_videos = ui.Button(frame=(8, option_y, self.more_panel.width - 16, 30),
                                         flex='W')
        self.btn_more_videos.title = 'Video/s'
        self._style_button(self.btn_more_videos)
        self.btn_more_videos.action = self._add_video_note
        self.more_panel.add_subview(self.btn_more_videos)
        option_y += 34

        self.btn_more_links = ui.Button(frame=(8, option_y, self.more_panel.width - 16, 30),
                                        flex='W')
        self.btn_more_links.title = 'Links'
        self._style_button(self.btn_more_links)
        self.btn_more_links.action = self._add_link
        self.more_panel.add_subview(self.btn_more_links)

        self.left_button_items = [ui.ButtonItem(title='Cancel', action=self.cancel)]
        self.right_button_items = [ui.ButtonItem(title='Save', action=self.save)]
        
                # Shared dict that holds additional content, same format as real items
        self.extra_item = {}
        ensure_additional_content_fields(self.extra_item)

        # Optional: a short summary label in the UI that you will update
        self.extra_summary_label = ui.Label()
        self.extra_summary_label.font = ('<System>', 12)
        self.extra_summary_label.text_color = (0.4, 0.4, 0.45)
        
        self._setup_additional_content_summary()
        self.add_subview(self.extra_summary_label)

    def layout(self):
        self.lbl.width = self.width - 32
        self.name_tf.width = self.width - 32
        self.cat_lbl.width = self.width - 32
        self.due_value.width = self.width - 32 - 180
        self.due_btn.frame = (self.width - 16 - 160, self.due_value.y - 6, 160, 36)

    def _style_button(self, btn):
        btn.tint_color = 'white'
        btn.border_width = 1
        btn.corner_radius = 8
        btn.border_color = (0.9, 0.9, 0.9)
        btn.background_color = (0.12, 0.12, 0.12)

    def _update_swatch(self, hexc):
        try:
            self.swatch.background_color = hex_to_ui_color(hexc)
        except Exception:
            self.swatch.background_color = 'white'

    def _refresh_category_label(self):
        cat = (self.cats.get(self.selected_hex, '') or '').strip()
        self.cat_lbl.text = f'Category: {cat if cat else "No category"}'

    def choose_colour(self, sender):
        def picked(hex_val, label):
            self.selected_hex = hex_val
            self.selected_name = label
            self._update_swatch(hex_val)
            self._refresh_category_label()
        picker = ColorPicker(_PALETTE, self.cats, on_pick=picked, title='Pick a Colour')
        if self.navigation_view:
            _safe_push(self.navigation_view, picker)
        else:
            ui.NavigationView(picker).present('fullscreen')

    def _set_due(self, sender):
        def _apply(value):
            if value is None:
                return
            self.due_at_iso = value
            self.due_value.text = _fmt_dt_for_label(value)
        picker = DateTimePicker(
            title='Set Due Date',
            initial_iso=self.due_at_iso,
            allow_clear=True,
            min_iso=None,
            mode='datetime',
            minute_step=1,
            on_result=_apply
        )
        if self.navigation_view:
            _safe_push(self.navigation_view, picker)
        else:
            ui.NavigationView(picker).present('fullscreen')
            
    def _toggle_more_panel(self, sender):
        self.more_panel_visible = not self.more_panel_visible
        self.more_panel.hidden = not self.more_panel_visible

    def _edit_description(self, sender):
        initial = self.description_text or ''
        text = dialogs.text_dialog(title='Item description', text=initial)
        if text is not None:
            self.description_text = text

    def _add_photo_note(self, sender):
        note = dialogs.input_alert('Add photo note', 'Describe or reference the photo')
        if note:
            self.photos.append(note)

    def _add_video_note(self, sender):
        note = dialogs.input_alert('Add video note', 'Describe or reference the video')
        if note:
            self.videos.append(note)

    def _add_link(self, sender):
        label = dialogs.input_alert('Link label', 'Enter a label for this link')
        if not label:
            return
        url = dialogs.input_alert('Link URL', 'Enter the URL')
        if not url:
            return
        self.links.append({'label': label, 'url': url})

    def cancel(self, sender=None):
        if self.navigation_view: self.navigation_view.pop_view()
        else: self.close()

    def save(self, sender):
        # Get and validate the title
        title = (self.name_tf.text or '').strip()
        if not title:
            dialogs.hud_alert('Please enter a name.', 'error', 1.0)
            return

        # Created-at timestamp for the new item
        try:
            # Assumes `import datetime` is at the top of the file
            created_iso = datetime.datetime.now().isoformat(timespec='seconds')
        except Exception:
            created_iso = ''

        # Call back to the app so it can actually create + save the item
        if self.on_save:
            self.on_save(
                title,
                self.selected_hex,
                created_iso,
                self.due_at_iso,
                self.description_text,
                list(self.photos),
                list(self.videos),
                list(self.links),
            )

        # Show a quick confirmation
        dialogs.hud_alert('Item saved', 'success', 0.7)

        # Return the user to the main screen (list)
        if self.navigation_view:
            # We were pushed onto a NavigationView, so just pop this view
            self.navigation_view.pop_view()
        else:
            # Fallback – close if not in a nav stack
            self.close()
            
        # --- Additional content summary strip (New Entry) ---

    def _setup_additional_content_summary(self):
        """
        Create a simple summary strip at the bottom of the New Entry screen
        so users can see at a glance if they've added description, media
        and links. This aligns the New Entry experience with the item
        detail 'Additional content' card.
        """
        # Container view at the bottom
        sv = ui.View()
        sv.background_color = (0.96, 0.96, 0.98)
        sv.border_width = 1
        sv.border_color = (0.85, 0.85, 0.9)
        sv.name = 'Additional content summary'
        sv.flex = 'WT'

        # Labels inside the strip
        desc_lbl = ui.Label()
        desc_lbl.font = ('<System>', 13)
        desc_lbl.text_color = (0.2, 0.2, 0.25)
        desc_lbl.number_of_lines = 2
        desc_lbl.flex = 'W'

        media_lbl = ui.Label()
        media_lbl.font = ('<System>', 13)
        media_lbl.text_color = (0.2, 0.2, 0.25)
        media_lbl.flex = 'W'

        links_lbl = ui.Label()
        links_lbl.font = ('<System>', 13)
        links_lbl.text_color = (0.2, 0.2, 0.25)
        links_lbl.flex = 'W'

        sv.add_subview(desc_lbl)
        sv.add_subview(media_lbl)
        sv.add_subview(links_lbl)

        self._summary_view = sv
        self._summary_desc_label = desc_lbl
        self._summary_media_label = media_lbl
        self._summary_links_label = links_lbl

        self.add_subview(sv)

        # Initial content based on whatever defaults NewEntryView has
        self._refresh_additional_content_summary()

    def _refresh_additional_content_summary(self):
        """
        Use NewEntryView's working fields to populate the summary:
        - self.description_text
        - self.photos / self.videos
        - self.links
        """
        # Description
        desc = (getattr(self, 'description_text', '') or '').strip()
        if desc:
            short = desc
            if len(short) > 80:
                short = short[:77] + '...'
            self._summary_desc_label.text = 'Description: ' + short
        else:
            self._summary_desc_label.text = 'Description: (none)'

        # Media
        photos = getattr(self, 'photos', []) or []
        videos = getattr(self, 'videos', []) or []
        p_count = len(photos)
        v_count = len(videos)
        if p_count or v_count:
            parts = []
            if p_count:
                parts.append(f'{p_count} photo(s)')
            if v_count:
                parts.append(f'{v_count} video(s)')
            self._summary_media_label.text = 'Media: ' + ', '.join(parts)
        else:
            self._summary_media_label.text = 'Media: (none)'

        # Links
        links = getattr(self, 'links', []) or []
        l_count = len(links)
        if l_count == 0:
            self._summary_links_label.text = 'Links: (none)'
        elif l_count == 1:
            self._summary_links_label.text = 'Links: 1 link'
        else:
            self._summary_links_label.text = f'Links: {l_count} links'

    def layout(self):
        """
        Position the summary strip at the bottom without disturbing
        any existing controls. Existing subviews keep their frames.
        """
        # If a parent class / mixin had a layout, let it run first
        try:
            super(type(self), self).layout()
        except Exception:
            pass

        if not hasattr(self, '_summary_view'):
            return

        sv = self._summary_view
        inset = 10
        height = 80
        sv.frame = (inset,
                    self.height - height - inset,
                    self.width - 2 * inset,
                    height)

        # Layout labels inside the strip
        padding = 8
        line_h = (height - padding * 2) / 3.0
        self._summary_desc_label.frame = (padding, padding,
                                          sv.width - 2 * padding,
                                          line_h)
        self._summary_media_label.frame = (padding,
                                           padding + line_h,
                                           sv.width - 2 * padding,
                                           line_h)
        self._summary_links_label.frame = (padding,
                                           padding + 2 * line_h,
                                           sv.width - 2 * padding,
                                           line_h)

        # Each time layout runs, refresh the text in case fields changed
        self._refresh_additional_content_summary()


# -------------------------
# Table DataSource — custom “•••” pill, with sorting and group headers
# -------------------------

class _DescKey(object):
    """Wrapper so we can invert ordering per key rather than using reverse=."""

    def __init__(self, key):
        self.key = key

    def __lt__(self, other):
        return self.key > other.key


class TodoDataSource(object):
    def __init__(self, items, owner):
        self.items = items
        self.owner = owner
        # flat indices into self.items, in display order
        self.filtered_indices = []
        # list of (label, start_index, length) in filtered_indices
        self.group_spans = []
        self.refresh()

    # ------------- filter helpers -------------

    def _match_done(self, it):
        f = self.owner.filter_done
        if f == 'active':
            return not it.get('done', False)
        if f == 'done':
            return bool(it.get('done', False))
        return True

    def _match_category(self, it):
        sel = self.owner.filter_category_hexes
        return True if not sel else (it.get('color') in sel)

    def _match_name(self, it):
        terms = getattr(self.owner, 'filter_name_terms', [])
        if not terms:
            return True
        title = (it.get('title', '') or '').lower()
        return any(t in title for t in terms)

    def _match_created(self, it):
        cf = getattr(self.owner, 'filter_created_from', None)
        ct = getattr(self.owner, 'filter_created_to', None)
        if not cf and not ct:
            return True
        s = it.get('created_at', '') or ''
        if not s:
            return False
        try:
            created = parse_iso_or_now(s)
        except Exception:
            return False
        if cf and created < cf:
            return False
        if ct and created > ct:
            return False
        return True

    def _match_due(self, it):
        df = getattr(self.owner, 'filter_due_from', None)
        dtv = getattr(self.owner, 'filter_due_to', None)
        if not df and not dtv:
            return True
        s = it.get('due_at', '') or ''
        if not s:
            return False
        try:
            due = parse_iso_or_now(s)
        except Exception:
            return False
        if df and due < df:
            return False
        if dtv and due > dtv:
            return False
        return True

    # ------------- sort key helpers -------------

    def _primary_key(self, pair, mode):
        idx, it = pair
        if mode == SORT_MODE_MANUAL:
            return parse_iso_or_now(it.get('created_at', ''))
        if mode == SORT_MODE_DUE_DATE:
            iso = it.get('due_at') or ''
            if iso.strip():
                return parse_iso_or_now(iso)
            return datetime.max
        if mode == SORT_MODE_CATEGORY:
            hx = it.get('color') or '#8E8E93'
            name = (self.owner.categories.get(hx, '') or 'No Category')
            return name.lower()
        if mode == SORT_MODE_TITLE:
            return (it.get('title') or '').strip().lower()
        if mode == SORT_MODE_CREATED:
            return parse_iso_or_now(it.get('created_at', ''))
        if mode == SORT_MODE_STATUS:
            status = it.get('status') or ('completed' if it.get('done') else 'todo')
            order = {'todo': 0, 'in_progress': 1, 'waiting': 2, 'completed': 3}
            return order.get(status, 99)
        return idx

    def _orient(self, key, direction):
        if direction == 'desc':
            return _DescKey(key)
        return key

    def _key_pair(self, pair, mode1, dir1, mode2, dir2):
        pk = self._primary_key(pair, mode1)
        sk = self._primary_key(pair, mode2) if mode2 else 0
        return (self._orient(pk, dir1), self._orient(sk, dir2))

    # ------------- core refresh: filter, sort, group -------------

    def refresh(self):
        pairs = []
        for idx, it in enumerate(self.items):
            if (self._match_done(it)
                and self._match_category(it)
                and self._match_name(it)
                and self._match_created(it)
                and self._match_due(it)):
                pairs.append((idx, it))
    
        mode1 = getattr(self.owner, 'sort_mode', SORT_MODE_MANUAL)
        dir1 = getattr(self.owner, 'sort_direction_primary', 'asc')
        mode2 = getattr(self.owner, 'sort_mode_2', SORT_MODE_CREATED)
        dir2 = getattr(self.owner, 'sort_direction_secondary', 'asc')
    
        # Pick correct grouping
        if mode1 == SORT_MODE_DUE_DATE:
            groups = self._groups_by_due_date(pairs, mode1, dir1, mode2, dir2)
        elif mode1 == SORT_MODE_CATEGORY:
            groups = self._groups_by_category(pairs, mode1, dir1, mode2, dir2)
        elif mode1 == SORT_MODE_TITLE:
            groups = self._groups_by_title(pairs, mode1, dir1, mode2, dir2)
        elif mode1 == SORT_MODE_CREATED:
            groups = self._groups_by_created(pairs, mode1, dir1, mode2, dir2)
        elif mode1 == SORT_MODE_STATUS:
            groups = self._groups_by_status(pairs, mode1, dir1, mode2, dir2)
        else:
            # Manual (single flat list)
            pairs.sort(key=lambda p: self._key_pair(p, mode1, dir1, mode2, dir2))
            self.display_rows = [('item', idx) for (idx, _it) in pairs]
            return
    
        # Build FLAT display rows: [('header', 'Label'), ('item', idx), ...]
        self.display_rows = []
        for label, group_pairs in groups:
            # Add header row
            self.display_rows.append(('header', label))
            # Add item rows
            for idx, _it in group_pairs:
                self.display_rows.append(('item', idx))

    # ------------- grouping helpers -------------

    def _groups_by_due_date(self, pairs, mode1, dir1, mode2, dir2):
        today_d = datetime.now().date()
        tomorrow_d = today_d + timedelta(days=1)

        overdue = []
        no_due = []
        today_items = []
        tomorrow_items = []
        later_by_date = {}

        for idx, it in pairs:
            iso = it.get('due_at') or ''
            dt = parse_iso_or_now(iso) if iso.strip() else None
            d = dt.date() if dt else None

            if not d:
                no_due.append((idx, it))
            elif d < today_d:
                overdue.append((idx, it))
            elif d == today_d:
                today_items.append((idx, it))
            elif d == tomorrow_d:
                tomorrow_items.append((idx, it))
            else:
                later_by_date.setdefault(d, []).append((idx, it))

        def sort_bucket(bucket):
            bucket.sort(key=lambda p: self._key_pair(p, mode1, dir1, mode2, dir2))

        sort_bucket(overdue)
        sort_bucket(today_items)
        sort_bucket(tomorrow_items)
        for d in list(later_by_date.keys()):
            sort_bucket(later_by_date[d])

        # "No due date" sorted by created_at then secondary key
        no_due.sort(
            key=lambda p: (
                self._orient(parse_iso_or_now(p[1].get('created_at', '')), dir1),
                self._orient(self._primary_key(p, mode2), dir2),
            )
        )

        groups = []
        if overdue:
            groups.append(('Overdue', overdue))
        if no_due:
            groups.append(('No due date', no_due))
        if today_items:
            label = 'Today · {}'.format(today_d.strftime('%a %d %b %Y'))
            groups.append((label, today_items))
        if tomorrow_items:
            label = 'Tomorrow · {}'.format(tomorrow_d.strftime('%a %d %b %Y'))
            groups.append((label, tomorrow_items))
        for d in sorted(later_by_date.keys()):
            label = d.strftime('%a %d %b %Y')
            groups.append((label, later_by_date[d]))
        return groups

    def _groups_by_category(self, pairs, mode1, dir1, mode2, dir2):
        buckets = {}
        for idx, it in pairs:
            hx = it.get('color') or '#8E8E93'
            name = (self.owner.categories.get(hx, '') or '').strip()
            if not name:
                name = 'No Category'
            buckets.setdefault(name, []).append((idx, it))

        names = sorted([n for n in buckets.keys() if n != 'No Category'])
        if 'No Category' in buckets:
            names.append('No Category')

        for n in names:
            buckets[n].sort(key=lambda p: self._key_pair(p, mode1, dir1, mode2, dir2))

        return [(n, buckets[n]) for n in names]

    def _groups_by_title(self, pairs, mode1, dir1, mode2, dir2):
        pairs = sorted(
            pairs,
            key=lambda p: self._key_pair(p, mode1, dir1, mode2, dir2),
        )

        buckets = {}
        for idx, it in pairs:
            title = (it.get('title') or '').strip()
            if not title:
                key = '#'
            else:
                first = title[0].upper()
                if 'A' <= first <= 'Z':
                    key = first
                elif '0' <= first <= '9':
                    key = '#'
                else:
                    key = '#'
            buckets.setdefault(key, []).append((idx, it))

        keys = sorted(buckets.keys())
        if '#' in keys:
            keys.remove('#')
            keys.append('#')

        groups = []
        for k in keys:
            label = k if k != '#' else '0-9 / Other'
            groups.append((label, buckets[k]))
        return groups

    def _groups_by_created(self, pairs, mode1, dir1, mode2, dir2):
        today_d = datetime.now().date()
        last7_start = today_d - timedelta(days=6)
        first_of_month = today_d.replace(day=1)

        last7 = []
        earlier_this_month = []
        by_month = {}

        for idx, it in pairs:
            created = parse_iso_or_now(it.get('created_at', ''))
            d = created.date()
            if d >= last7_start:
                last7.append((idx, it))
            elif first_of_month <= d < last7_start:
                earlier_this_month.append((idx, it))
            else:
                key = (d.year, d.month)
                by_month.setdefault(key, []).append((idx, it))

        def sort_bucket(bucket):
            bucket.sort(key=lambda p: self._key_pair(p, mode1, dir1, mode2, dir2))

        sort_bucket(last7)
        sort_bucket(earlier_this_month)
        for key in list(by_month.keys()):
            sort_bucket(by_month[key])

        groups = []
        if last7:
            groups.append(('Last 7 days', last7))
        if earlier_this_month:
            groups.append(('Earlier this month', earlier_this_month))
        for (y, m) in sorted(by_month.keys(), reverse=False):
            d = date(y, m, 1)
            label = d.strftime('%b %Y')
            groups.append((label, by_month[(y, m)]))
        return groups

    def _groups_by_status(self, pairs, mode1, dir1, mode2, dir2):
        order = ['todo', 'in_progress', 'waiting', 'completed']
        label_map = {
            'todo': 'To do',
            'in_progress': 'In progress',
            'waiting': 'Waiting',
            'completed': 'Completed',
        }
        buckets = {k: [] for k in order}
        other = []

        for idx, it in pairs:
            status = it.get('status') or ('completed' if it.get('done') else 'todo')
            if status in buckets:
                buckets[status].append((idx, it))
            else:
                other.append((idx, it))

        def sort_bucket(bucket):
            bucket.sort(key=lambda p: self._key_pair(p, mode1, dir1, mode2, dir2))

        for k in order:
            sort_bucket(buckets[k])
        sort_bucket(other)

        groups = []
        for k in order:
            if buckets[k]:
                groups.append((label_map.get(k, k.title()), buckets[k]))
        if other:
            groups.append(('Other', other))
        return groups

    # ------------- mapping helpers -------------

    def _use_headers(self):
        mode = getattr(self.owner, 'sort_mode', SORT_MODE_MANUAL)
        show = getattr(self.owner, 'sort_show_headers', True)
    
        # Must have groups OR Pythonista won't show anything
        has_groups = bool(self.group_spans)
    
        return (show and has_groups and mode != SORT_MODE_MANUAL)

    def _item_for_position(self, section, row):
        """Return (item_dict, original_index) for a given table position."""
        if self._use_headers():
            _label, start, length = self.group_spans[section]
            flat_index = start + row
        else:
            flat_index = row
        orig_idx = self.filtered_indices[flat_index]
        return self.items[orig_idx], orig_idx

    # ------------- table view data source methods -------------

    # Single section always
    def tableview_number_of_sections(self, tv):
        return 1
    
    def tableview_number_of_rows(self, tv, section):
        return len(self.display_rows)
    
    # These must return 0 / None so UIKit never draws its own headers
    def tableview_view_for_header(self, tv, section):
        return None
    
    def tableview_height_for_header(self, tv, section):
        return 0
        
        
        
    def tableview_cell_for_row(self, tv, section, row):
        kind, payload = self.display_rows[row]
    
        cell = ui.TableViewCell()
    
        # -----------------------------
        # HEADER ROW
        # -----------------------------
        if kind == 'header':
            cell.background_color = (0.96, 0.96, 0.98)
            cell.text_label.text = payload
            cell.text_label.font = ('<System-Bold>', 14)
            cell.text_label.text_color = 'black'
            # Disable interaction
            cell.selectable = False
            return cell
    
        # -----------------------------
        # ITEM ROW
        # -----------------------------
        orig_idx = payload
        item = self.items[orig_idx]
    
        title = item.get('title', '')
        if item.get('done'):
            title = '✓ ' + title
            cell.text_label.alpha = 0.55
        else:
            cell.text_label.alpha = 1.0
        cell.text_label.text = title
    
        # Background + text colour
        hexc = item.get('color', '#8E8E93')
        try:
            cell.background_color = hex_to_ui_color(hexc)
        except:
            cell.background_color = 'white'
            hexc = '#8E8E93'
    
        fg = best_text_color_for_bg(hexc)
        cell.text_label.text_color = fg
    
        # Remove old "•••" buttons
        for sv in list(cell.content_view.subviews):
            if getattr(sv, 'name', '') == 'more_btn':
                cell.content_view.remove_subview(sv)
    
        # Rebuild the "•••" button
        BTN_W, BTN_H = 36, 24
        btn = ui.Button(title='•••')
        btn.name = 'more_btn'
        btn.width, btn.height = BTN_W, BTN_H
        btn.corner_radius = 6
        btn.border_width = 0
        btn.background_color = (0, 0, 0, 0)
        btn.tint_color = fg
        btn.font = ('<System-Bold>', int(BTN_H * 0.9))
        x = cell.content_view.width - BTN_W - 12
        y = int((cell.content_view.height - BTN_H) / 2)
        btn.frame = (x, y, BTN_W, BTN_H)
        btn.flex = 'L'
        btn.action = (lambda s, idx=orig_idx: self._open_detail_direct(tv, idx))
        cell.content_view.add_subview(btn)
    
        return cell
        
    def _open_detail_direct(self, tv, orig_idx):
        """Open the item detail view when the ••• button is tapped."""
        item_ref = self.items[orig_idx]

        def on_save(_updated):
            # Item has already been mutated in-place
            save_items(self.items)
            self.refresh()
            tv.reload_data()

        def on_cats_change(_cats):
            # Update categories on the owner and rebuild filters
            self.owner.categories = _cats
            self.owner._rebuild_filter_summary()
            tv.reload_data()

        detail = ItemDetailView(
            item=item_ref,
            categories=self.owner.categories,
            on_save=on_save,
            on_cats_change=on_cats_change,
        )
        if self.owner.navigation_view:
            _safe_push(self.owner.navigation_view, detail)
        else:
            ui.NavigationView(detail).present('fullscreen')

    def tableview_can_delete(self, tv, section, row):
        kind, payload = self.display_rows[row]
        return (kind == 'item')


    def _open_detail_for_row(self, tv, section, row):
        item_ref, orig_idx = self._item_for_position(section, row)

        def on_save(_updated_item):
            save_items(self.items)
            self.refresh()
            tv.reload_data()

        def on_cats_change(_cats):
            self.owner.categories = _cats
            self.owner._rebuild_filter_summary()
            tv.reload_data()

        detail = ItemDetailView(item=item_ref, categories=self.owner.categories,
                                on_save=on_save, on_cats_change=on_cats_change)
        if self.owner.navigation_view:
            _safe_push(self.owner.navigation_view, detail)
        else:
            ui.NavigationView(detail).present('fullscreen')

    def tableview_can_delete(self, tv, section, row):
        kind, payload = self.display_rows[row]
        return (kind == 'item')

    def tableview_delete(self, tv, section, row):
        kind, payload = self.display_rows[row]
        if kind != 'item':
            return
        del self.items[payload]
        save_items(self.items)
        self.refresh()
        tv.reload_data()
    
    def tableview_did_select(self, tv, section, row):
        kind, payload = self.display_rows[row]
        if kind != 'item':
            return
    
        it = self.items[payload]
        it['done'] = not it.get('done')
        save_items(self.items)
        haptic_success()
        self.refresh()
        tv.reload_data()
    
# -------------------------
# Main App View
# -------------------------
# -------------------------
# Main App View
# -------------------------
class TodoApp(ui.View):
    def __init__(self):
        super().__init__()
        self.name = 'To-Do'
        self.background_color = 'white'

        # Load data
        self.items = load_items()
        self.categories = load_categories()

        # Advanced filter state
        self.filter_done = 'all'
        self.filter_category_hexes = set()
        self.filter_name_terms = []
        self.filter_created_from = None
        self.filter_created_to = None
        self.filter_due_from = None
        self.filter_due_to = None

        # Sort state
        self.sort_settings = SortSettings.load_from_disk()
        self.sort_settings.apply_user_default()
        self.sort_mode = self.sort_settings.mode                       # primary
        self.sort_direction_primary = self.sort_settings.direction_primary
        self.sort_mode_2 = self.sort_settings.secondary_mode           # secondary
        self.sort_direction_secondary = self.sort_settings.direction_secondary
        self.sort_show_headers = self.sort_settings.show_headers

        # Data source (must exist before we hook it up to the table)
        self.ds = TodoDataSource(self.items, self)

        # --- UI setup starts here ---
        gold = '#D4AF37'
        dark_gold = '#6E5A12'
        self.banner = ui.View(frame=(12, 8, self.width - 24, 64), flex='W')
        self.banner.background_color = 'black'
        self.banner.corner_radius = 12
        self.banner.border_width = 1
        self.banner.border_color = hex_to_ui_color(gold)
        self.add_subview(self.banner)

        self.banner_shadow = ui.Label(frame=(18, 14, self.banner.width - 36, 36), flex='W')
        self.banner_shadow.text = "Matt’s To Do List📋"
        self.banner_shadow.font = ('Arial-BoldMT', 28)
        self.banner_shadow.text_color = hex_to_ui_color(dark_gold)
        self.banner_shadow.alignment = ui.ALIGN_CENTER
        self.banner.add_subview(self.banner_shadow)

        self.banner_title = ui.Label(frame=(16, 12, self.banner.width - 32, 36), flex='W')
        self.banner_title.text = "Matt’s To Do List📋"
        self.banner_title.font = ('Arial-BoldMT', 28)
        self.banner_title.text_color = hex_to_ui_color(gold)
        self.banner_title.alignment = ui.ALIGN_CENTER
        self.banner.add_subview(self.banner_title)

        self.banner_underline = ui.View(frame=(12, self.banner.y + self.banner.height + 4, self.width - 24, 2), flex='W')
        self.banner_underline.background_color = hex_to_ui_color(gold)
        self.add_subview(self.banner_underline)

        self.header = ui.View(frame=(12, self.banner_underline.y + 8, self.width - 24, 152), flex='W')
        self.header.background_color = (0.95, 0.95, 0.97)
        self.header.corner_radius = 12
        self.header.border_width = 1
        self.header.border_color = (0.86, 0.86, 0.9)
        self.add_subview(self.header)

        self.title_lbl = ui.Label(frame=(16, 10, self.header.width - 32, 20), flex='W')
        self.title_lbl.text = 'Actions'
        self.title_lbl.font = ('<System-Bold>', 16)
        self.header.add_subview(self.title_lbl)

        self.seg_container = ui.View(frame=(16, 34, self.header.width - 32, 32), flex='W')
        self.header.add_subview(self.seg_container)
        self.seg_btns = []

        def make_seg_action(value):
            return lambda sender: self._set_done_filter(value)

        for label, val in [('All', 'all'), ('Active', 'active'), ('Done', 'done')]:
            b = ui.Button()
            b.title = label
            b.action = make_seg_action(val)
            b.corner_radius = 6
            b.border_width = 1
            b.border_color = (0.8, 0.8, 0.85)
            b.background_color = (1, 1, 1)
            b.tint_color = (0.1, 0.1, 0.2)
            self.seg_container.add_subview(b)
            self.seg_btns.append((b, val))

        # Header action buttons in one clean row
        self.btn_cats      = self._make_btn('Categories', self.action_categories)
        self.btn_filter    = self._make_btn('Filter', self.action_filter_category)
        self.btn_clearflt  = self._make_btn('Clear Filter', self.action_clear_filter)
        self.btn_sort      = self._make_btn('Sort', self.action_sort)
        self.btn_knowledge = self._make_btn('Knowledge', self.action_knowledge)

        for b in (self.btn_cats, self.btn_filter, self.btn_clearflt, self.btn_sort, self.btn_knowledge):
            self.header.add_subview(b)

        self.section_lbl = ui.Label(frame=(16, self.header.y + self.header.height + 13, self.width - 32, 22), flex='W')
        self.section_lbl.text = 'Your Tasks'
        self.section_lbl.font = ('<System-Bold>', 25)
        self.add_subview(self.section_lbl)

        self.filters_lbl = ui.Label(frame=(16, self.section_lbl.y + 25, self.width - 32, 16), flex='W')
        self.filters_lbl.font = ('<System>', 12)
        self.filters_lbl.text_color = (0.35, 0.35, 0.4)
        self.add_subview(self.filters_lbl)

        self.chip_bar = ui.View(frame=(16, self.filters_lbl.y + 20, self.width - 32, 20), flex='W')
        self.add_subview(self.chip_bar)
        self.chip_bar.hidden = True

        self.chip_bar_btn = ui.Button(frame=self.chip_bar.bounds, flex='WH')
        self.chip_bar_btn.background_color = (0, 0, 0, 0)
        self.chip_bar_btn.action = self._chip_bar_tapped_clear
        self.chip_bar.add_subview(self.chip_bar_btn)

        self.list_card = ui.View(frame=(12, self.chip_bar.y + 5, self.width - 24, self.height - (self.chip_bar.y + 12 + 5)), flex='WH')
        self.list_card.background_color = (0.98, 0.98, 0.99)
        self.list_card.corner_radius = 12
        self.list_card.border_width = 1
        self.list_card.border_color = (0.9, 0.9, 0.93)
        self.add_subview(self.list_card)

        self.table = ui.TableView(frame=self.list_card.bounds, flex='WH')
        self.table.data_source = self.ds
        self.table.delegate = self.ds
        self.table.row_height = 46
        self.list_card.add_subview(self.table)

        self._set_done_filter('all')
        self._rebuild_filter_summary()

        self.plus_btn = ui.Button()
        self.plus_btn.title = '+'
        self.plus_btn.action = self.action_add
        self.plus_btn.width = self.plus_btn.height = 60
        self.plus_btn.corner_radius = 60
        self.plus_btn.border_width = 0
        self.plus_btn.border_color = (0.8, 0.8, 0.85)
        self.plus_btn.background_color = (1, 1, 1)
        self.plus_btn.tint_color = (0, 0, 0)
        self.plus_btn.font = ('<System-Bold>', 47)
        self.add_subview(self.plus_btn)
        
        # Force group generation before first render
        self.ds.refresh()
        self.table.reload_data()

    def _make_btn(self, title, action):
        b = ui.Button()
        b.title = title
        b.action = action
        b.corner_radius = 8
        b.border_width = 1
        b.border_color = (0.8, 0.8, 0.85)
        b.background_color = (1, 1, 1)
        b.tint_color = (0.1, 0.1, 0.2)
        return b

    def _layout_hline(self, buttons, y):
        n = len(buttons)
        if n == 0:
            return
        left, right, gap = 16, self.header.width - 16, 8
        w = (right - left - gap * (n - 1)) / float(n)
        x = left
        for b in buttons:
            b.frame = (x, y, w, 36)
            x += w + gap

    def _layout_segmented(self):
        n = len(self.seg_btns)
        left, right, gap = 0, self.seg_container.width, 6
        w = (right - gap * (n - 1)) / float(n)
        x = 0
        for (b, _v) in self.seg_btns:
            b.frame = (x, 0, w, 32)
            x += w + gap

    def _selected_names(self):
        names = []
        for base_name, hx in _PALETTE:
            if hx in self.filter_category_hexes:
                names.append(self.categories.get(hx, '') or base_name)
        return names

    def _rebuild_filter_summary(self):
        status = {'all': 'All', 'active': 'Active', 'done': 'Done'}[self.filter_done]
        sel = list(self.filter_category_hexes)

        if not sel:
            base = f'Status: {status} | Category: All Categories'
        else:
            names = self._selected_names()
            base = (
                f"Status: {status} | Category: {names[0]}" if len(names) == 1
                else f"Status: {status} | Categories: {len(names)} selected"
            )

        adv = []
        if self.filter_name_terms:
            adv.append('Name')
        if self.filter_created_from or self.filter_created_to:
            adv.append('Created')
        if self.filter_due_from or self.filter_due_to:
            adv.append('Due')
        if adv:
            base += ' | ' + ', '.join(adv) + ' filters'

        # Add sort summary
        base += ' | Sort: ' + self._sort_summary()

        self.filters_lbl.text = base
        if not sel:
            self.chip_bar.hidden = True
            return

        self.chip_bar.hidden = False
        for v in list(self.chip_bar.subviews):
            if v is self.chip_bar_btn:
                continue
            self.chip_bar.remove_subview(v)

        MAX = 6
        padding = 4
        size = 16
        x = 0
        shown = 0
        for hx in sel[:MAX]:
            chip = ui.View(frame=(x, 0, size, size))
            chip.corner_radius = 4
            chip.border_width = 1
            chip.border_color = (0.8, 0.8, 0.85)
            try:
                chip.background_color = hex_to_ui_color(hx)
            except Exception:
                chip.background_color = 'white'
            self.chip_bar.add_subview(chip)
            x += size + padding
            shown += 1
        extra = len(sel) - shown
        if extra > 0:
            more_lbl = ui.Label(frame=(x, -2, 50, size + 4))
            more_lbl.text = f'+{extra}'
            more_lbl.font = ('<System>', 12)
            more_lbl.text_color = (0.35, 0.35, 0.4)
            self.chip_bar.add_subview(more_lbl)
            x += 24
        self.chip_bar_btn.frame = (0, 0, max(x, 44), size)
        
    def _tint_section_headers(self):
        """Force default iOS section headers to be black."""
        try:
            tv = ObjCInstance(self.table)
            UIColor = ObjCClass('UIColor')
            black = UIColor.blackColor()

            sections = tv.numberOfSections()
            for i in range(sections):
                header = tv.headerViewForSection_(i)
                if header:
                    label = header.textLabel()
                    if label:
                        label.setTextColor_(black)
        except Exception:
            pass

    def _reload_and_tint(self):
        """Reload table then recolor headers once UIKit creates them."""
        self.table.reload_data()
        ui.delay(self._tint_section_headers, 0.01)
        
    def _sort_summary(self):
        label_map = {
            SORT_MODE_MANUAL:   'Manual',
            SORT_MODE_DUE_DATE: 'Due date',
            SORT_MODE_CATEGORY: 'Category',
            SORT_MODE_TITLE:    'Title A-Z',
            SORT_MODE_CREATED:  'Created date',
            SORT_MODE_STATUS:   'Status',
        }
        primary = label_map.get(self.sort_mode, 'Manual')
        secondary = label_map.get(getattr(self, 'sort_mode_2', None), None)
        if secondary and secondary != primary:
            return f'{primary} then {secondary}'
        return primary


    def _set_done_filter(self, val):
        self.filter_done = val
        for (b, v) in self.seg_btns:
            if v == val:
                b.background_color = (0.92, 0.92, 0.96)
                b.border_color = (0.4, 0.4, 0.6)
            else:
                b.background_color = (1, 1, 1)
                b.border_color = (0.8, 0.8, 0.85)
        self.ds.refresh()
        self._rebuild_filter_summary()
        self._reload_and_tint()
        self._tint_section_headers()

    def _apply_sort_settings(self, settings, set_as_default=False):
        """Receive settings from Sort panel and refresh list."""
        self.sort_settings = settings
        self.sort_mode = settings.mode
        self.sort_direction_primary = settings.direction_primary
        self.sort_mode_2 = settings.secondary_mode
        self.sort_direction_secondary = settings.direction_secondary
        self.sort_show_headers = settings.show_headers
        if set_as_default:
            settings.save_to_disk()
        self.ds.refresh()
        self._rebuild_filter_summary()
        self._reload_and_tint()
        self._tint_section_headers()

    def action_sort(self, sender):
        """Open Sort panel."""
        panel = SortPanelView(
            sort_settings=self.sort_settings,
            on_apply=self._apply_sort_settings,
            on_clear_filters=self.action_clear_filter_from_sort)
        _safe_push(self.navigation_view, panel)

    def action_clear_filter_from_sort(self):
        """Handler for Sort panel Clear filters button."""
        self.action_clear_filter(None)
    def action_clear_filter_from_sort(self):
        """Handler for Sort panel Clear filters button."""
        self.action_clear_filter(None)

    def layout(self):
        self.banner.frame = (12, 8, self.width - 24, 64)
        self.banner_shadow.frame = (18, 14, self.banner.width - 36, 36)
        self.banner_title.frame  = (16, 12, self.banner.width - 32, 36)
        self.banner_underline.frame = (12, self.banner.y + self.banner.height + 4, self.width - 24, 2)

        self.header.frame = (12, self.banner_underline.y + 8, self.width - 24, 152)
        self.title_lbl.width = self.header.width - 32
        self.seg_container.frame = (16, 34, self.header.width - 32, 32)
        self._layout_segmented()
        # Now five header buttons, including Sort and Knowledge
        self._layout_hline(
            [self.btn_cats, self.btn_filter, self.btn_clearflt, self.btn_sort, self.btn_knowledge],
            y=74
        )

        self.section_lbl.frame = (16, self.header.y + self.header.height + 13, self.width - 32, 22)
        self.filters_lbl.frame = (16, self.section_lbl.y + 25, self.width - 32, 16)
        self.chip_bar.frame = (16, self.filters_lbl.y + 20, self.width - 32, 20)
        self.chip_bar_btn.frame = self.chip_bar.bounds

        list_top = self.chip_bar.y + 5
        self.list_card.frame = (12, list_top, self.width - 24, self.height - (list_top + 12))
        self.table.frame = self.list_card.bounds

        pad_right_for_pill = 12
        size = self.plus_btn.width
        plus_x = self.list_card.x + self.list_card.width - pad_right_for_pill - size + 13
        plus_y = self.section_lbl.y + int((self.section_lbl.height - size) / 2) + 7
        self.plus_btn.frame = (plus_x, plus_y, size, size)
        self.plus_btn.bring_to_front()

    def _chip_bar_tapped_clear(self, sender):
        if not self.filter_category_hexes:
            return
        self.filter_category_hexes.clear()
        self.ds.refresh()
        self._rebuild_filter_summary()
        self._reload_and_tint()
        dialogs.hud_alert('Color filter cleared', 'success', 0.6)

    def action_add(self, sender):
        """Open the NewEntryView and handle creation of a new item."""

        def on_save(title, color_hex, created_iso, due_iso, *extra):
            """
            Callback from NewEntryView.save.

            Parameters:
                title       (str)
                color_hex   (str)
                created_iso (str, ISO datetime)
                due_iso     (str or None)
                *extra      optional: description_text, photos, videos, links
            """
            # Unpack any extra data the NewEntryView sends
            description = ''
            photos = []
            videos = []
            links = []
            if len(extra) >= 4:
                description, photos, videos, links = extra[:4]

            # Build the new item dict
            new_item = {
                'title': title,
                'done': False,
                'color': color_hex,
                'created_at': created_iso or '',
                'due_at': due_iso or '',
                # Additional content
                'description': description or '',
                'links': list(links) if isinstance(links, list) else [],
                'media': [],  # you can later convert photos/videos into media if you like
            }

            # Ensure the new item matches the additional-content schema everywhere
            ensure_additional_content_fields(new_item)

            # Save into list + disk + refresh UI
            self.items.append(new_item)
            save_items(self.items)
            self.ds.items = self.items
            self.ds.refresh()
            self.table.reload_data()

        # Show the NewEntryView for user input
        view = NewEntryView(on_save=on_save, cats=self.categories)
        _safe_push(self.navigation_view, view)

    def action_categories(self, sender):
        def on_change(cats):
            self.categories = cats
            self._rebuild_filter_summary()
            self.table.reload_data()
        view = CategoriesView(_PALETTE, self.categories, on_change=on_change)
        _safe_push(self.navigation_view, view)

    def action_filter_category(self, sender):
        view = FilterView(self)
        _safe_push(self.navigation_view, view)

    def action_clear_filter(self, sender):
        self.filter_category_hexes.clear()
        self.filter_name_terms = []
        self.filter_created_from = None
        self.filter_created_to = None
        self.filter_due_from = None
        self.filter_due_to = None
        self._set_done_filter('all')
        dialogs.hud_alert('All filters cleared', 'success', 0.6)

    def action_knowledge(self, sender):
        """Open the Knowledge section from the main To Do screen."""
        view = KnowledgeCenterView()
        nav = self.navigation_view
        if nav:
            _safe_push(nav, view)
        else:
            view.present('sheet')

    def will_close(self):
        save_items(self.items)
        save_categories(self.categories)

# -------------------------
# Presentation guards
# -------------------------
_APP_PRESENTING = False
_LAST_PUSH_TS = 0.0

def _safe_present_root(nav_view, mode='fullscreen'):
    global _APP_PRESENTING
    if getattr(nav_view, 'superview', None) is not None or _APP_PRESENTING:
        return
    _APP_PRESENTING = True
    def _do():
        global _APP_PRESENTING
        try:
            nav_view.present(mode)
        except ValueError as e:
            if 'already being presented' not in str(e) and 'animation is in progress' not in str(e):
                raise
        finally:
            _APP_PRESENTING = False
    ui.delay(_do, 0.30)

def _safe_push(nav_view, child_view, min_gap=0.30):
    global _LAST_PUSH_TS
    now = time.monotonic()
    gap = now - _LAST_PUSH_TS
    def _do_push():
        global _LAST_PUSH_TS
        try:
            nav_view.push_view(child_view)
        except ValueError as e:
            if 'animation is in progress' in str(e) or 'already being presented' in str(e):
                ui.delay(lambda: _safe_push(nav_view, child_view, min_gap), min_gap)
                return
            else:
                raise
        _LAST_PUSH_TS = time.monotonic()
    if gap < min_gap:
        ui.delay(_do_push, min_gap - gap)
    else:
        _do_push()

# -------------------------
# Entry point (safe present)
# -------------------------
if __name__ == '__main__':
    try:
        ui.cancel_delays()
    except Exception:
        pass
    root = TodoApp()
    nav = ui.NavigationView(root)
    nav.navigation_bar_hidden = False
    _safe_present_root(nav, 'fullscreen')